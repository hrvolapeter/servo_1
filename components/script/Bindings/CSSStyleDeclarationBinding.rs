/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */

#![allow(non_camel_case_types,non_upper_case_globals,unused_imports,unused_variables,unused_assignments,unused_mut)]
use dom;
use dom::bindings;
use dom::bindings::callback::CallSetup;
use dom::bindings::callback::CallbackContainer;
use dom::bindings::callback::CallbackFunction;
use dom::bindings::callback::CallbackInterface;
use dom::bindings::callback::CallbackObject;
use dom::bindings::callback::ExceptionHandling;
use dom::bindings::callback::wrap_call_this_object;
use dom::bindings::codegen::InterfaceObjectMap;
use dom::bindings::codegen::PrototypeList;
use dom::bindings::codegen::RegisterBindings;
use dom::bindings::codegen::UnionTypes;
use dom::bindings::constant::ConstantSpec;
use dom::bindings::constant::ConstantVal;
use dom::bindings::conversions::ConversionBehavior;
use dom::bindings::conversions::ConversionResult;
use dom::bindings::conversions::DOM_OBJECT_SLOT;
use dom::bindings::conversions::FromJSValConvertible;
use dom::bindings::conversions::IDLInterface;
use dom::bindings::conversions::StringificationBehavior;
use dom::bindings::conversions::ToJSValConvertible;
use dom::bindings::conversions::is_array_like;
use dom::bindings::conversions::jsid_to_string;
use dom::bindings::conversions::native_from_handlevalue;
use dom::bindings::conversions::native_from_object;
use dom::bindings::conversions::private_from_object;
use dom::bindings::conversions::root_from_handleobject;
use dom::bindings::conversions::root_from_handlevalue;
use dom::bindings::conversions::root_from_object;
use dom::bindings::error::Error;
use dom::bindings::error::Error::JSFailed;
use dom::bindings::error::ErrorResult;
use dom::bindings::error::Fallible;
use dom::bindings::error::throw_dom_exception;
use dom::bindings::guard::Condition;
use dom::bindings::guard::Guard;
use dom::bindings::htmlconstructor::html_constructor;
use dom::bindings::htmlconstructor::pop_current_element_queue;
use dom::bindings::htmlconstructor::push_new_element_queue;
use dom::bindings::inheritance::Castable;
use dom::bindings::interface::ConstructorClassHook;
use dom::bindings::interface::InterfaceConstructorBehavior;
use dom::bindings::interface::NonCallbackInterfaceObjectClass;
use dom::bindings::interface::create_callback_interface_object;
use dom::bindings::interface::create_global_object;
use dom::bindings::interface::create_interface_prototype_object;
use dom::bindings::interface::create_named_constructors;
use dom::bindings::interface::create_noncallback_interface_object;
use dom::bindings::interface::define_guarded_constants;
use dom::bindings::interface::define_guarded_methods;
use dom::bindings::interface::define_guarded_properties;
use dom::bindings::interface::is_exposed_in;
use dom::bindings::iterable::Iterable;
use dom::bindings::iterable::IteratorType;
use dom::bindings::mozmap::MozMap;
use dom::bindings::namespace::NamespaceObjectClass;
use dom::bindings::namespace::create_namespace_object;
use dom::bindings::num::Finite;
use dom::bindings::proxyhandler;
use dom::bindings::proxyhandler::ensure_expando_object;
use dom::bindings::proxyhandler::fill_property_descriptor;
use dom::bindings::proxyhandler::get_expando_object;
use dom::bindings::proxyhandler::get_property_descriptor;
use dom::bindings::reflector::DomObject;
use dom::bindings::reflector::MutDomObject;
use dom::bindings::root::Dom;
use dom::bindings::root::DomRoot;
use dom::bindings::root::OptionalHeapSetter;
use dom::bindings::root::RootedReference;
use dom::bindings::str::ByteString;
use dom::bindings::str::DOMString;
use dom::bindings::str::USVString;
use dom::bindings::trace::JSTraceable;
use dom::bindings::trace::RootedTraceable;
use dom::bindings::trace::RootedTraceableBox;
use dom::bindings::utils::AsVoidPtr;
use dom::bindings::utils::DOMClass;
use dom::bindings::utils::DOMJSClass;
use dom::bindings::utils::DOM_PROTO_UNFORGEABLE_HOLDER_SLOT;
use dom::bindings::utils::JSCLASS_DOM_GLOBAL;
use dom::bindings::utils::ProtoOrIfaceArray;
use dom::bindings::utils::enumerate_global;
use dom::bindings::utils::finalize_global;
use dom::bindings::utils::find_enum_value;
use dom::bindings::utils::generic_getter;
use dom::bindings::utils::generic_lenient_getter;
use dom::bindings::utils::generic_lenient_setter;
use dom::bindings::utils::generic_method;
use dom::bindings::utils::generic_setter;
use dom::bindings::utils::get_array_index_from_id;
use dom::bindings::utils::get_dictionary_property;
use dom::bindings::utils::get_property_on_prototype;
use dom::bindings::utils::get_proto_or_iface_array;
use dom::bindings::utils::has_property_on_prototype;
use dom::bindings::utils::is_platform_object;
use dom::bindings::utils::resolve_global;
use dom::bindings::utils::set_dictionary_property;
use dom::bindings::utils::trace_global;
use dom::bindings::weakref::DOM_WEAK_SLOT;
use dom::bindings::weakref::WeakBox;
use dom::bindings::weakref::WeakReferenceable;
use dom::globalscope::GlobalScope;
use dom::windowproxy::WindowProxy;
use js;
use js::JSCLASS_GLOBAL_SLOT_COUNT;
use js::JSCLASS_IS_DOMJSCLASS;
use js::JSCLASS_IS_GLOBAL;
use js::JSCLASS_RESERVED_SLOTS_MASK;
use js::JS_CALLEE;
use js::error::throw_internal_error;
use js::error::throw_type_error;
use js::glue::AppendToAutoIdVector;
use js::glue::CallJitGetterOp;
use js::glue::CallJitMethodOp;
use js::glue::CallJitSetterOp;
use js::glue::CreateProxyHandler;
use js::glue::GetProxyPrivate;
use js::glue::ProxyTraps;
use js::glue::RUST_JSID_IS_INT;
use js::glue::RUST_JSID_IS_STRING;
use js::glue::RUST_SYMBOL_TO_JSID;
use js::glue::UnwrapObject;
use js::glue::int_to_jsid;
use js::jsapi::AutoIdVector;
use js::jsapi::CallArgs;
use js::jsapi::CurrentGlobalOrNull;
use js::jsapi::FreeOp;
use js::jsapi::GetWellKnownSymbol;
use js::jsapi::Handle as RawHandle;
use js::jsapi::HandleId as RawHandleId;
use js::jsapi::HandleObject as RawHandleObject;
use js::jsapi::HandleValue as RawHandleValue;
use js::jsapi::HandleValueArray;
use js::jsapi::Heap;
use js::jsapi::INTERNED_STRING_TO_JSID;
use js::jsapi::IsCallable;
use js::jsapi::JSAutoCompartment;
use js::jsapi::JSCLASS_RESERVED_SLOTS_SHIFT;
use js::jsapi::JSClass;
use js::jsapi::JSContext;
use js::jsapi::JSFreeOp;
use js::jsapi::JSFunctionSpec;
use js::jsapi::JSITER_HIDDEN;
use js::jsapi::JSITER_OWNONLY;
use js::jsapi::JSITER_SYMBOLS;
use js::jsapi::JSJitGetterCallArgs;
use js::jsapi::JSJitInfo;
use js::jsapi::JSJitInfo_AliasSet;
use js::jsapi::JSJitInfo_ArgType;
use js::jsapi::JSJitInfo_OpType;
use js::jsapi::JSJitMethodCallArgs;
use js::jsapi::JSJitSetterCallArgs;
use js::jsapi::JSNative;
use js::jsapi::JSNativeWrapper;
use js::jsapi::JSObject;
use js::jsapi::JSPROP_ENUMERATE;
use js::jsapi::JSPROP_PERMANENT;
use js::jsapi::JSPROP_READONLY;
use js::jsapi::JSPROP_SHARED;
use js::jsapi::JSPropertySpec;
use js::jsapi::JSString;
use js::jsapi::JSTracer;
use js::jsapi::JSType;
use js::jsapi::JSTypedMethodJitInfo;
use js::jsapi::JSValueType;
use js::jsapi::JS_AtomizeAndPinString;
use js::jsapi::JS_ForwardGetPropertyTo;
use js::jsapi::JS_GetErrorPrototype;
use js::jsapi::JS_GetGlobalForObject;
use js::jsapi::JS_GetIteratorPrototype;
use js::jsapi::JS_GetPropertyById;
use js::jsapi::JS_GetPropertyDescriptorById;
use js::jsapi::JS_GetReservedSlot;
use js::jsapi::JS_HasProperty;
use js::jsapi::JS_HasPropertyById;
use js::jsapi::JS_NewObject;
use js::jsapi::JS_SetReservedSlot;
use js::jsapi::MutableHandle as RawMutableHandle;
use js::jsapi::MutableHandleObject as RawMutableHandleObject;
use js::jsapi::MutableHandleValue as RawMutableHandleValue;
use js::jsapi::ObjectOpResult;
use js::jsapi::PropertyDescriptor;
use js::jsapi::Rooted;
use js::jsapi::RootedId;
use js::jsapi::RootedObject;
use js::jsapi::RootedString;
use js::jsapi::SymbolCode;
use js::jsapi::jsid;
use js::jsval::JSVal;
use js::jsval::NullValue;
use js::jsval::ObjectOrNullValue;
use js::jsval::ObjectValue;
use js::jsval::PrivateValue;
use js::jsval::UndefinedValue;
use js::panic::maybe_resume_unwind;
use js::panic::wrap_panic;
use js::rust::CustomAutoRooterGuard;
use js::rust::GCMethods;
use js::rust::Handle;
use js::rust::HandleId;
use js::rust::HandleObject;
use js::rust::HandleValue;
use js::rust::MutableHandle;
use js::rust::MutableHandleObject;
use js::rust::MutableHandleValue;
use js::rust::define_methods;
use js::rust::define_properties;
use js::rust::get_object_class;
use js::rust::wrappers::Call;
use js::rust::wrappers::GetPropertyKeys;
use js::rust::wrappers::JS_CallFunctionValue;
use js::rust::wrappers::JS_CopyPropertiesFrom;
use js::rust::wrappers::JS_DefineProperty;
use js::rust::wrappers::JS_DefinePropertyById2;
use js::rust::wrappers::JS_GetFunctionPrototype;
use js::rust::wrappers::JS_GetObjectPrototype;
use js::rust::wrappers::JS_GetProperty;
use js::rust::wrappers::JS_InitializePropertiesFromCompatibleNativeObject;
use js::rust::wrappers::JS_NewObjectWithGivenProto;
use js::rust::wrappers::JS_NewObjectWithoutMetadata;
use js::rust::wrappers::JS_ObjectIsDate;
use js::rust::wrappers::JS_SetImmutablePrototype;
use js::rust::wrappers::JS_SetProperty;
use js::rust::wrappers::JS_SetPrototype;
use js::rust::wrappers::JS_SplicePrototype;
use js::rust::wrappers::JS_WrapObject;
use js::rust::wrappers::JS_WrapValue;
use js::rust::wrappers::NewProxyObject;
use js::typedarray;
use libc;
use malloc_size_of::MallocSizeOfOps;
use mem::malloc_size_of_including_raw_self;
use servo_config::prefs::PREFS;
use std::borrow::ToOwned;
use std::cmp;
use std::default::Default;
use std::ffi::CString;
use std::mem;
use std::num;
use std::os;
use std::os::raw::c_void;
use std::panic;
use std::ptr;
use std::ptr::NonNull;
use std::rc;
use std::rc::Rc;
use std::str;
use typeholder::TypeHolderTrait;

pub use self::CSSStyleDeclarationBinding::{Wrap, CSSStyleDeclarationMethods, GetProtoObject, DefineDOMInterface};
pub mod CSSStyleDeclarationBinding {
#![allow(non_camel_case_types,non_upper_case_globals,unused_imports,unused_variables,unused_assignments,unused_mut)]
use dom;
use dom::bindings;
use dom::bindings::callback::CallSetup;
use dom::bindings::callback::CallbackContainer;
use dom::bindings::callback::CallbackFunction;
use dom::bindings::callback::CallbackInterface;
use dom::bindings::callback::CallbackObject;
use dom::bindings::callback::ExceptionHandling;
use dom::bindings::callback::wrap_call_this_object;
use dom::bindings::codegen::InterfaceObjectMap;
use dom::bindings::codegen::PrototypeList;
use dom::bindings::codegen::RegisterBindings;
use dom::bindings::codegen::UnionTypes;
use dom::bindings::constant::ConstantSpec;
use dom::bindings::constant::ConstantVal;
use dom::bindings::conversions::ConversionBehavior;
use dom::bindings::conversions::ConversionResult;
use dom::bindings::conversions::DOM_OBJECT_SLOT;
use dom::bindings::conversions::FromJSValConvertible;
use dom::bindings::conversions::IDLInterface;
use dom::bindings::conversions::StringificationBehavior;
use dom::bindings::conversions::ToJSValConvertible;
use dom::bindings::conversions::is_array_like;
use dom::bindings::conversions::jsid_to_string;
use dom::bindings::conversions::native_from_handlevalue;
use dom::bindings::conversions::native_from_object;
use dom::bindings::conversions::private_from_object;
use dom::bindings::conversions::root_from_handleobject;
use dom::bindings::conversions::root_from_handlevalue;
use dom::bindings::conversions::root_from_object;
use dom::bindings::error::Error;
use dom::bindings::error::Error::JSFailed;
use dom::bindings::error::ErrorResult;
use dom::bindings::error::Fallible;
use dom::bindings::error::throw_dom_exception;
use dom::bindings::guard::Condition;
use dom::bindings::guard::Guard;
use dom::bindings::htmlconstructor::html_constructor;
use dom::bindings::htmlconstructor::pop_current_element_queue;
use dom::bindings::htmlconstructor::push_new_element_queue;
use dom::bindings::inheritance::Castable;
use dom::bindings::interface::ConstructorClassHook;
use dom::bindings::interface::InterfaceConstructorBehavior;
use dom::bindings::interface::NonCallbackInterfaceObjectClass;
use dom::bindings::interface::create_callback_interface_object;
use dom::bindings::interface::create_global_object;
use dom::bindings::interface::create_interface_prototype_object;
use dom::bindings::interface::create_named_constructors;
use dom::bindings::interface::create_noncallback_interface_object;
use dom::bindings::interface::define_guarded_constants;
use dom::bindings::interface::define_guarded_methods;
use dom::bindings::interface::define_guarded_properties;
use dom::bindings::interface::is_exposed_in;
use dom::bindings::iterable::Iterable;
use dom::bindings::iterable::IteratorType;
use dom::bindings::mozmap::MozMap;
use dom::bindings::namespace::NamespaceObjectClass;
use dom::bindings::namespace::create_namespace_object;
use dom::bindings::num::Finite;
use dom::bindings::proxyhandler;
use dom::bindings::proxyhandler::ensure_expando_object;
use dom::bindings::proxyhandler::fill_property_descriptor;
use dom::bindings::proxyhandler::get_expando_object;
use dom::bindings::proxyhandler::get_property_descriptor;
use dom::bindings::reflector::DomObject;
use dom::bindings::reflector::MutDomObject;
use dom::bindings::root::Dom;
use dom::bindings::root::DomRoot;
use dom::bindings::root::OptionalHeapSetter;
use dom::bindings::root::RootedReference;
use dom::bindings::str::ByteString;
use dom::bindings::str::DOMString;
use dom::bindings::str::USVString;
use dom::bindings::trace::JSTraceable;
use dom::bindings::trace::RootedTraceable;
use dom::bindings::trace::RootedTraceableBox;
use dom::bindings::utils::AsVoidPtr;
use dom::bindings::utils::DOMClass;
use dom::bindings::utils::DOMJSClass;
use dom::bindings::utils::DOM_PROTO_UNFORGEABLE_HOLDER_SLOT;
use dom::bindings::utils::JSCLASS_DOM_GLOBAL;
use dom::bindings::utils::ProtoOrIfaceArray;
use dom::bindings::utils::enumerate_global;
use dom::bindings::utils::finalize_global;
use dom::bindings::utils::find_enum_value;
use dom::bindings::utils::generic_getter;
use dom::bindings::utils::generic_lenient_getter;
use dom::bindings::utils::generic_lenient_setter;
use dom::bindings::utils::generic_method;
use dom::bindings::utils::generic_setter;
use dom::bindings::utils::get_array_index_from_id;
use dom::bindings::utils::get_dictionary_property;
use dom::bindings::utils::get_property_on_prototype;
use dom::bindings::utils::get_proto_or_iface_array;
use dom::bindings::utils::has_property_on_prototype;
use dom::bindings::utils::is_platform_object;
use dom::bindings::utils::resolve_global;
use dom::bindings::utils::set_dictionary_property;
use dom::bindings::utils::trace_global;
use dom::bindings::weakref::DOM_WEAK_SLOT;
use dom::bindings::weakref::WeakBox;
use dom::bindings::weakref::WeakReferenceable;
use dom::globalscope::GlobalScope;
use dom::types::CSSStyleDeclaration;
use dom::windowproxy::WindowProxy;
use js;
use js::JSCLASS_GLOBAL_SLOT_COUNT;
use js::JSCLASS_IS_DOMJSCLASS;
use js::JSCLASS_IS_GLOBAL;
use js::JSCLASS_RESERVED_SLOTS_MASK;
use js::JS_CALLEE;
use js::error::throw_internal_error;
use js::error::throw_type_error;
use js::glue::AppendToAutoIdVector;
use js::glue::CallJitGetterOp;
use js::glue::CallJitMethodOp;
use js::glue::CallJitSetterOp;
use js::glue::CreateProxyHandler;
use js::glue::GetProxyPrivate;
use js::glue::ProxyTraps;
use js::glue::RUST_JSID_IS_INT;
use js::glue::RUST_JSID_IS_STRING;
use js::glue::RUST_SYMBOL_TO_JSID;
use js::glue::UnwrapObject;
use js::glue::int_to_jsid;
use js::jsapi::AutoIdVector;
use js::jsapi::CallArgs;
use js::jsapi::CurrentGlobalOrNull;
use js::jsapi::FreeOp;
use js::jsapi::GetWellKnownSymbol;
use js::jsapi::Handle as RawHandle;
use js::jsapi::HandleId as RawHandleId;
use js::jsapi::HandleObject as RawHandleObject;
use js::jsapi::HandleValue as RawHandleValue;
use js::jsapi::HandleValueArray;
use js::jsapi::Heap;
use js::jsapi::INTERNED_STRING_TO_JSID;
use js::jsapi::IsCallable;
use js::jsapi::JSAutoCompartment;
use js::jsapi::JSCLASS_RESERVED_SLOTS_SHIFT;
use js::jsapi::JSClass;
use js::jsapi::JSContext;
use js::jsapi::JSFreeOp;
use js::jsapi::JSFunctionSpec;
use js::jsapi::JSITER_HIDDEN;
use js::jsapi::JSITER_OWNONLY;
use js::jsapi::JSITER_SYMBOLS;
use js::jsapi::JSJitGetterCallArgs;
use js::jsapi::JSJitInfo;
use js::jsapi::JSJitInfo_AliasSet;
use js::jsapi::JSJitInfo_ArgType;
use js::jsapi::JSJitInfo_OpType;
use js::jsapi::JSJitMethodCallArgs;
use js::jsapi::JSJitSetterCallArgs;
use js::jsapi::JSNative;
use js::jsapi::JSNativeWrapper;
use js::jsapi::JSObject;
use js::jsapi::JSPROP_ENUMERATE;
use js::jsapi::JSPROP_PERMANENT;
use js::jsapi::JSPROP_READONLY;
use js::jsapi::JSPROP_SHARED;
use js::jsapi::JSPropertySpec;
use js::jsapi::JSString;
use js::jsapi::JSTracer;
use js::jsapi::JSType;
use js::jsapi::JSTypedMethodJitInfo;
use js::jsapi::JSValueType;
use js::jsapi::JS_AtomizeAndPinString;
use js::jsapi::JS_ForwardGetPropertyTo;
use js::jsapi::JS_GetErrorPrototype;
use js::jsapi::JS_GetGlobalForObject;
use js::jsapi::JS_GetIteratorPrototype;
use js::jsapi::JS_GetPropertyById;
use js::jsapi::JS_GetPropertyDescriptorById;
use js::jsapi::JS_GetReservedSlot;
use js::jsapi::JS_HasProperty;
use js::jsapi::JS_HasPropertyById;
use js::jsapi::JS_NewObject;
use js::jsapi::JS_SetReservedSlot;
use js::jsapi::MutableHandle as RawMutableHandle;
use js::jsapi::MutableHandleObject as RawMutableHandleObject;
use js::jsapi::MutableHandleValue as RawMutableHandleValue;
use js::jsapi::ObjectOpResult;
use js::jsapi::PropertyDescriptor;
use js::jsapi::Rooted;
use js::jsapi::RootedId;
use js::jsapi::RootedObject;
use js::jsapi::RootedString;
use js::jsapi::SymbolCode;
use js::jsapi::jsid;
use js::jsval::JSVal;
use js::jsval::NullValue;
use js::jsval::ObjectOrNullValue;
use js::jsval::ObjectValue;
use js::jsval::PrivateValue;
use js::jsval::UndefinedValue;
use js::panic::maybe_resume_unwind;
use js::panic::wrap_panic;
use js::rust::CustomAutoRooterGuard;
use js::rust::GCMethods;
use js::rust::Handle;
use js::rust::HandleId;
use js::rust::HandleObject;
use js::rust::HandleValue;
use js::rust::MutableHandle;
use js::rust::MutableHandleObject;
use js::rust::MutableHandleValue;
use js::rust::define_methods;
use js::rust::define_properties;
use js::rust::get_object_class;
use js::rust::wrappers::Call;
use js::rust::wrappers::GetPropertyKeys;
use js::rust::wrappers::JS_CallFunctionValue;
use js::rust::wrappers::JS_CopyPropertiesFrom;
use js::rust::wrappers::JS_DefineProperty;
use js::rust::wrappers::JS_DefinePropertyById2;
use js::rust::wrappers::JS_GetFunctionPrototype;
use js::rust::wrappers::JS_GetObjectPrototype;
use js::rust::wrappers::JS_GetProperty;
use js::rust::wrappers::JS_InitializePropertiesFromCompatibleNativeObject;
use js::rust::wrappers::JS_NewObjectWithGivenProto;
use js::rust::wrappers::JS_NewObjectWithoutMetadata;
use js::rust::wrappers::JS_ObjectIsDate;
use js::rust::wrappers::JS_SetImmutablePrototype;
use js::rust::wrappers::JS_SetProperty;
use js::rust::wrappers::JS_SetPrototype;
use js::rust::wrappers::JS_SplicePrototype;
use js::rust::wrappers::JS_WrapObject;
use js::rust::wrappers::JS_WrapValue;
use js::rust::wrappers::NewProxyObject;
use js::typedarray;
use libc;
use malloc_size_of::MallocSizeOfOps;
use mem::malloc_size_of_including_raw_self;
use servo_config::prefs::PREFS;
use std::borrow::ToOwned;
use std::cmp;
use std::default::Default;
use std::ffi::CString;
use std::mem;
use std::num;
use std::os;
use std::os::raw::c_void;
use std::panic;
use std::ptr;
use std::ptr::NonNull;
use std::rc;
use std::rc::Rc;
use std::str;
use typeholder::TypeHolderTrait;

unsafe extern fn get_cssText<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.CssText();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_cssText<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetCssText(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const cssText_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const cssText_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_length<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: u32 = this.Length();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const length_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn item<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"CSSStyleDeclaration.item\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: DOMString = this.Item(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const item_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn getPropertyValue<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"CSSStyleDeclaration.getPropertyValue\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: DOMString = this.GetPropertyValue(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const getPropertyValue_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn getPropertyPriority<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"CSSStyleDeclaration.getPropertyPriority\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: DOMString = this.GetPropertyPriority(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const getPropertyPriority_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn setProperty<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"CSSStyleDeclaration.setProperty\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let arg1: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(1), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let arg2: DOMString = if args.get(2).is_undefined() {
            DOMString::from("")
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(2), StringificationBehavior::Empty) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetProperty(arg0, arg1, arg2);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const setProperty_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn setPropertyValue<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"CSSStyleDeclaration.setPropertyValue\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let arg1: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(1), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetPropertyValue(arg0, arg1);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const setPropertyValue_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn setPropertyPriority<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"CSSStyleDeclaration.setPropertyPriority\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let arg1: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(1), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetPropertyPriority(arg0, arg1);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const setPropertyPriority_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn removeProperty<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"CSSStyleDeclaration.removeProperty\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<DOMString, Error> = this.RemoveProperty(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const removeProperty_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_cssFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.CssFloat();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_cssFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetCssFloat(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const cssFloat_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const cssFloat_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_all<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.All();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_all<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetAll(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const all_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const all_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_background<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Background();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_background<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBackground(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const background_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const background_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_backgroundColor<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BackgroundColor();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_backgroundColor<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBackgroundColor(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const backgroundColor_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const backgroundColor_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_background_color<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Background_color();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_background_color<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBackground_color(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const background_color_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const background_color_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_backgroundPosition<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BackgroundPosition();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_backgroundPosition<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBackgroundPosition(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const backgroundPosition_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const backgroundPosition_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_background_position<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Background_position();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_background_position<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBackground_position(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const background_position_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const background_position_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_backgroundPositionX<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BackgroundPositionX();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_backgroundPositionX<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBackgroundPositionX(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const backgroundPositionX_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const backgroundPositionX_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_background_position_x<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Background_position_x();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_background_position_x<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBackground_position_x(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const background_position_x_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const background_position_x_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_backgroundPositionY<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BackgroundPositionY();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_backgroundPositionY<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBackgroundPositionY(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const backgroundPositionY_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const backgroundPositionY_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_background_position_y<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Background_position_y();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_background_position_y<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBackground_position_y(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const background_position_y_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const background_position_y_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_backgroundRepeat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BackgroundRepeat();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_backgroundRepeat<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBackgroundRepeat(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const backgroundRepeat_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const backgroundRepeat_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_background_repeat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Background_repeat();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_background_repeat<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBackground_repeat(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const background_repeat_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const background_repeat_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_backgroundImage<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BackgroundImage();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_backgroundImage<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBackgroundImage(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const backgroundImage_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const backgroundImage_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_background_image<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Background_image();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_background_image<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBackground_image(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const background_image_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const background_image_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_backgroundAttachment<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BackgroundAttachment();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_backgroundAttachment<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBackgroundAttachment(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const backgroundAttachment_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const backgroundAttachment_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_background_attachment<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Background_attachment();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_background_attachment<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBackground_attachment(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const background_attachment_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const background_attachment_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_backgroundSize<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BackgroundSize();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_backgroundSize<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBackgroundSize(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const backgroundSize_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const backgroundSize_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_background_size<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Background_size();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_background_size<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBackground_size(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const background_size_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const background_size_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_backgroundOrigin<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BackgroundOrigin();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_backgroundOrigin<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBackgroundOrigin(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const backgroundOrigin_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const backgroundOrigin_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_background_origin<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Background_origin();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_background_origin<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBackground_origin(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const background_origin_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const background_origin_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_backgroundClip<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BackgroundClip();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_backgroundClip<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBackgroundClip(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const backgroundClip_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const backgroundClip_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_background_clip<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Background_clip();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_background_clip<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBackground_clip(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const background_clip_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const background_clip_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderColor<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderColor();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderColor<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderColor(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderColor_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderColor_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_color<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_color();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_color<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_color(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_color_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_color_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderRadius<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderRadius();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderRadius<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderRadius(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderRadius_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderRadius_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_radius<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_radius();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_radius<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_radius(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_radius_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_radius_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderSpacing<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderSpacing();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderSpacing<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderSpacing(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderSpacing_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderSpacing_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_spacing<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_spacing();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_spacing<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_spacing(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_spacing_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_spacing_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderStyle();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderStyle(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderStyle_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderStyle_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_style<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_style();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_style<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_style(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_style_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_style_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderWidth();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderWidth(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderWidth_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderWidth_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_width<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_width();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_width<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_width(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_width_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_width_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderBottom<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderBottom();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderBottom<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderBottom(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderBottom_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderBottom_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_bottom<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_bottom();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_bottom<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_bottom(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_bottom_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_bottom_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderBottomColor<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderBottomColor();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderBottomColor<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderBottomColor(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderBottomColor_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderBottomColor_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_bottom_color<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_bottom_color();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_bottom_color<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_bottom_color(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_bottom_color_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_bottom_color_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderBottomLeftRadius<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderBottomLeftRadius();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderBottomLeftRadius<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderBottomLeftRadius(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderBottomLeftRadius_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderBottomLeftRadius_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_bottom_left_radius<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_bottom_left_radius();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_bottom_left_radius<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_bottom_left_radius(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_bottom_left_radius_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_bottom_left_radius_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderBottomRightRadius<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderBottomRightRadius();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderBottomRightRadius<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderBottomRightRadius(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderBottomRightRadius_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderBottomRightRadius_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_bottom_right_radius<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_bottom_right_radius();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_bottom_right_radius<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_bottom_right_radius(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_bottom_right_radius_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_bottom_right_radius_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderBottomStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderBottomStyle();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderBottomStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderBottomStyle(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderBottomStyle_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderBottomStyle_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_bottom_style<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_bottom_style();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_bottom_style<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_bottom_style(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_bottom_style_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_bottom_style_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderBottomWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderBottomWidth();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderBottomWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderBottomWidth(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderBottomWidth_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderBottomWidth_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_bottom_width<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_bottom_width();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_bottom_width<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_bottom_width(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_bottom_width_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_bottom_width_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderLeft<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderLeft();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderLeft<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderLeft(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderLeft_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderLeft_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_left<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_left();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_left<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_left(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_left_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_left_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderLeftColor<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderLeftColor();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderLeftColor<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderLeftColor(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderLeftColor_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderLeftColor_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_left_color<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_left_color();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_left_color<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_left_color(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_left_color_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_left_color_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderLeftStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderLeftStyle();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderLeftStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderLeftStyle(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderLeftStyle_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderLeftStyle_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_left_style<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_left_style();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_left_style<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_left_style(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_left_style_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_left_style_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderLeftWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderLeftWidth();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderLeftWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderLeftWidth(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderLeftWidth_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderLeftWidth_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_left_width<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_left_width();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_left_width<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_left_width(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_left_width_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_left_width_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderRight<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderRight();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderRight<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderRight(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderRight_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderRight_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_right<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_right();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_right<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_right(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_right_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_right_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderRightColor<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderRightColor();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderRightColor<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderRightColor(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderRightColor_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderRightColor_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_right_color<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_right_color();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_right_color<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_right_color(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_right_color_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_right_color_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderRightStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderRightStyle();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderRightStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderRightStyle(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderRightStyle_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderRightStyle_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_right_style<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_right_style();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_right_style<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_right_style(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_right_style_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_right_style_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderRightWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderRightWidth();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderRightWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderRightWidth(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderRightWidth_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderRightWidth_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_right_width<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_right_width();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_right_width<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_right_width(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_right_width_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_right_width_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderTop<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderTop();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderTop<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderTop(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderTop_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderTop_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_top<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_top();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_top<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_top(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_top_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_top_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderTopColor<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderTopColor();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderTopColor<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderTopColor(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderTopColor_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderTopColor_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_top_color<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_top_color();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_top_color<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_top_color(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_top_color_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_top_color_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderTopLeftRadius<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderTopLeftRadius();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderTopLeftRadius<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderTopLeftRadius(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderTopLeftRadius_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderTopLeftRadius_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_top_left_radius<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_top_left_radius();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_top_left_radius<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_top_left_radius(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_top_left_radius_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_top_left_radius_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderTopRightRadius<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderTopRightRadius();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderTopRightRadius<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderTopRightRadius(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderTopRightRadius_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderTopRightRadius_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_top_right_radius<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_top_right_radius();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_top_right_radius<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_top_right_radius(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_top_right_radius_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_top_right_radius_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderTopStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderTopStyle();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderTopStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderTopStyle(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderTopStyle_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderTopStyle_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_top_style<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_top_style();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_top_style<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_top_style(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_top_style_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_top_style_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderTopWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderTopWidth();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderTopWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderTopWidth(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderTopWidth_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderTopWidth_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_top_width<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_top_width();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_top_width<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_top_width(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_top_width_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_top_width_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_image_source<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_image_source();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_image_source<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_image_source(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_image_source_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_image_source_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderImageSource<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderImageSource();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderImageSource<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderImageSource(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderImageSource_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderImageSource_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_image_slice<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_image_slice();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_image_slice<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_image_slice(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_image_slice_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_image_slice_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderImageSlice<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderImageSlice();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderImageSlice<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderImageSlice(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderImageSlice_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderImageSlice_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_image_repeat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_image_repeat();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_image_repeat<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_image_repeat(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_image_repeat_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_image_repeat_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderImageRepeat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderImageRepeat();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderImageRepeat<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderImageRepeat(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderImageRepeat_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderImageRepeat_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_image_outset<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_image_outset();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_image_outset<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_image_outset(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_image_outset_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_image_outset_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderImageOutset<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderImageOutset();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderImageOutset<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderImageOutset(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderImageOutset_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderImageOutset_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_image_width<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_image_width();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_image_width<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_image_width(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_image_width_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_image_width_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderImageWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderImageWidth();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderImageWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderImageWidth(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderImageWidth_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderImageWidth_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_image<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_image();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_image<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_image(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_image_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_image_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderImage<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderImage();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderImage<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderImage(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderImage_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderImage_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_block_start_color<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_block_start_color();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_block_start_color<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_block_start_color(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_block_start_color_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_block_start_color_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderBlockStartColor<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderBlockStartColor();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderBlockStartColor<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderBlockStartColor(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderBlockStartColor_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderBlockStartColor_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_block_start_width<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_block_start_width();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_block_start_width<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_block_start_width(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_block_start_width_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_block_start_width_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderBlockStartWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderBlockStartWidth();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderBlockStartWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderBlockStartWidth(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderBlockStartWidth_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderBlockStartWidth_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_block_start_style<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_block_start_style();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_block_start_style<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_block_start_style(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_block_start_style_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_block_start_style_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderBlockStartStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderBlockStartStyle();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderBlockStartStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderBlockStartStyle(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderBlockStartStyle_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderBlockStartStyle_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_block_end_color<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_block_end_color();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_block_end_color<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_block_end_color(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_block_end_color_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_block_end_color_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderBlockEndColor<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderBlockEndColor();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderBlockEndColor<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderBlockEndColor(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderBlockEndColor_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderBlockEndColor_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_block_end_width<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_block_end_width();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_block_end_width<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_block_end_width(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_block_end_width_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_block_end_width_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderBlockEndWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderBlockEndWidth();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderBlockEndWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderBlockEndWidth(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderBlockEndWidth_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderBlockEndWidth_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_block_end_style<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_block_end_style();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_block_end_style<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_block_end_style(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_block_end_style_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_block_end_style_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderBlockEndStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderBlockEndStyle();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderBlockEndStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderBlockEndStyle(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderBlockEndStyle_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderBlockEndStyle_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_inline_start_color<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_inline_start_color();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_inline_start_color<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_inline_start_color(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_inline_start_color_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_inline_start_color_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderInlineStartColor<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderInlineStartColor();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderInlineStartColor<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderInlineStartColor(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderInlineStartColor_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderInlineStartColor_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_inline_start_width<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_inline_start_width();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_inline_start_width<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_inline_start_width(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_inline_start_width_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_inline_start_width_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderInlineStartWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderInlineStartWidth();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderInlineStartWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderInlineStartWidth(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderInlineStartWidth_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderInlineStartWidth_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_inline_start_style<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_inline_start_style();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_inline_start_style<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_inline_start_style(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_inline_start_style_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_inline_start_style_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderInlineStartStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderInlineStartStyle();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderInlineStartStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderInlineStartStyle(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderInlineStartStyle_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderInlineStartStyle_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_inline_end_color<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_inline_end_color();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_inline_end_color<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_inline_end_color(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_inline_end_color_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_inline_end_color_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderInlineEndColor<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderInlineEndColor();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderInlineEndColor<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderInlineEndColor(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderInlineEndColor_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderInlineEndColor_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_inline_end_width<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_inline_end_width();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_inline_end_width<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_inline_end_width(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_inline_end_width_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_inline_end_width_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderInlineEndWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderInlineEndWidth();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderInlineEndWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderInlineEndWidth(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderInlineEndWidth_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderInlineEndWidth_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_inline_end_style<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_inline_end_style();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_inline_end_style<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_inline_end_style(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_inline_end_style_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_inline_end_style_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderInlineEndStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderInlineEndStyle();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderInlineEndStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderInlineEndStyle(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderInlineEndStyle_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderInlineEndStyle_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_block_start<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_block_start();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_block_start<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_block_start(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_block_start_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_block_start_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderBlockStart<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderBlockStart();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderBlockStart<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderBlockStart(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderBlockStart_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderBlockStart_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_block_end<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_block_end();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_block_end<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_block_end(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_block_end_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_block_end_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderBlockEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderBlockEnd();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderBlockEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderBlockEnd(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderBlockEnd_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderBlockEnd_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_inline_start<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_inline_start();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_inline_start<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_inline_start(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_inline_start_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_inline_start_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderInlineStart<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderInlineStart();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderInlineStart<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderInlineStart(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderInlineStart_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderInlineStart_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_inline_end<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_inline_end();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_inline_end<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_inline_end(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_inline_end_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_inline_end_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderInlineEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderInlineEnd();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderInlineEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderInlineEnd(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderInlineEnd_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderInlineEnd_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_content<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Content();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_content<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetContent(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const content_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const content_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_color<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Color();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_color<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetColor(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const color_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const color_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_display<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Display();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_display<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetDisplay(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const display_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const display_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_opacity<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Opacity();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_opacity<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetOpacity(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const opacity_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const opacity_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_visibility<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Visibility();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_visibility<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetVisibility(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const visibility_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const visibility_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_cursor<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Cursor();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_cursor<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetCursor(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const cursor_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const cursor_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_boxSizing<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BoxSizing();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_boxSizing<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBoxSizing(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const boxSizing_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const boxSizing_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_box_sizing<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Box_sizing();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_box_sizing<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBox_sizing(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const box_sizing_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const box_sizing_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_boxShadow<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BoxShadow();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_boxShadow<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBoxShadow(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const boxShadow_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const boxShadow_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_box_shadow<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Box_shadow();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_box_shadow<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBox_shadow(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const box_shadow_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const box_shadow_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_textShadow<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.TextShadow();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_textShadow<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetTextShadow(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const textShadow_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const textShadow_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_text_shadow<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Text_shadow();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_text_shadow<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetText_shadow(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const text_shadow_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const text_shadow_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_float<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Float();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_float<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetFloat(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const float_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const float_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_clear<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Clear();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_clear<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetClear(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const clear_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const clear_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_clip<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Clip();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_clip<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetClip(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const clip_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const clip_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_transform<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Transform();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_transform<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetTransform(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const transform_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const transform_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_transformOrigin<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.TransformOrigin();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_transformOrigin<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetTransformOrigin(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const transformOrigin_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const transformOrigin_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_transform_origin<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Transform_origin();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_transform_origin<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetTransform_origin(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const transform_origin_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const transform_origin_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_perspective<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Perspective();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_perspective<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetPerspective(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const perspective_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const perspective_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_perspectiveOrigin<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.PerspectiveOrigin();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_perspectiveOrigin<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetPerspectiveOrigin(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const perspectiveOrigin_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const perspectiveOrigin_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_perspective_origin<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Perspective_origin();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_perspective_origin<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetPerspective_origin(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const perspective_origin_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const perspective_origin_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_transformStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.TransformStyle();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_transformStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetTransformStyle(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const transformStyle_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const transformStyle_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_transform_style<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Transform_style();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_transform_style<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetTransform_style(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const transform_style_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const transform_style_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_backfaceVisibility<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BackfaceVisibility();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_backfaceVisibility<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBackfaceVisibility(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const backfaceVisibility_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const backfaceVisibility_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_backface_visibility<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Backface_visibility();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_backface_visibility<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBackface_visibility(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const backface_visibility_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const backface_visibility_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_rotate<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Rotate();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_rotate<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetRotate(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const rotate_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const rotate_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_scale<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Scale();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_scale<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetScale(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const scale_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const scale_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_translate<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Translate();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_translate<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetTranslate(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const translate_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const translate_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_direction<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Direction();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_direction<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetDirection(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const direction_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const direction_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_unicodeBidi<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.UnicodeBidi();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_unicodeBidi<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetUnicodeBidi(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const unicodeBidi_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const unicodeBidi_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_unicode_bidi<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Unicode_bidi();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_unicode_bidi<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetUnicode_bidi(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const unicode_bidi_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const unicode_bidi_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_filter<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Filter();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_filter<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetFilter(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const filter_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const filter_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_lineHeight<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.LineHeight();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_lineHeight<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetLineHeight(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const lineHeight_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const lineHeight_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_line_height<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Line_height();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_line_height<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetLine_height(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const line_height_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const line_height_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_mixBlendMode<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.MixBlendMode();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_mixBlendMode<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMixBlendMode(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const mixBlendMode_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const mixBlendMode_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_mix_blend_mode<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Mix_blend_mode();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_mix_blend_mode<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMix_blend_mode(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const mix_blend_mode_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const mix_blend_mode_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_verticalAlign<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.VerticalAlign();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_verticalAlign<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetVerticalAlign(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const verticalAlign_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const verticalAlign_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_vertical_align<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Vertical_align();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_vertical_align<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetVertical_align(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const vertical_align_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const vertical_align_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_listStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.ListStyle();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_listStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetListStyle(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const listStyle_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const listStyle_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_list_style<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.List_style();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_list_style<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetList_style(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const list_style_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const list_style_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_listStylePosition<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.ListStylePosition();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_listStylePosition<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetListStylePosition(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const listStylePosition_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const listStylePosition_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_list_style_position<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.List_style_position();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_list_style_position<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetList_style_position(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const list_style_position_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const list_style_position_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_listStyleType<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.ListStyleType();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_listStyleType<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetListStyleType(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const listStyleType_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const listStyleType_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_list_style_type<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.List_style_type();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_list_style_type<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetList_style_type(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const list_style_type_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const list_style_type_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_listStyleImage<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.ListStyleImage();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_listStyleImage<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetListStyleImage(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const listStyleImage_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const listStyleImage_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_list_style_image<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.List_style_image();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_list_style_image<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetList_style_image(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const list_style_image_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const list_style_image_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_quotes<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Quotes();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_quotes<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetQuotes(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const quotes_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const quotes_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_counterIncrement<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.CounterIncrement();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_counterIncrement<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetCounterIncrement(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const counterIncrement_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const counterIncrement_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_counter_increment<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Counter_increment();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_counter_increment<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetCounter_increment(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const counter_increment_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const counter_increment_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_counterReset<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.CounterReset();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_counterReset<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetCounterReset(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const counterReset_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const counterReset_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_counter_reset<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Counter_reset();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_counter_reset<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetCounter_reset(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const counter_reset_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const counter_reset_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_overflow<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Overflow();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_overflow<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetOverflow(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const overflow_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const overflow_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_overflowX<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.OverflowX();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_overflowX<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetOverflowX(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const overflowX_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const overflowX_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_overflow_x<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Overflow_x();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_overflow_x<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetOverflow_x(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const overflow_x_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const overflow_x_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_overflowY<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.OverflowY();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_overflowY<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetOverflowY(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const overflowY_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const overflowY_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_overflow_y<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Overflow_y();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_overflow_y<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetOverflow_y(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const overflow_y_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const overflow_y_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_overflowWrap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.OverflowWrap();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_overflowWrap<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetOverflowWrap(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const overflowWrap_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const overflowWrap_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_overflow_wrap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Overflow_wrap();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_overflow_wrap<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetOverflow_wrap(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const overflow_wrap_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const overflow_wrap_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_tableLayout<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.TableLayout();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_tableLayout<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetTableLayout(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const tableLayout_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const tableLayout_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_table_layout<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Table_layout();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_table_layout<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetTable_layout(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const table_layout_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const table_layout_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_borderCollapse<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BorderCollapse();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderCollapse<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorderCollapse(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const borderCollapse_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const borderCollapse_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_border_collapse<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Border_collapse();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_collapse<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBorder_collapse(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const border_collapse_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const border_collapse_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_emptyCells<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.EmptyCells();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_emptyCells<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetEmptyCells(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const emptyCells_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const emptyCells_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_empty_cells<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Empty_cells();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_empty_cells<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetEmpty_cells(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const empty_cells_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const empty_cells_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_captionSide<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.CaptionSide();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_captionSide<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetCaptionSide(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const captionSide_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const captionSide_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_caption_side<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Caption_side();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_caption_side<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetCaption_side(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const caption_side_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const caption_side_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_whiteSpace<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.WhiteSpace();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_whiteSpace<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetWhiteSpace(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const whiteSpace_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const whiteSpace_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_white_space<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.White_space();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_white_space<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetWhite_space(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const white_space_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const white_space_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_writingMode<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.WritingMode();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_writingMode<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetWritingMode(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const writingMode_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const writingMode_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_writing_mode<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Writing_mode();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_writing_mode<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetWriting_mode(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const writing_mode_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const writing_mode_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_letterSpacing<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.LetterSpacing();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_letterSpacing<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetLetterSpacing(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const letterSpacing_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const letterSpacing_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_letter_spacing<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Letter_spacing();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_letter_spacing<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetLetter_spacing(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const letter_spacing_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const letter_spacing_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_wordBreak<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.WordBreak();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_wordBreak<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetWordBreak(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const wordBreak_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const wordBreak_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_word_break<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Word_break();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_word_break<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetWord_break(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const word_break_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const word_break_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_wordSpacing<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.WordSpacing();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_wordSpacing<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetWordSpacing(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const wordSpacing_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const wordSpacing_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_word_spacing<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Word_spacing();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_word_spacing<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetWord_spacing(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const word_spacing_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const word_spacing_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_wordWrap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.WordWrap();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_wordWrap<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetWordWrap(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const wordWrap_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const wordWrap_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_word_wrap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Word_wrap();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_word_wrap<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetWord_wrap(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const word_wrap_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const word_wrap_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_textOverflow<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.TextOverflow();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_textOverflow<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetTextOverflow(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const textOverflow_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const textOverflow_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_text_overflow<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Text_overflow();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_text_overflow<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetText_overflow(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const text_overflow_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const text_overflow_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_textAlign<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.TextAlign();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_textAlign<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetTextAlign(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const textAlign_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const textAlign_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_text_align<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Text_align();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_text_align<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetText_align(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const text_align_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const text_align_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_textDecoration<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.TextDecoration();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_textDecoration<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetTextDecoration(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const textDecoration_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const textDecoration_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_text_decoration<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Text_decoration();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_text_decoration<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetText_decoration(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const text_decoration_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const text_decoration_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_textDecorationLine<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.TextDecorationLine();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_textDecorationLine<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetTextDecorationLine(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const textDecorationLine_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const textDecorationLine_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_text_decoration_line<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Text_decoration_line();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_text_decoration_line<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetText_decoration_line(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const text_decoration_line_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const text_decoration_line_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_textIndent<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.TextIndent();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_textIndent<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetTextIndent(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const textIndent_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const textIndent_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_text_indent<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Text_indent();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_text_indent<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetText_indent(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const text_indent_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const text_indent_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_textJustify<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.TextJustify();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_textJustify<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetTextJustify(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const textJustify_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const textJustify_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_text_justify<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Text_justify();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_text_justify<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetText_justify(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const text_justify_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const text_justify_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_textRendering<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.TextRendering();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_textRendering<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetTextRendering(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const textRendering_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const textRendering_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_text_rendering<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Text_rendering();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_text_rendering<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetText_rendering(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const text_rendering_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const text_rendering_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_textTransform<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.TextTransform();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_textTransform<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetTextTransform(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const textTransform_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const textTransform_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_text_transform<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Text_transform();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_text_transform<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetText_transform(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const text_transform_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const text_transform_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_font<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Font();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_font<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetFont(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const font_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const font_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_fontFamily<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.FontFamily();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_fontFamily<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetFontFamily(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const fontFamily_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const fontFamily_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_font_family<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Font_family();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_font_family<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetFont_family(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const font_family_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const font_family_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_fontSize<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.FontSize();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_fontSize<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetFontSize(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const fontSize_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const fontSize_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_font_size<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Font_size();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_font_size<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetFont_size(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const font_size_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const font_size_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_fontStretch<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.FontStretch();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_fontStretch<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetFontStretch(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const fontStretch_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const fontStretch_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_font_stretch<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Font_stretch();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_font_stretch<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetFont_stretch(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const font_stretch_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const font_stretch_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_fontStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.FontStyle();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_fontStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetFontStyle(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const fontStyle_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const fontStyle_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_font_style<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Font_style();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_font_style<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetFont_style(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const font_style_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const font_style_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_fontVariant<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.FontVariant();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_fontVariant<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetFontVariant(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const fontVariant_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const fontVariant_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_font_variant<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Font_variant();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_font_variant<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetFont_variant(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const font_variant_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const font_variant_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_fontVariantCaps<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.FontVariantCaps();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_fontVariantCaps<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetFontVariantCaps(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const fontVariantCaps_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const fontVariantCaps_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_font_variant_caps<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Font_variant_caps();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_font_variant_caps<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetFont_variant_caps(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const font_variant_caps_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const font_variant_caps_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_fontWeight<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.FontWeight();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_fontWeight<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetFontWeight(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const fontWeight_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const fontWeight_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_font_weight<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Font_weight();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_font_weight<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetFont_weight(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const font_weight_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const font_weight_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_margin<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Margin();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_margin<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMargin(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const margin_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const margin_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_marginBottom<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.MarginBottom();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_marginBottom<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMarginBottom(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const marginBottom_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const marginBottom_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_margin_bottom<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Margin_bottom();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_margin_bottom<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMargin_bottom(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const margin_bottom_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const margin_bottom_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_marginLeft<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.MarginLeft();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_marginLeft<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMarginLeft(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const marginLeft_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const marginLeft_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_margin_left<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Margin_left();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_margin_left<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMargin_left(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const margin_left_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const margin_left_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_marginRight<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.MarginRight();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_marginRight<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMarginRight(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const marginRight_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const marginRight_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_margin_right<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Margin_right();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_margin_right<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMargin_right(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const margin_right_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const margin_right_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_marginTop<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.MarginTop();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_marginTop<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMarginTop(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const marginTop_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const marginTop_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_margin_top<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Margin_top();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_margin_top<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMargin_top(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const margin_top_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const margin_top_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_margin_block_start<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Margin_block_start();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_margin_block_start<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMargin_block_start(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const margin_block_start_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const margin_block_start_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_marginBlockStart<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.MarginBlockStart();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_marginBlockStart<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMarginBlockStart(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const marginBlockStart_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const marginBlockStart_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_margin_block_end<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Margin_block_end();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_margin_block_end<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMargin_block_end(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const margin_block_end_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const margin_block_end_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_marginBlockEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.MarginBlockEnd();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_marginBlockEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMarginBlockEnd(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const marginBlockEnd_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const marginBlockEnd_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_margin_inline_start<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Margin_inline_start();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_margin_inline_start<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMargin_inline_start(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const margin_inline_start_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const margin_inline_start_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_marginInlineStart<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.MarginInlineStart();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_marginInlineStart<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMarginInlineStart(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const marginInlineStart_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const marginInlineStart_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_margin_inline_end<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Margin_inline_end();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_margin_inline_end<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMargin_inline_end(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const margin_inline_end_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const margin_inline_end_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_marginInlineEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.MarginInlineEnd();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_marginInlineEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMarginInlineEnd(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const marginInlineEnd_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const marginInlineEnd_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_padding<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Padding();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_padding<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetPadding(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const padding_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const padding_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_paddingBottom<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.PaddingBottom();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_paddingBottom<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetPaddingBottom(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const paddingBottom_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const paddingBottom_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_padding_bottom<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Padding_bottom();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_padding_bottom<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetPadding_bottom(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const padding_bottom_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const padding_bottom_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_paddingLeft<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.PaddingLeft();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_paddingLeft<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetPaddingLeft(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const paddingLeft_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const paddingLeft_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_padding_left<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Padding_left();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_padding_left<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetPadding_left(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const padding_left_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const padding_left_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_paddingRight<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.PaddingRight();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_paddingRight<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetPaddingRight(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const paddingRight_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const paddingRight_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_padding_right<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Padding_right();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_padding_right<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetPadding_right(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const padding_right_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const padding_right_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_paddingTop<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.PaddingTop();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_paddingTop<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetPaddingTop(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const paddingTop_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const paddingTop_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_padding_top<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Padding_top();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_padding_top<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetPadding_top(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const padding_top_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const padding_top_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_padding_block_start<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Padding_block_start();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_padding_block_start<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetPadding_block_start(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const padding_block_start_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const padding_block_start_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_paddingBlockStart<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.PaddingBlockStart();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_paddingBlockStart<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetPaddingBlockStart(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const paddingBlockStart_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const paddingBlockStart_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_padding_block_end<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Padding_block_end();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_padding_block_end<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetPadding_block_end(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const padding_block_end_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const padding_block_end_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_paddingBlockEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.PaddingBlockEnd();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_paddingBlockEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetPaddingBlockEnd(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const paddingBlockEnd_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const paddingBlockEnd_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_padding_inline_start<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Padding_inline_start();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_padding_inline_start<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetPadding_inline_start(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const padding_inline_start_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const padding_inline_start_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_paddingInlineStart<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.PaddingInlineStart();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_paddingInlineStart<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetPaddingInlineStart(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const paddingInlineStart_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const paddingInlineStart_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_padding_inline_end<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Padding_inline_end();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_padding_inline_end<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetPadding_inline_end(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const padding_inline_end_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const padding_inline_end_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_paddingInlineEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.PaddingInlineEnd();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_paddingInlineEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetPaddingInlineEnd(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const paddingInlineEnd_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const paddingInlineEnd_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_outline<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Outline();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_outline<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetOutline(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const outline_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const outline_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_outlineColor<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.OutlineColor();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_outlineColor<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetOutlineColor(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const outlineColor_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const outlineColor_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_outline_color<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Outline_color();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_outline_color<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetOutline_color(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const outline_color_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const outline_color_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_outlineStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.OutlineStyle();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_outlineStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetOutlineStyle(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const outlineStyle_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const outlineStyle_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_outline_style<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Outline_style();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_outline_style<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetOutline_style(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const outline_style_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const outline_style_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_outlineWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.OutlineWidth();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_outlineWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetOutlineWidth(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const outlineWidth_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const outlineWidth_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_outline_width<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Outline_width();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_outline_width<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetOutline_width(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const outline_width_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const outline_width_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_outlineOffset<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.OutlineOffset();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_outlineOffset<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetOutlineOffset(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const outlineOffset_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const outlineOffset_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_outline_offset<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Outline_offset();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_outline_offset<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetOutline_offset(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const outline_offset_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const outline_offset_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_position<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Position();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_position<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetPosition(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const position_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const position_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_pointerEvents<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.PointerEvents();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_pointerEvents<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetPointerEvents(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const pointerEvents_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const pointerEvents_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_pointer_events<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Pointer_events();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_pointer_events<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetPointer_events(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const pointer_events_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const pointer_events_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_top<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Top();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_top<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetTop(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const top_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const top_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_right<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Right();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_right<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetRight(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const right_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const right_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_left<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Left();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_left<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetLeft(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const left_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const left_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_bottom<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Bottom();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_bottom<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBottom(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const bottom_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const bottom_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_offset_block_start<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Offset_block_start();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_offset_block_start<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetOffset_block_start(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const offset_block_start_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const offset_block_start_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_offsetBlockStart<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.OffsetBlockStart();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_offsetBlockStart<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetOffsetBlockStart(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const offsetBlockStart_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const offsetBlockStart_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_offset_block_end<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Offset_block_end();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_offset_block_end<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetOffset_block_end(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const offset_block_end_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const offset_block_end_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_offsetBlockEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.OffsetBlockEnd();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_offsetBlockEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetOffsetBlockEnd(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const offsetBlockEnd_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const offsetBlockEnd_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_offset_inline_start<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Offset_inline_start();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_offset_inline_start<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetOffset_inline_start(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const offset_inline_start_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const offset_inline_start_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_offsetInlineStart<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.OffsetInlineStart();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_offsetInlineStart<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetOffsetInlineStart(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const offsetInlineStart_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const offsetInlineStart_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_offset_inline_end<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Offset_inline_end();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_offset_inline_end<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetOffset_inline_end(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const offset_inline_end_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const offset_inline_end_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_offsetInlineEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.OffsetInlineEnd();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_offsetInlineEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetOffsetInlineEnd(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const offsetInlineEnd_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const offsetInlineEnd_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_height<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Height();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_height<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetHeight(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const height_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const height_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_minHeight<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.MinHeight();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_minHeight<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMinHeight(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const minHeight_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const minHeight_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_min_height<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Min_height();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_min_height<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMin_height(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const min_height_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const min_height_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_maxHeight<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.MaxHeight();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_maxHeight<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMaxHeight(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const maxHeight_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const maxHeight_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_max_height<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Max_height();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_max_height<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMax_height(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const max_height_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const max_height_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_width<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Width();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_width<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetWidth(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const width_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const width_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_minWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.MinWidth();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_minWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMinWidth(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const minWidth_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const minWidth_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_min_width<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Min_width();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_min_width<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMin_width(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const min_width_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const min_width_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_maxWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.MaxWidth();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_maxWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMaxWidth(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const maxWidth_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const maxWidth_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_max_width<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Max_width();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_max_width<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMax_width(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const max_width_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const max_width_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_block_size<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Block_size();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_block_size<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBlock_size(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const block_size_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const block_size_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_blockSize<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.BlockSize();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_blockSize<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetBlockSize(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const blockSize_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const blockSize_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_inline_size<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Inline_size();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_inline_size<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetInline_size(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const inline_size_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const inline_size_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_inlineSize<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.InlineSize();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_inlineSize<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetInlineSize(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const inlineSize_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const inlineSize_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_max_block_size<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Max_block_size();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_max_block_size<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMax_block_size(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const max_block_size_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const max_block_size_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_maxBlockSize<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.MaxBlockSize();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_maxBlockSize<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMaxBlockSize(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const maxBlockSize_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const maxBlockSize_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_max_inline_size<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Max_inline_size();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_max_inline_size<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMax_inline_size(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const max_inline_size_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const max_inline_size_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_maxInlineSize<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.MaxInlineSize();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_maxInlineSize<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMaxInlineSize(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const maxInlineSize_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const maxInlineSize_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_min_block_size<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Min_block_size();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_min_block_size<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMin_block_size(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const min_block_size_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const min_block_size_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_minBlockSize<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.MinBlockSize();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_minBlockSize<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMinBlockSize(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const minBlockSize_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const minBlockSize_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_min_inline_size<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Min_inline_size();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_min_inline_size<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMin_inline_size(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const min_inline_size_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const min_inline_size_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_minInlineSize<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.MinInlineSize();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_minInlineSize<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetMinInlineSize(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const minInlineSize_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const minInlineSize_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_zIndex<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.ZIndex();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_zIndex<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetZIndex(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const zIndex_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const zIndex_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_z_index<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Z_index();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_z_index<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetZ_index(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const z_index_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const z_index_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_imageRendering<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.ImageRendering();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_imageRendering<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetImageRendering(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const imageRendering_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const imageRendering_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_image_rendering<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Image_rendering();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_image_rendering<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetImage_rendering(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const image_rendering_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const image_rendering_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_columnCount<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.ColumnCount();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_columnCount<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetColumnCount(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const columnCount_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const columnCount_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_column_count<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Column_count();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_column_count<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetColumn_count(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const column_count_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const column_count_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_columnWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.ColumnWidth();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_columnWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetColumnWidth(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const columnWidth_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const columnWidth_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_column_width<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Column_width();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_column_width<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetColumn_width(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const column_width_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const column_width_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_columns<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Columns();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_columns<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetColumns(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const columns_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const columns_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_columnGap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.ColumnGap();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_columnGap<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetColumnGap(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const columnGap_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const columnGap_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_column_gap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Column_gap();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_column_gap<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetColumn_gap(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const column_gap_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const column_gap_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_transition<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Transition();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_transition<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetTransition(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const transition_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const transition_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_transitionDuration<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.TransitionDuration();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_transitionDuration<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetTransitionDuration(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const transitionDuration_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const transitionDuration_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_transition_duration<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Transition_duration();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_transition_duration<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetTransition_duration(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const transition_duration_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const transition_duration_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_transitionTimingFunction<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.TransitionTimingFunction();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_transitionTimingFunction<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetTransitionTimingFunction(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const transitionTimingFunction_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const transitionTimingFunction_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_transition_timing_function<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Transition_timing_function();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_transition_timing_function<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetTransition_timing_function(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const transition_timing_function_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const transition_timing_function_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_transitionProperty<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.TransitionProperty();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_transitionProperty<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetTransitionProperty(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const transitionProperty_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const transitionProperty_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_transition_property<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Transition_property();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_transition_property<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetTransition_property(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const transition_property_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const transition_property_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_transitionDelay<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.TransitionDelay();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_transitionDelay<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetTransitionDelay(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const transitionDelay_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const transitionDelay_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_transition_delay<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Transition_delay();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_transition_delay<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetTransition_delay(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const transition_delay_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const transition_delay_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_flex<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Flex();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_flex<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetFlex(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const flex_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const flex_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_flexFlow<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.FlexFlow();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_flexFlow<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetFlexFlow(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const flexFlow_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const flexFlow_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_flex_flow<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Flex_flow();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_flex_flow<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetFlex_flow(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const flex_flow_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const flex_flow_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_flexDirection<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.FlexDirection();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_flexDirection<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetFlexDirection(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const flexDirection_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const flexDirection_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_flex_direction<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Flex_direction();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_flex_direction<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetFlex_direction(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const flex_direction_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const flex_direction_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_flexWrap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.FlexWrap();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_flexWrap<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetFlexWrap(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const flexWrap_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const flexWrap_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_flex_wrap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Flex_wrap();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_flex_wrap<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetFlex_wrap(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const flex_wrap_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const flex_wrap_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_justifyContent<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.JustifyContent();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_justifyContent<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetJustifyContent(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const justifyContent_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const justifyContent_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_justify_content<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Justify_content();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_justify_content<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetJustify_content(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const justify_content_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const justify_content_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_alignItems<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.AlignItems();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_alignItems<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetAlignItems(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const alignItems_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const alignItems_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_align_items<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Align_items();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_align_items<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetAlign_items(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const align_items_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const align_items_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_alignContent<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.AlignContent();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_alignContent<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetAlignContent(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const alignContent_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const alignContent_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_align_content<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Align_content();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_align_content<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetAlign_content(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const align_content_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const align_content_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_order<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Order();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_order<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetOrder(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const order_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const order_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_flexBasis<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.FlexBasis();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_flexBasis<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetFlexBasis(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const flexBasis_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const flexBasis_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_flex_basis<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Flex_basis();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_flex_basis<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetFlex_basis(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const flex_basis_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const flex_basis_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_flexGrow<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.FlexGrow();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_flexGrow<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetFlexGrow(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const flexGrow_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const flexGrow_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_flex_grow<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Flex_grow();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_flex_grow<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetFlex_grow(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const flex_grow_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const flex_grow_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_flexShrink<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.FlexShrink();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_flexShrink<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetFlexShrink(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const flexShrink_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const flexShrink_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_flex_shrink<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Flex_shrink();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_flex_shrink<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetFlex_shrink(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const flex_shrink_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const flex_shrink_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_alignSelf<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.AlignSelf();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_alignSelf<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetAlignSelf(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const alignSelf_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const alignSelf_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_align_self<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Align_self();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_align_self<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetAlign_self(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const align_self_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const align_self_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_animation<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Animation();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animation<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetAnimation(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const animation_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const animation_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_animation_name<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Animation_name();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animation_name<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetAnimation_name(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const animation_name_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const animation_name_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_animationName<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.AnimationName();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animationName<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetAnimationName(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const animationName_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const animationName_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_animation_duration<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Animation_duration();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animation_duration<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetAnimation_duration(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const animation_duration_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const animation_duration_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_animationDuration<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.AnimationDuration();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animationDuration<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetAnimationDuration(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const animationDuration_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const animationDuration_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_animation_timing_function<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Animation_timing_function();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animation_timing_function<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetAnimation_timing_function(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const animation_timing_function_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const animation_timing_function_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_animationTimingFunction<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.AnimationTimingFunction();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animationTimingFunction<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetAnimationTimingFunction(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const animationTimingFunction_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const animationTimingFunction_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_animation_iteration_count<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Animation_iteration_count();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animation_iteration_count<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetAnimation_iteration_count(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const animation_iteration_count_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const animation_iteration_count_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_animationIterationCount<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.AnimationIterationCount();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animationIterationCount<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetAnimationIterationCount(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const animationIterationCount_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const animationIterationCount_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_animation_direction<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Animation_direction();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animation_direction<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetAnimation_direction(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const animation_direction_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const animation_direction_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_animationDirection<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.AnimationDirection();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animationDirection<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetAnimationDirection(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const animationDirection_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const animationDirection_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_animation_play_state<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Animation_play_state();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animation_play_state<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetAnimation_play_state(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const animation_play_state_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const animation_play_state_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_animationPlayState<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.AnimationPlayState();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animationPlayState<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetAnimationPlayState(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const animationPlayState_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const animationPlayState_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_animation_fill_mode<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Animation_fill_mode();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animation_fill_mode<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetAnimation_fill_mode(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const animation_fill_mode_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const animation_fill_mode_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_animationFillMode<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.AnimationFillMode();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animationFillMode<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetAnimationFillMode(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const animationFillMode_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const animationFillMode_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_animation_delay<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.Animation_delay();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animation_delay<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetAnimation_delay(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const animation_delay_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const animation_delay_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_animationDelay<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue::<TH>();

        let result: DOMString = this.AnimationDelay();
        pop_current_element_queue::<TH>();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animationDelay<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue::<TH>();

        let result: Result<(), Error> = this.SetAnimationDelay(arg0);
        pop_current_element_queue::<TH>();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const animationDelay_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const animationDelay_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn FOO_finalize(_fop: *mut JSFreeOp, obj: *mut JSObject) {
	unimplemented!();
}

unsafe extern fn _finalize<TH: TypeHolderTrait>
(_fop: *mut JSFreeOp, obj: *mut JSObject) {
    return wrap_panic(panic::AssertUnwindSafe(|| {

        let this = native_from_object::<CSSStyleDeclaration<TH>>(obj).unwrap();
            if !this.is_null() {
                // The pointer can be null if the object is the unforgeable holder of that interface.
                let _ = Box::from_raw(this as *mut CSSStyleDeclaration<TH>);
            }
            debug!("CSSStyleDeclaration<TH> finalize: {:p}", this);
    }), ());
}

unsafe extern fn FOO_trace(trc: *mut JSTracer, obj: *mut JSObject) {
	unimplemented!();
}

unsafe extern fn _trace<TH: TypeHolderTrait>
(trc: *mut JSTracer, obj: *mut JSObject) {
    return wrap_panic(panic::AssertUnwindSafe(|| {

        let this = native_from_object::<CSSStyleDeclaration<TH>>(obj).unwrap();
        if this.is_null() { return; } // GC during obj creation
        (*this).trace(trc);
    }), ());
}

pub unsafe fn DefineProxyHandler<TH: TypeHolderTrait>
() -> *const libc::c_void {
    let traps = ProxyTraps {
        enter: None,
        getOwnPropertyDescriptor: Some(getOwnPropertyDescriptor::<TH>),
        defineProperty: Some(proxyhandler::define_property),
        ownPropertyKeys: Some(own_property_keys::<TH>),
        delete_: Some(proxyhandler::delete),
        enumerate: None,
        getPrototypeIfOrdinary: Some(proxyhandler::get_prototype_if_ordinary),
        preventExtensions: Some(proxyhandler::prevent_extensions),
        isExtensible: Some(proxyhandler::is_extensible),
        has: None,
        get: Some(get::<TH>),
        set: None,
        call: None,
        construct: None,
        getPropertyDescriptor: Some(get_property_descriptor),
        hasOwn: Some(hasOwn::<TH>),
        getOwnEnumerablePropertyKeys: Some(own_property_keys::<TH>),
        nativeCall: None,
        hasInstance: None,
        objectClassIs: None,
        className: Some(className::<TH>),
        fun_toString: None,
        boxedValue_unbox: None,
        defaultValue: None,
        trace: Some(FOO_trace),
        finalize: Some(FOO_finalize),
        objectMoved: None,
        isCallable: None,
        isConstructor: None,
    };

    CreateProxyHandler(&traps, Class.as_void_ptr())
}

#[inline] unsafe fn UnwrapProxy<TH: TypeHolderTrait>
(obj: RawHandleObject) -> *const CSSStyleDeclaration<TH> {
    /*if (xpc::WrapperFactory::IsXrayWrapper(obj)) {
        obj = js::UnwrapObject(obj);
    }*/
    //MOZ_ASSERT(IsProxy(obj));
    let box_ = GetProxyPrivate(obj.get()).to_private() as *const CSSStyleDeclaration<TH>;
    return box_;
}

pub unsafe fn FOO_malloc_size_of(
    ops: &mut MallocSizeOfOps, obj: *const c_void) -> usize {
	unimplemented!()
}

static Class: DOMClass = DOMClass {
    interface_chain: [ PrototypeList::ID::CSSStyleDeclaration, PrototypeList::ID::Last, PrototypeList::ID::Last, PrototypeList::ID::Last, PrototypeList::ID::Last, PrototypeList::ID::Last ],
    type_id: ::dom::bindings::codegen::InheritTypes::TopTypeId { alone: () },
    global: InterfaceObjectMap::Globals::EMPTY,
   	malloc_size_of: FOO_malloc_size_of as unsafe fn(&mut _, _) -> _,
};

unsafe extern fn own_property_keys<TH: TypeHolderTrait>
(cx: *mut JSContext, proxy: RawHandleObject, props: *mut AutoIdVector) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let unwrapped_proxy = UnwrapProxy::<TH>(proxy);
        for i in 0..(*unwrapped_proxy).Length() {
            rooted!(in(cx) let rooted_jsid = int_to_jsid(i as i32));
            AppendToAutoIdVector(props, rooted_jsid.handle().get());
        }
        rooted!(in(cx) let mut expando = ptr::null_mut::<JSObject>());
        get_expando_object(proxy, expando.handle_mut());
        if !expando.is_null() {
            GetPropertyKeys(cx, expando.handle(), JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, props);
        }

        return true;

    }), false);
}

unsafe extern fn getOwnPropertyDescriptor<TH: TypeHolderTrait>
(cx: *mut JSContext, proxy: RawHandleObject, id: RawHandleId, desc: RawMutableHandle<PropertyDescriptor>) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let index = get_array_index_from_id(cx, Handle::from_raw(id));
        if let Some(index) = index {
            let this = UnwrapProxy::<TH>(proxy);
            let this = &*this;
            let result: Option<DOMString> = this.IndexedGetter(index);

            if let Some(result) = result {
                rooted!(in(cx) let mut result_root = UndefinedValue());
                (result).to_jsval(cx, result_root.handle_mut());
                desc.get().value = result_root.get();
                fill_property_descriptor(MutableHandle::from_raw(desc), proxy.get(), JSPROP_ENUMERATE | JSPROP_READONLY);
                return true;
            }
        }
        rooted!(in(cx) let mut expando = ptr::null_mut::<JSObject>());
        get_expando_object(proxy, expando.handle_mut());
        //if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = GetExpandoObject(proxy))) {
        let proxy_lt = Handle::from_raw(proxy);
        let id_lt = Handle::from_raw(id);
        if !expando.is_null() {
            if !JS_GetPropertyDescriptorById(cx, expando.handle().into(), id, desc) {
                return false;
            }
            if !desc.obj.is_null() {
                // Pretend the property lives on the wrapper.
                desc.get().obj = proxy.get();
                return true;
            }
        }
        desc.get().obj = ptr::null_mut();
        return true;
    }), false);
}

unsafe extern fn className<TH: TypeHolderTrait>
(cx: *mut JSContext, _proxy: RawHandleObject) -> *const i8 {
    b"CSSStyleDeclaration\0" as *const u8 as *const i8
}

unsafe extern fn get<TH: TypeHolderTrait>
(cx: *mut JSContext, proxy: RawHandleObject, receiver: RawHandleValue, id: RawHandleId, vp: RawMutableHandleValue) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        //MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
        //"Should not have a XrayWrapper here");
        let proxy_lt = Handle::from_raw(proxy);
        let vp_lt = MutableHandle::from_raw(vp);
        let id_lt = Handle::from_raw(id);
        let receiver_lt = Handle::from_raw(receiver);

        let index = get_array_index_from_id(cx, id_lt);
        if let Some(index) = index {
            let this = UnwrapProxy::<TH>(proxy);
            let this = &*this;
            let result: Option<DOMString> = this.IndexedGetter(index);

            if let Some(result) = result {

                (result).to_jsval(cx, vp_lt);
                return true;
            }    // Even if we don't have this index, we don't forward the
            // get on to our expando object.
        } else {
            rooted!(in(cx) let mut expando = ptr::null_mut::<JSObject>());
            get_expando_object(proxy, expando.handle_mut());
            if !expando.is_null() {
                let mut hasProp = false;
                if !JS_HasPropertyById(cx, expando.handle().into(), id, &mut hasProp) {
                    return false;
                }

                if hasProp {
                    return JS_ForwardGetPropertyTo(cx, expando.handle().into(), id, receiver, vp);
                }
            }
        }

        let mut found = false;
        if !get_property_on_prototype(cx, proxy_lt, receiver_lt, id_lt, &mut found, vp_lt) {
            return false;
        }

        if found {
            return true;
        }

        vp.set(UndefinedValue());
        return true;
    }), false);
}

unsafe extern fn hasOwn<TH: TypeHolderTrait>
(cx: *mut JSContext, proxy: RawHandleObject, id: RawHandleId, bp: *mut bool) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let index = get_array_index_from_id(cx, Handle::from_raw(id));
        if let Some(index) = index {
            let this = UnwrapProxy::<TH>(proxy);
            let this = &*this;
            let result: Option<DOMString> = this.IndexedGetter(index);

            *bp = result.is_some();
            return true;
        }

        rooted!(in(cx) let mut expando = ptr::null_mut::<JSObject>());
        let proxy_lt = Handle::from_raw(proxy);
        let id_lt = Handle::from_raw(id);
        get_expando_object(proxy, expando.handle_mut());
        if !expando.is_null() {
            let ok = JS_HasPropertyById(cx, expando.handle().into(), id, bp);
            if !ok || *bp {
                return ok;
            }
        }
        *bp = false;
        return true;
    }), false);
}

pub unsafe fn Wrap<TH: TypeHolderTrait>
(cx: *mut JSContext, scope: &GlobalScope<TH>, object: Box<CSSStyleDeclaration<TH>>) -> DomRoot<CSSStyleDeclaration<TH>> {
    let scope = scope.reflector().get_jsobject();
    assert!(!scope.get().is_null());
    assert!(((*get_object_class(scope.get())).flags & JSCLASS_IS_GLOBAL) != 0);

    rooted!(in(cx) let mut proto = ptr::null_mut::<JSObject>());
    let _ac = JSAutoCompartment::new(cx, scope.get());
    GetProtoObject::<TH>(cx, scope, proto.handle_mut());
    assert!(!proto.is_null());

    let raw = Box::into_raw(object);
    let _rt = RootedTraceable::new(&*raw);

    let handler = RegisterBindings::PROXY_HANDLERS[PrototypeList::Proxies::CSSStyleDeclaration as usize];
    rooted!(in(cx) let private = PrivateValue(raw as *const libc::c_void));
    let obj = NewProxyObject(cx, handler,
                             private.handle(),
                             proto.get(), scope.get(),
                             ptr::null_mut(), ptr::null_mut());
    assert!(!obj.is_null());
    rooted!(in(cx) let obj = obj);


    (*raw).init_reflector(obj.get());

    DomRoot::from_ref(&*raw)
}

impl<TH: TypeHolderTrait> IDLInterface for CSSStyleDeclaration<TH> {
    #[inline]
    fn derives(class: &'static DOMClass) -> bool {
        class as *const _ == &Class as *const _
    }
}

impl<TH: TypeHolderTrait> PartialEq for CSSStyleDeclaration<TH> {
    fn eq(&self, other: &CSSStyleDeclaration<TH>) -> bool {
        self as *const CSSStyleDeclaration<TH> == &*other
    }
}

pub trait CSSStyleDeclarationMethods<TH: TypeHolderTrait> {
    fn CssText(&self) -> DOMString;
    fn SetCssText(&self, value: DOMString) -> ErrorResult;
    fn Length(&self) -> u32;
    fn Item(&self, index: u32) -> DOMString;
    fn GetPropertyValue(&self, property: DOMString) -> DOMString;
    fn GetPropertyPriority(&self, property: DOMString) -> DOMString;
    fn SetProperty(&self, property: DOMString, value: DOMString, priority: DOMString) -> Fallible<()>;
    fn SetPropertyValue(&self, property: DOMString, value: DOMString) -> Fallible<()>;
    fn SetPropertyPriority(&self, property: DOMString, priority: DOMString) -> Fallible<()>;
    fn RemoveProperty(&self, property: DOMString) -> Fallible<DOMString>;
    fn CssFloat(&self) -> DOMString;
    fn SetCssFloat(&self, value: DOMString) -> ErrorResult;
    fn All(&self) -> DOMString;
    fn SetAll(&self, value: DOMString) -> ErrorResult;
    fn Background(&self) -> DOMString;
    fn SetBackground(&self, value: DOMString) -> ErrorResult;
    fn BackgroundColor(&self) -> DOMString;
    fn SetBackgroundColor(&self, value: DOMString) -> ErrorResult;
    fn Background_color(&self) -> DOMString;
    fn SetBackground_color(&self, value: DOMString) -> ErrorResult;
    fn BackgroundPosition(&self) -> DOMString;
    fn SetBackgroundPosition(&self, value: DOMString) -> ErrorResult;
    fn Background_position(&self) -> DOMString;
    fn SetBackground_position(&self, value: DOMString) -> ErrorResult;
    fn BackgroundPositionX(&self) -> DOMString;
    fn SetBackgroundPositionX(&self, value: DOMString) -> ErrorResult;
    fn Background_position_x(&self) -> DOMString;
    fn SetBackground_position_x(&self, value: DOMString) -> ErrorResult;
    fn BackgroundPositionY(&self) -> DOMString;
    fn SetBackgroundPositionY(&self, value: DOMString) -> ErrorResult;
    fn Background_position_y(&self) -> DOMString;
    fn SetBackground_position_y(&self, value: DOMString) -> ErrorResult;
    fn BackgroundRepeat(&self) -> DOMString;
    fn SetBackgroundRepeat(&self, value: DOMString) -> ErrorResult;
    fn Background_repeat(&self) -> DOMString;
    fn SetBackground_repeat(&self, value: DOMString) -> ErrorResult;
    fn BackgroundImage(&self) -> DOMString;
    fn SetBackgroundImage(&self, value: DOMString) -> ErrorResult;
    fn Background_image(&self) -> DOMString;
    fn SetBackground_image(&self, value: DOMString) -> ErrorResult;
    fn BackgroundAttachment(&self) -> DOMString;
    fn SetBackgroundAttachment(&self, value: DOMString) -> ErrorResult;
    fn Background_attachment(&self) -> DOMString;
    fn SetBackground_attachment(&self, value: DOMString) -> ErrorResult;
    fn BackgroundSize(&self) -> DOMString;
    fn SetBackgroundSize(&self, value: DOMString) -> ErrorResult;
    fn Background_size(&self) -> DOMString;
    fn SetBackground_size(&self, value: DOMString) -> ErrorResult;
    fn BackgroundOrigin(&self) -> DOMString;
    fn SetBackgroundOrigin(&self, value: DOMString) -> ErrorResult;
    fn Background_origin(&self) -> DOMString;
    fn SetBackground_origin(&self, value: DOMString) -> ErrorResult;
    fn BackgroundClip(&self) -> DOMString;
    fn SetBackgroundClip(&self, value: DOMString) -> ErrorResult;
    fn Background_clip(&self) -> DOMString;
    fn SetBackground_clip(&self, value: DOMString) -> ErrorResult;
    fn Border(&self) -> DOMString;
    fn SetBorder(&self, value: DOMString) -> ErrorResult;
    fn BorderColor(&self) -> DOMString;
    fn SetBorderColor(&self, value: DOMString) -> ErrorResult;
    fn Border_color(&self) -> DOMString;
    fn SetBorder_color(&self, value: DOMString) -> ErrorResult;
    fn BorderRadius(&self) -> DOMString;
    fn SetBorderRadius(&self, value: DOMString) -> ErrorResult;
    fn Border_radius(&self) -> DOMString;
    fn SetBorder_radius(&self, value: DOMString) -> ErrorResult;
    fn BorderSpacing(&self) -> DOMString;
    fn SetBorderSpacing(&self, value: DOMString) -> ErrorResult;
    fn Border_spacing(&self) -> DOMString;
    fn SetBorder_spacing(&self, value: DOMString) -> ErrorResult;
    fn BorderStyle(&self) -> DOMString;
    fn SetBorderStyle(&self, value: DOMString) -> ErrorResult;
    fn Border_style(&self) -> DOMString;
    fn SetBorder_style(&self, value: DOMString) -> ErrorResult;
    fn BorderWidth(&self) -> DOMString;
    fn SetBorderWidth(&self, value: DOMString) -> ErrorResult;
    fn Border_width(&self) -> DOMString;
    fn SetBorder_width(&self, value: DOMString) -> ErrorResult;
    fn BorderBottom(&self) -> DOMString;
    fn SetBorderBottom(&self, value: DOMString) -> ErrorResult;
    fn Border_bottom(&self) -> DOMString;
    fn SetBorder_bottom(&self, value: DOMString) -> ErrorResult;
    fn BorderBottomColor(&self) -> DOMString;
    fn SetBorderBottomColor(&self, value: DOMString) -> ErrorResult;
    fn Border_bottom_color(&self) -> DOMString;
    fn SetBorder_bottom_color(&self, value: DOMString) -> ErrorResult;
    fn BorderBottomLeftRadius(&self) -> DOMString;
    fn SetBorderBottomLeftRadius(&self, value: DOMString) -> ErrorResult;
    fn Border_bottom_left_radius(&self) -> DOMString;
    fn SetBorder_bottom_left_radius(&self, value: DOMString) -> ErrorResult;
    fn BorderBottomRightRadius(&self) -> DOMString;
    fn SetBorderBottomRightRadius(&self, value: DOMString) -> ErrorResult;
    fn Border_bottom_right_radius(&self) -> DOMString;
    fn SetBorder_bottom_right_radius(&self, value: DOMString) -> ErrorResult;
    fn BorderBottomStyle(&self) -> DOMString;
    fn SetBorderBottomStyle(&self, value: DOMString) -> ErrorResult;
    fn Border_bottom_style(&self) -> DOMString;
    fn SetBorder_bottom_style(&self, value: DOMString) -> ErrorResult;
    fn BorderBottomWidth(&self) -> DOMString;
    fn SetBorderBottomWidth(&self, value: DOMString) -> ErrorResult;
    fn Border_bottom_width(&self) -> DOMString;
    fn SetBorder_bottom_width(&self, value: DOMString) -> ErrorResult;
    fn BorderLeft(&self) -> DOMString;
    fn SetBorderLeft(&self, value: DOMString) -> ErrorResult;
    fn Border_left(&self) -> DOMString;
    fn SetBorder_left(&self, value: DOMString) -> ErrorResult;
    fn BorderLeftColor(&self) -> DOMString;
    fn SetBorderLeftColor(&self, value: DOMString) -> ErrorResult;
    fn Border_left_color(&self) -> DOMString;
    fn SetBorder_left_color(&self, value: DOMString) -> ErrorResult;
    fn BorderLeftStyle(&self) -> DOMString;
    fn SetBorderLeftStyle(&self, value: DOMString) -> ErrorResult;
    fn Border_left_style(&self) -> DOMString;
    fn SetBorder_left_style(&self, value: DOMString) -> ErrorResult;
    fn BorderLeftWidth(&self) -> DOMString;
    fn SetBorderLeftWidth(&self, value: DOMString) -> ErrorResult;
    fn Border_left_width(&self) -> DOMString;
    fn SetBorder_left_width(&self, value: DOMString) -> ErrorResult;
    fn BorderRight(&self) -> DOMString;
    fn SetBorderRight(&self, value: DOMString) -> ErrorResult;
    fn Border_right(&self) -> DOMString;
    fn SetBorder_right(&self, value: DOMString) -> ErrorResult;
    fn BorderRightColor(&self) -> DOMString;
    fn SetBorderRightColor(&self, value: DOMString) -> ErrorResult;
    fn Border_right_color(&self) -> DOMString;
    fn SetBorder_right_color(&self, value: DOMString) -> ErrorResult;
    fn BorderRightStyle(&self) -> DOMString;
    fn SetBorderRightStyle(&self, value: DOMString) -> ErrorResult;
    fn Border_right_style(&self) -> DOMString;
    fn SetBorder_right_style(&self, value: DOMString) -> ErrorResult;
    fn BorderRightWidth(&self) -> DOMString;
    fn SetBorderRightWidth(&self, value: DOMString) -> ErrorResult;
    fn Border_right_width(&self) -> DOMString;
    fn SetBorder_right_width(&self, value: DOMString) -> ErrorResult;
    fn BorderTop(&self) -> DOMString;
    fn SetBorderTop(&self, value: DOMString) -> ErrorResult;
    fn Border_top(&self) -> DOMString;
    fn SetBorder_top(&self, value: DOMString) -> ErrorResult;
    fn BorderTopColor(&self) -> DOMString;
    fn SetBorderTopColor(&self, value: DOMString) -> ErrorResult;
    fn Border_top_color(&self) -> DOMString;
    fn SetBorder_top_color(&self, value: DOMString) -> ErrorResult;
    fn BorderTopLeftRadius(&self) -> DOMString;
    fn SetBorderTopLeftRadius(&self, value: DOMString) -> ErrorResult;
    fn Border_top_left_radius(&self) -> DOMString;
    fn SetBorder_top_left_radius(&self, value: DOMString) -> ErrorResult;
    fn BorderTopRightRadius(&self) -> DOMString;
    fn SetBorderTopRightRadius(&self, value: DOMString) -> ErrorResult;
    fn Border_top_right_radius(&self) -> DOMString;
    fn SetBorder_top_right_radius(&self, value: DOMString) -> ErrorResult;
    fn BorderTopStyle(&self) -> DOMString;
    fn SetBorderTopStyle(&self, value: DOMString) -> ErrorResult;
    fn Border_top_style(&self) -> DOMString;
    fn SetBorder_top_style(&self, value: DOMString) -> ErrorResult;
    fn BorderTopWidth(&self) -> DOMString;
    fn SetBorderTopWidth(&self, value: DOMString) -> ErrorResult;
    fn Border_top_width(&self) -> DOMString;
    fn SetBorder_top_width(&self, value: DOMString) -> ErrorResult;
    fn Border_image_source(&self) -> DOMString;
    fn SetBorder_image_source(&self, value: DOMString) -> ErrorResult;
    fn BorderImageSource(&self) -> DOMString;
    fn SetBorderImageSource(&self, value: DOMString) -> ErrorResult;
    fn Border_image_slice(&self) -> DOMString;
    fn SetBorder_image_slice(&self, value: DOMString) -> ErrorResult;
    fn BorderImageSlice(&self) -> DOMString;
    fn SetBorderImageSlice(&self, value: DOMString) -> ErrorResult;
    fn Border_image_repeat(&self) -> DOMString;
    fn SetBorder_image_repeat(&self, value: DOMString) -> ErrorResult;
    fn BorderImageRepeat(&self) -> DOMString;
    fn SetBorderImageRepeat(&self, value: DOMString) -> ErrorResult;
    fn Border_image_outset(&self) -> DOMString;
    fn SetBorder_image_outset(&self, value: DOMString) -> ErrorResult;
    fn BorderImageOutset(&self) -> DOMString;
    fn SetBorderImageOutset(&self, value: DOMString) -> ErrorResult;
    fn Border_image_width(&self) -> DOMString;
    fn SetBorder_image_width(&self, value: DOMString) -> ErrorResult;
    fn BorderImageWidth(&self) -> DOMString;
    fn SetBorderImageWidth(&self, value: DOMString) -> ErrorResult;
    fn Border_image(&self) -> DOMString;
    fn SetBorder_image(&self, value: DOMString) -> ErrorResult;
    fn BorderImage(&self) -> DOMString;
    fn SetBorderImage(&self, value: DOMString) -> ErrorResult;
    fn Border_block_start_color(&self) -> DOMString;
    fn SetBorder_block_start_color(&self, value: DOMString) -> ErrorResult;
    fn BorderBlockStartColor(&self) -> DOMString;
    fn SetBorderBlockStartColor(&self, value: DOMString) -> ErrorResult;
    fn Border_block_start_width(&self) -> DOMString;
    fn SetBorder_block_start_width(&self, value: DOMString) -> ErrorResult;
    fn BorderBlockStartWidth(&self) -> DOMString;
    fn SetBorderBlockStartWidth(&self, value: DOMString) -> ErrorResult;
    fn Border_block_start_style(&self) -> DOMString;
    fn SetBorder_block_start_style(&self, value: DOMString) -> ErrorResult;
    fn BorderBlockStartStyle(&self) -> DOMString;
    fn SetBorderBlockStartStyle(&self, value: DOMString) -> ErrorResult;
    fn Border_block_end_color(&self) -> DOMString;
    fn SetBorder_block_end_color(&self, value: DOMString) -> ErrorResult;
    fn BorderBlockEndColor(&self) -> DOMString;
    fn SetBorderBlockEndColor(&self, value: DOMString) -> ErrorResult;
    fn Border_block_end_width(&self) -> DOMString;
    fn SetBorder_block_end_width(&self, value: DOMString) -> ErrorResult;
    fn BorderBlockEndWidth(&self) -> DOMString;
    fn SetBorderBlockEndWidth(&self, value: DOMString) -> ErrorResult;
    fn Border_block_end_style(&self) -> DOMString;
    fn SetBorder_block_end_style(&self, value: DOMString) -> ErrorResult;
    fn BorderBlockEndStyle(&self) -> DOMString;
    fn SetBorderBlockEndStyle(&self, value: DOMString) -> ErrorResult;
    fn Border_inline_start_color(&self) -> DOMString;
    fn SetBorder_inline_start_color(&self, value: DOMString) -> ErrorResult;
    fn BorderInlineStartColor(&self) -> DOMString;
    fn SetBorderInlineStartColor(&self, value: DOMString) -> ErrorResult;
    fn Border_inline_start_width(&self) -> DOMString;
    fn SetBorder_inline_start_width(&self, value: DOMString) -> ErrorResult;
    fn BorderInlineStartWidth(&self) -> DOMString;
    fn SetBorderInlineStartWidth(&self, value: DOMString) -> ErrorResult;
    fn Border_inline_start_style(&self) -> DOMString;
    fn SetBorder_inline_start_style(&self, value: DOMString) -> ErrorResult;
    fn BorderInlineStartStyle(&self) -> DOMString;
    fn SetBorderInlineStartStyle(&self, value: DOMString) -> ErrorResult;
    fn Border_inline_end_color(&self) -> DOMString;
    fn SetBorder_inline_end_color(&self, value: DOMString) -> ErrorResult;
    fn BorderInlineEndColor(&self) -> DOMString;
    fn SetBorderInlineEndColor(&self, value: DOMString) -> ErrorResult;
    fn Border_inline_end_width(&self) -> DOMString;
    fn SetBorder_inline_end_width(&self, value: DOMString) -> ErrorResult;
    fn BorderInlineEndWidth(&self) -> DOMString;
    fn SetBorderInlineEndWidth(&self, value: DOMString) -> ErrorResult;
    fn Border_inline_end_style(&self) -> DOMString;
    fn SetBorder_inline_end_style(&self, value: DOMString) -> ErrorResult;
    fn BorderInlineEndStyle(&self) -> DOMString;
    fn SetBorderInlineEndStyle(&self, value: DOMString) -> ErrorResult;
    fn Border_block_start(&self) -> DOMString;
    fn SetBorder_block_start(&self, value: DOMString) -> ErrorResult;
    fn BorderBlockStart(&self) -> DOMString;
    fn SetBorderBlockStart(&self, value: DOMString) -> ErrorResult;
    fn Border_block_end(&self) -> DOMString;
    fn SetBorder_block_end(&self, value: DOMString) -> ErrorResult;
    fn BorderBlockEnd(&self) -> DOMString;
    fn SetBorderBlockEnd(&self, value: DOMString) -> ErrorResult;
    fn Border_inline_start(&self) -> DOMString;
    fn SetBorder_inline_start(&self, value: DOMString) -> ErrorResult;
    fn BorderInlineStart(&self) -> DOMString;
    fn SetBorderInlineStart(&self, value: DOMString) -> ErrorResult;
    fn Border_inline_end(&self) -> DOMString;
    fn SetBorder_inline_end(&self, value: DOMString) -> ErrorResult;
    fn BorderInlineEnd(&self) -> DOMString;
    fn SetBorderInlineEnd(&self, value: DOMString) -> ErrorResult;
    fn Content(&self) -> DOMString;
    fn SetContent(&self, value: DOMString) -> ErrorResult;
    fn Color(&self) -> DOMString;
    fn SetColor(&self, value: DOMString) -> ErrorResult;
    fn Display(&self) -> DOMString;
    fn SetDisplay(&self, value: DOMString) -> ErrorResult;
    fn Opacity(&self) -> DOMString;
    fn SetOpacity(&self, value: DOMString) -> ErrorResult;
    fn Visibility(&self) -> DOMString;
    fn SetVisibility(&self, value: DOMString) -> ErrorResult;
    fn Cursor(&self) -> DOMString;
    fn SetCursor(&self, value: DOMString) -> ErrorResult;
    fn BoxSizing(&self) -> DOMString;
    fn SetBoxSizing(&self, value: DOMString) -> ErrorResult;
    fn Box_sizing(&self) -> DOMString;
    fn SetBox_sizing(&self, value: DOMString) -> ErrorResult;
    fn BoxShadow(&self) -> DOMString;
    fn SetBoxShadow(&self, value: DOMString) -> ErrorResult;
    fn Box_shadow(&self) -> DOMString;
    fn SetBox_shadow(&self, value: DOMString) -> ErrorResult;
    fn TextShadow(&self) -> DOMString;
    fn SetTextShadow(&self, value: DOMString) -> ErrorResult;
    fn Text_shadow(&self) -> DOMString;
    fn SetText_shadow(&self, value: DOMString) -> ErrorResult;
    fn Float(&self) -> DOMString;
    fn SetFloat(&self, value: DOMString) -> ErrorResult;
    fn Clear(&self) -> DOMString;
    fn SetClear(&self, value: DOMString) -> ErrorResult;
    fn Clip(&self) -> DOMString;
    fn SetClip(&self, value: DOMString) -> ErrorResult;
    fn Transform(&self) -> DOMString;
    fn SetTransform(&self, value: DOMString) -> ErrorResult;
    fn TransformOrigin(&self) -> DOMString;
    fn SetTransformOrigin(&self, value: DOMString) -> ErrorResult;
    fn Transform_origin(&self) -> DOMString;
    fn SetTransform_origin(&self, value: DOMString) -> ErrorResult;
    fn Perspective(&self) -> DOMString;
    fn SetPerspective(&self, value: DOMString) -> ErrorResult;
    fn PerspectiveOrigin(&self) -> DOMString;
    fn SetPerspectiveOrigin(&self, value: DOMString) -> ErrorResult;
    fn Perspective_origin(&self) -> DOMString;
    fn SetPerspective_origin(&self, value: DOMString) -> ErrorResult;
    fn TransformStyle(&self) -> DOMString;
    fn SetTransformStyle(&self, value: DOMString) -> ErrorResult;
    fn Transform_style(&self) -> DOMString;
    fn SetTransform_style(&self, value: DOMString) -> ErrorResult;
    fn BackfaceVisibility(&self) -> DOMString;
    fn SetBackfaceVisibility(&self, value: DOMString) -> ErrorResult;
    fn Backface_visibility(&self) -> DOMString;
    fn SetBackface_visibility(&self, value: DOMString) -> ErrorResult;
    fn Rotate(&self) -> DOMString;
    fn SetRotate(&self, value: DOMString) -> ErrorResult;
    fn Scale(&self) -> DOMString;
    fn SetScale(&self, value: DOMString) -> ErrorResult;
    fn Translate(&self) -> DOMString;
    fn SetTranslate(&self, value: DOMString) -> ErrorResult;
    fn Direction(&self) -> DOMString;
    fn SetDirection(&self, value: DOMString) -> ErrorResult;
    fn UnicodeBidi(&self) -> DOMString;
    fn SetUnicodeBidi(&self, value: DOMString) -> ErrorResult;
    fn Unicode_bidi(&self) -> DOMString;
    fn SetUnicode_bidi(&self, value: DOMString) -> ErrorResult;
    fn Filter(&self) -> DOMString;
    fn SetFilter(&self, value: DOMString) -> ErrorResult;
    fn LineHeight(&self) -> DOMString;
    fn SetLineHeight(&self, value: DOMString) -> ErrorResult;
    fn Line_height(&self) -> DOMString;
    fn SetLine_height(&self, value: DOMString) -> ErrorResult;
    fn MixBlendMode(&self) -> DOMString;
    fn SetMixBlendMode(&self, value: DOMString) -> ErrorResult;
    fn Mix_blend_mode(&self) -> DOMString;
    fn SetMix_blend_mode(&self, value: DOMString) -> ErrorResult;
    fn VerticalAlign(&self) -> DOMString;
    fn SetVerticalAlign(&self, value: DOMString) -> ErrorResult;
    fn Vertical_align(&self) -> DOMString;
    fn SetVertical_align(&self, value: DOMString) -> ErrorResult;
    fn ListStyle(&self) -> DOMString;
    fn SetListStyle(&self, value: DOMString) -> ErrorResult;
    fn List_style(&self) -> DOMString;
    fn SetList_style(&self, value: DOMString) -> ErrorResult;
    fn ListStylePosition(&self) -> DOMString;
    fn SetListStylePosition(&self, value: DOMString) -> ErrorResult;
    fn List_style_position(&self) -> DOMString;
    fn SetList_style_position(&self, value: DOMString) -> ErrorResult;
    fn ListStyleType(&self) -> DOMString;
    fn SetListStyleType(&self, value: DOMString) -> ErrorResult;
    fn List_style_type(&self) -> DOMString;
    fn SetList_style_type(&self, value: DOMString) -> ErrorResult;
    fn ListStyleImage(&self) -> DOMString;
    fn SetListStyleImage(&self, value: DOMString) -> ErrorResult;
    fn List_style_image(&self) -> DOMString;
    fn SetList_style_image(&self, value: DOMString) -> ErrorResult;
    fn Quotes(&self) -> DOMString;
    fn SetQuotes(&self, value: DOMString) -> ErrorResult;
    fn CounterIncrement(&self) -> DOMString;
    fn SetCounterIncrement(&self, value: DOMString) -> ErrorResult;
    fn Counter_increment(&self) -> DOMString;
    fn SetCounter_increment(&self, value: DOMString) -> ErrorResult;
    fn CounterReset(&self) -> DOMString;
    fn SetCounterReset(&self, value: DOMString) -> ErrorResult;
    fn Counter_reset(&self) -> DOMString;
    fn SetCounter_reset(&self, value: DOMString) -> ErrorResult;
    fn Overflow(&self) -> DOMString;
    fn SetOverflow(&self, value: DOMString) -> ErrorResult;
    fn OverflowX(&self) -> DOMString;
    fn SetOverflowX(&self, value: DOMString) -> ErrorResult;
    fn Overflow_x(&self) -> DOMString;
    fn SetOverflow_x(&self, value: DOMString) -> ErrorResult;
    fn OverflowY(&self) -> DOMString;
    fn SetOverflowY(&self, value: DOMString) -> ErrorResult;
    fn Overflow_y(&self) -> DOMString;
    fn SetOverflow_y(&self, value: DOMString) -> ErrorResult;
    fn OverflowWrap(&self) -> DOMString;
    fn SetOverflowWrap(&self, value: DOMString) -> ErrorResult;
    fn Overflow_wrap(&self) -> DOMString;
    fn SetOverflow_wrap(&self, value: DOMString) -> ErrorResult;
    fn TableLayout(&self) -> DOMString;
    fn SetTableLayout(&self, value: DOMString) -> ErrorResult;
    fn Table_layout(&self) -> DOMString;
    fn SetTable_layout(&self, value: DOMString) -> ErrorResult;
    fn BorderCollapse(&self) -> DOMString;
    fn SetBorderCollapse(&self, value: DOMString) -> ErrorResult;
    fn Border_collapse(&self) -> DOMString;
    fn SetBorder_collapse(&self, value: DOMString) -> ErrorResult;
    fn EmptyCells(&self) -> DOMString;
    fn SetEmptyCells(&self, value: DOMString) -> ErrorResult;
    fn Empty_cells(&self) -> DOMString;
    fn SetEmpty_cells(&self, value: DOMString) -> ErrorResult;
    fn CaptionSide(&self) -> DOMString;
    fn SetCaptionSide(&self, value: DOMString) -> ErrorResult;
    fn Caption_side(&self) -> DOMString;
    fn SetCaption_side(&self, value: DOMString) -> ErrorResult;
    fn WhiteSpace(&self) -> DOMString;
    fn SetWhiteSpace(&self, value: DOMString) -> ErrorResult;
    fn White_space(&self) -> DOMString;
    fn SetWhite_space(&self, value: DOMString) -> ErrorResult;
    fn WritingMode(&self) -> DOMString;
    fn SetWritingMode(&self, value: DOMString) -> ErrorResult;
    fn Writing_mode(&self) -> DOMString;
    fn SetWriting_mode(&self, value: DOMString) -> ErrorResult;
    fn LetterSpacing(&self) -> DOMString;
    fn SetLetterSpacing(&self, value: DOMString) -> ErrorResult;
    fn Letter_spacing(&self) -> DOMString;
    fn SetLetter_spacing(&self, value: DOMString) -> ErrorResult;
    fn WordBreak(&self) -> DOMString;
    fn SetWordBreak(&self, value: DOMString) -> ErrorResult;
    fn Word_break(&self) -> DOMString;
    fn SetWord_break(&self, value: DOMString) -> ErrorResult;
    fn WordSpacing(&self) -> DOMString;
    fn SetWordSpacing(&self, value: DOMString) -> ErrorResult;
    fn Word_spacing(&self) -> DOMString;
    fn SetWord_spacing(&self, value: DOMString) -> ErrorResult;
    fn WordWrap(&self) -> DOMString;
    fn SetWordWrap(&self, value: DOMString) -> ErrorResult;
    fn Word_wrap(&self) -> DOMString;
    fn SetWord_wrap(&self, value: DOMString) -> ErrorResult;
    fn TextOverflow(&self) -> DOMString;
    fn SetTextOverflow(&self, value: DOMString) -> ErrorResult;
    fn Text_overflow(&self) -> DOMString;
    fn SetText_overflow(&self, value: DOMString) -> ErrorResult;
    fn TextAlign(&self) -> DOMString;
    fn SetTextAlign(&self, value: DOMString) -> ErrorResult;
    fn Text_align(&self) -> DOMString;
    fn SetText_align(&self, value: DOMString) -> ErrorResult;
    fn TextDecoration(&self) -> DOMString;
    fn SetTextDecoration(&self, value: DOMString) -> ErrorResult;
    fn Text_decoration(&self) -> DOMString;
    fn SetText_decoration(&self, value: DOMString) -> ErrorResult;
    fn TextDecorationLine(&self) -> DOMString;
    fn SetTextDecorationLine(&self, value: DOMString) -> ErrorResult;
    fn Text_decoration_line(&self) -> DOMString;
    fn SetText_decoration_line(&self, value: DOMString) -> ErrorResult;
    fn TextIndent(&self) -> DOMString;
    fn SetTextIndent(&self, value: DOMString) -> ErrorResult;
    fn Text_indent(&self) -> DOMString;
    fn SetText_indent(&self, value: DOMString) -> ErrorResult;
    fn TextJustify(&self) -> DOMString;
    fn SetTextJustify(&self, value: DOMString) -> ErrorResult;
    fn Text_justify(&self) -> DOMString;
    fn SetText_justify(&self, value: DOMString) -> ErrorResult;
    fn TextRendering(&self) -> DOMString;
    fn SetTextRendering(&self, value: DOMString) -> ErrorResult;
    fn Text_rendering(&self) -> DOMString;
    fn SetText_rendering(&self, value: DOMString) -> ErrorResult;
    fn TextTransform(&self) -> DOMString;
    fn SetTextTransform(&self, value: DOMString) -> ErrorResult;
    fn Text_transform(&self) -> DOMString;
    fn SetText_transform(&self, value: DOMString) -> ErrorResult;
    fn Font(&self) -> DOMString;
    fn SetFont(&self, value: DOMString) -> ErrorResult;
    fn FontFamily(&self) -> DOMString;
    fn SetFontFamily(&self, value: DOMString) -> ErrorResult;
    fn Font_family(&self) -> DOMString;
    fn SetFont_family(&self, value: DOMString) -> ErrorResult;
    fn FontSize(&self) -> DOMString;
    fn SetFontSize(&self, value: DOMString) -> ErrorResult;
    fn Font_size(&self) -> DOMString;
    fn SetFont_size(&self, value: DOMString) -> ErrorResult;
    fn FontStretch(&self) -> DOMString;
    fn SetFontStretch(&self, value: DOMString) -> ErrorResult;
    fn Font_stretch(&self) -> DOMString;
    fn SetFont_stretch(&self, value: DOMString) -> ErrorResult;
    fn FontStyle(&self) -> DOMString;
    fn SetFontStyle(&self, value: DOMString) -> ErrorResult;
    fn Font_style(&self) -> DOMString;
    fn SetFont_style(&self, value: DOMString) -> ErrorResult;
    fn FontVariant(&self) -> DOMString;
    fn SetFontVariant(&self, value: DOMString) -> ErrorResult;
    fn Font_variant(&self) -> DOMString;
    fn SetFont_variant(&self, value: DOMString) -> ErrorResult;
    fn FontVariantCaps(&self) -> DOMString;
    fn SetFontVariantCaps(&self, value: DOMString) -> ErrorResult;
    fn Font_variant_caps(&self) -> DOMString;
    fn SetFont_variant_caps(&self, value: DOMString) -> ErrorResult;
    fn FontWeight(&self) -> DOMString;
    fn SetFontWeight(&self, value: DOMString) -> ErrorResult;
    fn Font_weight(&self) -> DOMString;
    fn SetFont_weight(&self, value: DOMString) -> ErrorResult;
    fn Margin(&self) -> DOMString;
    fn SetMargin(&self, value: DOMString) -> ErrorResult;
    fn MarginBottom(&self) -> DOMString;
    fn SetMarginBottom(&self, value: DOMString) -> ErrorResult;
    fn Margin_bottom(&self) -> DOMString;
    fn SetMargin_bottom(&self, value: DOMString) -> ErrorResult;
    fn MarginLeft(&self) -> DOMString;
    fn SetMarginLeft(&self, value: DOMString) -> ErrorResult;
    fn Margin_left(&self) -> DOMString;
    fn SetMargin_left(&self, value: DOMString) -> ErrorResult;
    fn MarginRight(&self) -> DOMString;
    fn SetMarginRight(&self, value: DOMString) -> ErrorResult;
    fn Margin_right(&self) -> DOMString;
    fn SetMargin_right(&self, value: DOMString) -> ErrorResult;
    fn MarginTop(&self) -> DOMString;
    fn SetMarginTop(&self, value: DOMString) -> ErrorResult;
    fn Margin_top(&self) -> DOMString;
    fn SetMargin_top(&self, value: DOMString) -> ErrorResult;
    fn Margin_block_start(&self) -> DOMString;
    fn SetMargin_block_start(&self, value: DOMString) -> ErrorResult;
    fn MarginBlockStart(&self) -> DOMString;
    fn SetMarginBlockStart(&self, value: DOMString) -> ErrorResult;
    fn Margin_block_end(&self) -> DOMString;
    fn SetMargin_block_end(&self, value: DOMString) -> ErrorResult;
    fn MarginBlockEnd(&self) -> DOMString;
    fn SetMarginBlockEnd(&self, value: DOMString) -> ErrorResult;
    fn Margin_inline_start(&self) -> DOMString;
    fn SetMargin_inline_start(&self, value: DOMString) -> ErrorResult;
    fn MarginInlineStart(&self) -> DOMString;
    fn SetMarginInlineStart(&self, value: DOMString) -> ErrorResult;
    fn Margin_inline_end(&self) -> DOMString;
    fn SetMargin_inline_end(&self, value: DOMString) -> ErrorResult;
    fn MarginInlineEnd(&self) -> DOMString;
    fn SetMarginInlineEnd(&self, value: DOMString) -> ErrorResult;
    fn Padding(&self) -> DOMString;
    fn SetPadding(&self, value: DOMString) -> ErrorResult;
    fn PaddingBottom(&self) -> DOMString;
    fn SetPaddingBottom(&self, value: DOMString) -> ErrorResult;
    fn Padding_bottom(&self) -> DOMString;
    fn SetPadding_bottom(&self, value: DOMString) -> ErrorResult;
    fn PaddingLeft(&self) -> DOMString;
    fn SetPaddingLeft(&self, value: DOMString) -> ErrorResult;
    fn Padding_left(&self) -> DOMString;
    fn SetPadding_left(&self, value: DOMString) -> ErrorResult;
    fn PaddingRight(&self) -> DOMString;
    fn SetPaddingRight(&self, value: DOMString) -> ErrorResult;
    fn Padding_right(&self) -> DOMString;
    fn SetPadding_right(&self, value: DOMString) -> ErrorResult;
    fn PaddingTop(&self) -> DOMString;
    fn SetPaddingTop(&self, value: DOMString) -> ErrorResult;
    fn Padding_top(&self) -> DOMString;
    fn SetPadding_top(&self, value: DOMString) -> ErrorResult;
    fn Padding_block_start(&self) -> DOMString;
    fn SetPadding_block_start(&self, value: DOMString) -> ErrorResult;
    fn PaddingBlockStart(&self) -> DOMString;
    fn SetPaddingBlockStart(&self, value: DOMString) -> ErrorResult;
    fn Padding_block_end(&self) -> DOMString;
    fn SetPadding_block_end(&self, value: DOMString) -> ErrorResult;
    fn PaddingBlockEnd(&self) -> DOMString;
    fn SetPaddingBlockEnd(&self, value: DOMString) -> ErrorResult;
    fn Padding_inline_start(&self) -> DOMString;
    fn SetPadding_inline_start(&self, value: DOMString) -> ErrorResult;
    fn PaddingInlineStart(&self) -> DOMString;
    fn SetPaddingInlineStart(&self, value: DOMString) -> ErrorResult;
    fn Padding_inline_end(&self) -> DOMString;
    fn SetPadding_inline_end(&self, value: DOMString) -> ErrorResult;
    fn PaddingInlineEnd(&self) -> DOMString;
    fn SetPaddingInlineEnd(&self, value: DOMString) -> ErrorResult;
    fn Outline(&self) -> DOMString;
    fn SetOutline(&self, value: DOMString) -> ErrorResult;
    fn OutlineColor(&self) -> DOMString;
    fn SetOutlineColor(&self, value: DOMString) -> ErrorResult;
    fn Outline_color(&self) -> DOMString;
    fn SetOutline_color(&self, value: DOMString) -> ErrorResult;
    fn OutlineStyle(&self) -> DOMString;
    fn SetOutlineStyle(&self, value: DOMString) -> ErrorResult;
    fn Outline_style(&self) -> DOMString;
    fn SetOutline_style(&self, value: DOMString) -> ErrorResult;
    fn OutlineWidth(&self) -> DOMString;
    fn SetOutlineWidth(&self, value: DOMString) -> ErrorResult;
    fn Outline_width(&self) -> DOMString;
    fn SetOutline_width(&self, value: DOMString) -> ErrorResult;
    fn OutlineOffset(&self) -> DOMString;
    fn SetOutlineOffset(&self, value: DOMString) -> ErrorResult;
    fn Outline_offset(&self) -> DOMString;
    fn SetOutline_offset(&self, value: DOMString) -> ErrorResult;
    fn Position(&self) -> DOMString;
    fn SetPosition(&self, value: DOMString) -> ErrorResult;
    fn PointerEvents(&self) -> DOMString;
    fn SetPointerEvents(&self, value: DOMString) -> ErrorResult;
    fn Pointer_events(&self) -> DOMString;
    fn SetPointer_events(&self, value: DOMString) -> ErrorResult;
    fn Top(&self) -> DOMString;
    fn SetTop(&self, value: DOMString) -> ErrorResult;
    fn Right(&self) -> DOMString;
    fn SetRight(&self, value: DOMString) -> ErrorResult;
    fn Left(&self) -> DOMString;
    fn SetLeft(&self, value: DOMString) -> ErrorResult;
    fn Bottom(&self) -> DOMString;
    fn SetBottom(&self, value: DOMString) -> ErrorResult;
    fn Offset_block_start(&self) -> DOMString;
    fn SetOffset_block_start(&self, value: DOMString) -> ErrorResult;
    fn OffsetBlockStart(&self) -> DOMString;
    fn SetOffsetBlockStart(&self, value: DOMString) -> ErrorResult;
    fn Offset_block_end(&self) -> DOMString;
    fn SetOffset_block_end(&self, value: DOMString) -> ErrorResult;
    fn OffsetBlockEnd(&self) -> DOMString;
    fn SetOffsetBlockEnd(&self, value: DOMString) -> ErrorResult;
    fn Offset_inline_start(&self) -> DOMString;
    fn SetOffset_inline_start(&self, value: DOMString) -> ErrorResult;
    fn OffsetInlineStart(&self) -> DOMString;
    fn SetOffsetInlineStart(&self, value: DOMString) -> ErrorResult;
    fn Offset_inline_end(&self) -> DOMString;
    fn SetOffset_inline_end(&self, value: DOMString) -> ErrorResult;
    fn OffsetInlineEnd(&self) -> DOMString;
    fn SetOffsetInlineEnd(&self, value: DOMString) -> ErrorResult;
    fn Height(&self) -> DOMString;
    fn SetHeight(&self, value: DOMString) -> ErrorResult;
    fn MinHeight(&self) -> DOMString;
    fn SetMinHeight(&self, value: DOMString) -> ErrorResult;
    fn Min_height(&self) -> DOMString;
    fn SetMin_height(&self, value: DOMString) -> ErrorResult;
    fn MaxHeight(&self) -> DOMString;
    fn SetMaxHeight(&self, value: DOMString) -> ErrorResult;
    fn Max_height(&self) -> DOMString;
    fn SetMax_height(&self, value: DOMString) -> ErrorResult;
    fn Width(&self) -> DOMString;
    fn SetWidth(&self, value: DOMString) -> ErrorResult;
    fn MinWidth(&self) -> DOMString;
    fn SetMinWidth(&self, value: DOMString) -> ErrorResult;
    fn Min_width(&self) -> DOMString;
    fn SetMin_width(&self, value: DOMString) -> ErrorResult;
    fn MaxWidth(&self) -> DOMString;
    fn SetMaxWidth(&self, value: DOMString) -> ErrorResult;
    fn Max_width(&self) -> DOMString;
    fn SetMax_width(&self, value: DOMString) -> ErrorResult;
    fn Block_size(&self) -> DOMString;
    fn SetBlock_size(&self, value: DOMString) -> ErrorResult;
    fn BlockSize(&self) -> DOMString;
    fn SetBlockSize(&self, value: DOMString) -> ErrorResult;
    fn Inline_size(&self) -> DOMString;
    fn SetInline_size(&self, value: DOMString) -> ErrorResult;
    fn InlineSize(&self) -> DOMString;
    fn SetInlineSize(&self, value: DOMString) -> ErrorResult;
    fn Max_block_size(&self) -> DOMString;
    fn SetMax_block_size(&self, value: DOMString) -> ErrorResult;
    fn MaxBlockSize(&self) -> DOMString;
    fn SetMaxBlockSize(&self, value: DOMString) -> ErrorResult;
    fn Max_inline_size(&self) -> DOMString;
    fn SetMax_inline_size(&self, value: DOMString) -> ErrorResult;
    fn MaxInlineSize(&self) -> DOMString;
    fn SetMaxInlineSize(&self, value: DOMString) -> ErrorResult;
    fn Min_block_size(&self) -> DOMString;
    fn SetMin_block_size(&self, value: DOMString) -> ErrorResult;
    fn MinBlockSize(&self) -> DOMString;
    fn SetMinBlockSize(&self, value: DOMString) -> ErrorResult;
    fn Min_inline_size(&self) -> DOMString;
    fn SetMin_inline_size(&self, value: DOMString) -> ErrorResult;
    fn MinInlineSize(&self) -> DOMString;
    fn SetMinInlineSize(&self, value: DOMString) -> ErrorResult;
    fn ZIndex(&self) -> DOMString;
    fn SetZIndex(&self, value: DOMString) -> ErrorResult;
    fn Z_index(&self) -> DOMString;
    fn SetZ_index(&self, value: DOMString) -> ErrorResult;
    fn ImageRendering(&self) -> DOMString;
    fn SetImageRendering(&self, value: DOMString) -> ErrorResult;
    fn Image_rendering(&self) -> DOMString;
    fn SetImage_rendering(&self, value: DOMString) -> ErrorResult;
    fn ColumnCount(&self) -> DOMString;
    fn SetColumnCount(&self, value: DOMString) -> ErrorResult;
    fn Column_count(&self) -> DOMString;
    fn SetColumn_count(&self, value: DOMString) -> ErrorResult;
    fn ColumnWidth(&self) -> DOMString;
    fn SetColumnWidth(&self, value: DOMString) -> ErrorResult;
    fn Column_width(&self) -> DOMString;
    fn SetColumn_width(&self, value: DOMString) -> ErrorResult;
    fn Columns(&self) -> DOMString;
    fn SetColumns(&self, value: DOMString) -> ErrorResult;
    fn ColumnGap(&self) -> DOMString;
    fn SetColumnGap(&self, value: DOMString) -> ErrorResult;
    fn Column_gap(&self) -> DOMString;
    fn SetColumn_gap(&self, value: DOMString) -> ErrorResult;
    fn Transition(&self) -> DOMString;
    fn SetTransition(&self, value: DOMString) -> ErrorResult;
    fn TransitionDuration(&self) -> DOMString;
    fn SetTransitionDuration(&self, value: DOMString) -> ErrorResult;
    fn Transition_duration(&self) -> DOMString;
    fn SetTransition_duration(&self, value: DOMString) -> ErrorResult;
    fn TransitionTimingFunction(&self) -> DOMString;
    fn SetTransitionTimingFunction(&self, value: DOMString) -> ErrorResult;
    fn Transition_timing_function(&self) -> DOMString;
    fn SetTransition_timing_function(&self, value: DOMString) -> ErrorResult;
    fn TransitionProperty(&self) -> DOMString;
    fn SetTransitionProperty(&self, value: DOMString) -> ErrorResult;
    fn Transition_property(&self) -> DOMString;
    fn SetTransition_property(&self, value: DOMString) -> ErrorResult;
    fn TransitionDelay(&self) -> DOMString;
    fn SetTransitionDelay(&self, value: DOMString) -> ErrorResult;
    fn Transition_delay(&self) -> DOMString;
    fn SetTransition_delay(&self, value: DOMString) -> ErrorResult;
    fn Flex(&self) -> DOMString;
    fn SetFlex(&self, value: DOMString) -> ErrorResult;
    fn FlexFlow(&self) -> DOMString;
    fn SetFlexFlow(&self, value: DOMString) -> ErrorResult;
    fn Flex_flow(&self) -> DOMString;
    fn SetFlex_flow(&self, value: DOMString) -> ErrorResult;
    fn FlexDirection(&self) -> DOMString;
    fn SetFlexDirection(&self, value: DOMString) -> ErrorResult;
    fn Flex_direction(&self) -> DOMString;
    fn SetFlex_direction(&self, value: DOMString) -> ErrorResult;
    fn FlexWrap(&self) -> DOMString;
    fn SetFlexWrap(&self, value: DOMString) -> ErrorResult;
    fn Flex_wrap(&self) -> DOMString;
    fn SetFlex_wrap(&self, value: DOMString) -> ErrorResult;
    fn JustifyContent(&self) -> DOMString;
    fn SetJustifyContent(&self, value: DOMString) -> ErrorResult;
    fn Justify_content(&self) -> DOMString;
    fn SetJustify_content(&self, value: DOMString) -> ErrorResult;
    fn AlignItems(&self) -> DOMString;
    fn SetAlignItems(&self, value: DOMString) -> ErrorResult;
    fn Align_items(&self) -> DOMString;
    fn SetAlign_items(&self, value: DOMString) -> ErrorResult;
    fn AlignContent(&self) -> DOMString;
    fn SetAlignContent(&self, value: DOMString) -> ErrorResult;
    fn Align_content(&self) -> DOMString;
    fn SetAlign_content(&self, value: DOMString) -> ErrorResult;
    fn Order(&self) -> DOMString;
    fn SetOrder(&self, value: DOMString) -> ErrorResult;
    fn FlexBasis(&self) -> DOMString;
    fn SetFlexBasis(&self, value: DOMString) -> ErrorResult;
    fn Flex_basis(&self) -> DOMString;
    fn SetFlex_basis(&self, value: DOMString) -> ErrorResult;
    fn FlexGrow(&self) -> DOMString;
    fn SetFlexGrow(&self, value: DOMString) -> ErrorResult;
    fn Flex_grow(&self) -> DOMString;
    fn SetFlex_grow(&self, value: DOMString) -> ErrorResult;
    fn FlexShrink(&self) -> DOMString;
    fn SetFlexShrink(&self, value: DOMString) -> ErrorResult;
    fn Flex_shrink(&self) -> DOMString;
    fn SetFlex_shrink(&self, value: DOMString) -> ErrorResult;
    fn AlignSelf(&self) -> DOMString;
    fn SetAlignSelf(&self, value: DOMString) -> ErrorResult;
    fn Align_self(&self) -> DOMString;
    fn SetAlign_self(&self, value: DOMString) -> ErrorResult;
    fn Animation(&self) -> DOMString;
    fn SetAnimation(&self, value: DOMString) -> ErrorResult;
    fn Animation_name(&self) -> DOMString;
    fn SetAnimation_name(&self, value: DOMString) -> ErrorResult;
    fn AnimationName(&self) -> DOMString;
    fn SetAnimationName(&self, value: DOMString) -> ErrorResult;
    fn Animation_duration(&self) -> DOMString;
    fn SetAnimation_duration(&self, value: DOMString) -> ErrorResult;
    fn AnimationDuration(&self) -> DOMString;
    fn SetAnimationDuration(&self, value: DOMString) -> ErrorResult;
    fn Animation_timing_function(&self) -> DOMString;
    fn SetAnimation_timing_function(&self, value: DOMString) -> ErrorResult;
    fn AnimationTimingFunction(&self) -> DOMString;
    fn SetAnimationTimingFunction(&self, value: DOMString) -> ErrorResult;
    fn Animation_iteration_count(&self) -> DOMString;
    fn SetAnimation_iteration_count(&self, value: DOMString) -> ErrorResult;
    fn AnimationIterationCount(&self) -> DOMString;
    fn SetAnimationIterationCount(&self, value: DOMString) -> ErrorResult;
    fn Animation_direction(&self) -> DOMString;
    fn SetAnimation_direction(&self, value: DOMString) -> ErrorResult;
    fn AnimationDirection(&self) -> DOMString;
    fn SetAnimationDirection(&self, value: DOMString) -> ErrorResult;
    fn Animation_play_state(&self) -> DOMString;
    fn SetAnimation_play_state(&self, value: DOMString) -> ErrorResult;
    fn AnimationPlayState(&self) -> DOMString;
    fn SetAnimationPlayState(&self, value: DOMString) -> ErrorResult;
    fn Animation_fill_mode(&self) -> DOMString;
    fn SetAnimation_fill_mode(&self, value: DOMString) -> ErrorResult;
    fn AnimationFillMode(&self) -> DOMString;
    fn SetAnimationFillMode(&self, value: DOMString) -> ErrorResult;
    fn Animation_delay(&self) -> DOMString;
    fn SetAnimation_delay(&self, value: DOMString) -> ErrorResult;
    fn AnimationDelay(&self) -> DOMString;
    fn SetAnimationDelay(&self, value: DOMString) -> ErrorResult;
    fn IndexedGetter(&self, index: u32) -> Option<DOMString>;
}
const sMethods_specs: &'static [&'static[JSFunctionSpec]] = &[
&[
    JSFunctionSpec {
        name: b"item\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &item_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getPropertyValue\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getPropertyValue_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getPropertyPriority\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getPropertyPriority_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"setProperty\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &setProperty_methodinfo as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"setPropertyValue\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &setPropertyValue_methodinfo as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"setPropertyPriority\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &setPropertyPriority_methodinfo as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"removeProperty\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &removeProperty_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: (SymbolCode::iterator as i32 + 1) as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: b"ArrayValues\0" as *const u8 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]

];
const sMethods: &'static [Guard<&'static [JSFunctionSpec]>] = &[
    Guard::new(Condition::Satisfied, sMethods_specs[0])
];
const sAttributes_specs: &'static [&'static[JSPropertySpec]] = &[
&[
    JSPropertySpec {
        name: b"cssText\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &cssText_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &cssText_setterinfo }
    },
    JSPropertySpec {
        name: b"length\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &length_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"cssFloat\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &cssFloat_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &cssFloat_setterinfo }
    },
    JSPropertySpec {
        name: b"all\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &all_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &all_setterinfo }
    },
    JSPropertySpec {
        name: b"background\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &background_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &background_setterinfo }
    },
    JSPropertySpec {
        name: b"backgroundColor\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &backgroundColor_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &backgroundColor_setterinfo }
    },
    JSPropertySpec {
        name: b"background-color\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &background_color_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &background_color_setterinfo }
    },
    JSPropertySpec {
        name: b"backgroundPosition\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &backgroundPosition_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &backgroundPosition_setterinfo }
    },
    JSPropertySpec {
        name: b"background-position\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &background_position_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &background_position_setterinfo }
    },
    JSPropertySpec {
        name: b"backgroundPositionX\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &backgroundPositionX_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &backgroundPositionX_setterinfo }
    },
    JSPropertySpec {
        name: b"background-position-x\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &background_position_x_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &background_position_x_setterinfo }
    },
    JSPropertySpec {
        name: b"backgroundPositionY\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &backgroundPositionY_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &backgroundPositionY_setterinfo }
    },
    JSPropertySpec {
        name: b"background-position-y\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &background_position_y_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &background_position_y_setterinfo }
    },
    JSPropertySpec {
        name: b"backgroundRepeat\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &backgroundRepeat_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &backgroundRepeat_setterinfo }
    },
    JSPropertySpec {
        name: b"background-repeat\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &background_repeat_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &background_repeat_setterinfo }
    },
    JSPropertySpec {
        name: b"backgroundImage\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &backgroundImage_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &backgroundImage_setterinfo }
    },
    JSPropertySpec {
        name: b"background-image\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &background_image_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &background_image_setterinfo }
    },
    JSPropertySpec {
        name: b"backgroundAttachment\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &backgroundAttachment_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &backgroundAttachment_setterinfo }
    },
    JSPropertySpec {
        name: b"background-attachment\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &background_attachment_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &background_attachment_setterinfo }
    },
    JSPropertySpec {
        name: b"backgroundSize\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &backgroundSize_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &backgroundSize_setterinfo }
    },
    JSPropertySpec {
        name: b"background-size\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &background_size_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &background_size_setterinfo }
    },
    JSPropertySpec {
        name: b"backgroundOrigin\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &backgroundOrigin_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &backgroundOrigin_setterinfo }
    },
    JSPropertySpec {
        name: b"background-origin\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &background_origin_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &background_origin_setterinfo }
    },
    JSPropertySpec {
        name: b"backgroundClip\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &backgroundClip_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &backgroundClip_setterinfo }
    },
    JSPropertySpec {
        name: b"background-clip\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &background_clip_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &background_clip_setterinfo }
    },
    JSPropertySpec {
        name: b"border\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_setterinfo }
    },
    JSPropertySpec {
        name: b"borderColor\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderColor_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderColor_setterinfo }
    },
    JSPropertySpec {
        name: b"border-color\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_color_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_color_setterinfo }
    },
    JSPropertySpec {
        name: b"borderRadius\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderRadius_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderRadius_setterinfo }
    },
    JSPropertySpec {
        name: b"border-radius\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_radius_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_radius_setterinfo }
    },
    JSPropertySpec {
        name: b"borderSpacing\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderSpacing_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderSpacing_setterinfo }
    },
    JSPropertySpec {
        name: b"border-spacing\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_spacing_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_spacing_setterinfo }
    },
    JSPropertySpec {
        name: b"borderStyle\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderStyle_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderStyle_setterinfo }
    },
    JSPropertySpec {
        name: b"border-style\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_style_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_style_setterinfo }
    },
    JSPropertySpec {
        name: b"borderWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderWidth_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderWidth_setterinfo }
    },
    JSPropertySpec {
        name: b"border-width\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_width_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_width_setterinfo }
    },
    JSPropertySpec {
        name: b"borderBottom\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderBottom_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderBottom_setterinfo }
    },
    JSPropertySpec {
        name: b"border-bottom\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_bottom_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_bottom_setterinfo }
    },
    JSPropertySpec {
        name: b"borderBottomColor\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderBottomColor_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderBottomColor_setterinfo }
    },
    JSPropertySpec {
        name: b"border-bottom-color\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_bottom_color_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_bottom_color_setterinfo }
    },
    JSPropertySpec {
        name: b"borderBottomLeftRadius\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderBottomLeftRadius_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderBottomLeftRadius_setterinfo }
    },
    JSPropertySpec {
        name: b"border-bottom-left-radius\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_bottom_left_radius_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_bottom_left_radius_setterinfo }
    },
    JSPropertySpec {
        name: b"borderBottomRightRadius\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderBottomRightRadius_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderBottomRightRadius_setterinfo }
    },
    JSPropertySpec {
        name: b"border-bottom-right-radius\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_bottom_right_radius_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_bottom_right_radius_setterinfo }
    },
    JSPropertySpec {
        name: b"borderBottomStyle\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderBottomStyle_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderBottomStyle_setterinfo }
    },
    JSPropertySpec {
        name: b"border-bottom-style\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_bottom_style_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_bottom_style_setterinfo }
    },
    JSPropertySpec {
        name: b"borderBottomWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderBottomWidth_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderBottomWidth_setterinfo }
    },
    JSPropertySpec {
        name: b"border-bottom-width\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_bottom_width_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_bottom_width_setterinfo }
    },
    JSPropertySpec {
        name: b"borderLeft\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderLeft_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderLeft_setterinfo }
    },
    JSPropertySpec {
        name: b"border-left\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_left_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_left_setterinfo }
    },
    JSPropertySpec {
        name: b"borderLeftColor\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderLeftColor_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderLeftColor_setterinfo }
    },
    JSPropertySpec {
        name: b"border-left-color\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_left_color_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_left_color_setterinfo }
    },
    JSPropertySpec {
        name: b"borderLeftStyle\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderLeftStyle_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderLeftStyle_setterinfo }
    },
    JSPropertySpec {
        name: b"border-left-style\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_left_style_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_left_style_setterinfo }
    },
    JSPropertySpec {
        name: b"borderLeftWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderLeftWidth_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderLeftWidth_setterinfo }
    },
    JSPropertySpec {
        name: b"border-left-width\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_left_width_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_left_width_setterinfo }
    },
    JSPropertySpec {
        name: b"borderRight\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderRight_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderRight_setterinfo }
    },
    JSPropertySpec {
        name: b"border-right\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_right_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_right_setterinfo }
    },
    JSPropertySpec {
        name: b"borderRightColor\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderRightColor_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderRightColor_setterinfo }
    },
    JSPropertySpec {
        name: b"border-right-color\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_right_color_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_right_color_setterinfo }
    },
    JSPropertySpec {
        name: b"borderRightStyle\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderRightStyle_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderRightStyle_setterinfo }
    },
    JSPropertySpec {
        name: b"border-right-style\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_right_style_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_right_style_setterinfo }
    },
    JSPropertySpec {
        name: b"borderRightWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderRightWidth_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderRightWidth_setterinfo }
    },
    JSPropertySpec {
        name: b"border-right-width\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_right_width_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_right_width_setterinfo }
    },
    JSPropertySpec {
        name: b"borderTop\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderTop_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderTop_setterinfo }
    },
    JSPropertySpec {
        name: b"border-top\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_top_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_top_setterinfo }
    },
    JSPropertySpec {
        name: b"borderTopColor\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderTopColor_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderTopColor_setterinfo }
    },
    JSPropertySpec {
        name: b"border-top-color\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_top_color_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_top_color_setterinfo }
    },
    JSPropertySpec {
        name: b"borderTopLeftRadius\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderTopLeftRadius_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderTopLeftRadius_setterinfo }
    },
    JSPropertySpec {
        name: b"border-top-left-radius\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_top_left_radius_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_top_left_radius_setterinfo }
    },
    JSPropertySpec {
        name: b"borderTopRightRadius\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderTopRightRadius_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderTopRightRadius_setterinfo }
    },
    JSPropertySpec {
        name: b"border-top-right-radius\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_top_right_radius_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_top_right_radius_setterinfo }
    },
    JSPropertySpec {
        name: b"borderTopStyle\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderTopStyle_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderTopStyle_setterinfo }
    },
    JSPropertySpec {
        name: b"border-top-style\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_top_style_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_top_style_setterinfo }
    },
    JSPropertySpec {
        name: b"borderTopWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderTopWidth_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderTopWidth_setterinfo }
    },
    JSPropertySpec {
        name: b"border-top-width\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_top_width_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_top_width_setterinfo }
    },
    JSPropertySpec {
        name: b"border-image-source\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_image_source_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_image_source_setterinfo }
    },
    JSPropertySpec {
        name: b"borderImageSource\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderImageSource_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderImageSource_setterinfo }
    },
    JSPropertySpec {
        name: b"border-image-slice\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_image_slice_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_image_slice_setterinfo }
    },
    JSPropertySpec {
        name: b"borderImageSlice\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderImageSlice_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderImageSlice_setterinfo }
    },
    JSPropertySpec {
        name: b"border-image-repeat\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_image_repeat_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_image_repeat_setterinfo }
    },
    JSPropertySpec {
        name: b"borderImageRepeat\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderImageRepeat_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderImageRepeat_setterinfo }
    },
    JSPropertySpec {
        name: b"border-image-outset\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_image_outset_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_image_outset_setterinfo }
    },
    JSPropertySpec {
        name: b"borderImageOutset\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderImageOutset_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderImageOutset_setterinfo }
    },
    JSPropertySpec {
        name: b"border-image-width\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_image_width_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_image_width_setterinfo }
    },
    JSPropertySpec {
        name: b"borderImageWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderImageWidth_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderImageWidth_setterinfo }
    },
    JSPropertySpec {
        name: b"border-image\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_image_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_image_setterinfo }
    },
    JSPropertySpec {
        name: b"borderImage\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderImage_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderImage_setterinfo }
    },
    JSPropertySpec {
        name: b"border-block-start-color\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_block_start_color_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_block_start_color_setterinfo }
    },
    JSPropertySpec {
        name: b"borderBlockStartColor\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderBlockStartColor_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderBlockStartColor_setterinfo }
    },
    JSPropertySpec {
        name: b"border-block-start-width\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_block_start_width_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_block_start_width_setterinfo }
    },
    JSPropertySpec {
        name: b"borderBlockStartWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderBlockStartWidth_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderBlockStartWidth_setterinfo }
    },
    JSPropertySpec {
        name: b"border-block-start-style\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_block_start_style_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_block_start_style_setterinfo }
    },
    JSPropertySpec {
        name: b"borderBlockStartStyle\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderBlockStartStyle_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderBlockStartStyle_setterinfo }
    },
    JSPropertySpec {
        name: b"border-block-end-color\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_block_end_color_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_block_end_color_setterinfo }
    },
    JSPropertySpec {
        name: b"borderBlockEndColor\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderBlockEndColor_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderBlockEndColor_setterinfo }
    },
    JSPropertySpec {
        name: b"border-block-end-width\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_block_end_width_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_block_end_width_setterinfo }
    },
    JSPropertySpec {
        name: b"borderBlockEndWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderBlockEndWidth_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderBlockEndWidth_setterinfo }
    },
    JSPropertySpec {
        name: b"border-block-end-style\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_block_end_style_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_block_end_style_setterinfo }
    },
    JSPropertySpec {
        name: b"borderBlockEndStyle\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderBlockEndStyle_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderBlockEndStyle_setterinfo }
    },
    JSPropertySpec {
        name: b"border-inline-start-color\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_inline_start_color_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_inline_start_color_setterinfo }
    },
    JSPropertySpec {
        name: b"borderInlineStartColor\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderInlineStartColor_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderInlineStartColor_setterinfo }
    },
    JSPropertySpec {
        name: b"border-inline-start-width\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_inline_start_width_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_inline_start_width_setterinfo }
    },
    JSPropertySpec {
        name: b"borderInlineStartWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderInlineStartWidth_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderInlineStartWidth_setterinfo }
    },
    JSPropertySpec {
        name: b"border-inline-start-style\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_inline_start_style_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_inline_start_style_setterinfo }
    },
    JSPropertySpec {
        name: b"borderInlineStartStyle\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderInlineStartStyle_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderInlineStartStyle_setterinfo }
    },
    JSPropertySpec {
        name: b"border-inline-end-color\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_inline_end_color_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_inline_end_color_setterinfo }
    },
    JSPropertySpec {
        name: b"borderInlineEndColor\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderInlineEndColor_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderInlineEndColor_setterinfo }
    },
    JSPropertySpec {
        name: b"border-inline-end-width\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_inline_end_width_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_inline_end_width_setterinfo }
    },
    JSPropertySpec {
        name: b"borderInlineEndWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderInlineEndWidth_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderInlineEndWidth_setterinfo }
    },
    JSPropertySpec {
        name: b"border-inline-end-style\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_inline_end_style_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_inline_end_style_setterinfo }
    },
    JSPropertySpec {
        name: b"borderInlineEndStyle\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderInlineEndStyle_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderInlineEndStyle_setterinfo }
    },
    JSPropertySpec {
        name: b"border-block-start\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_block_start_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_block_start_setterinfo }
    },
    JSPropertySpec {
        name: b"borderBlockStart\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderBlockStart_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderBlockStart_setterinfo }
    },
    JSPropertySpec {
        name: b"border-block-end\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_block_end_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_block_end_setterinfo }
    },
    JSPropertySpec {
        name: b"borderBlockEnd\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderBlockEnd_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderBlockEnd_setterinfo }
    },
    JSPropertySpec {
        name: b"border-inline-start\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_inline_start_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_inline_start_setterinfo }
    },
    JSPropertySpec {
        name: b"borderInlineStart\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderInlineStart_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderInlineStart_setterinfo }
    },
    JSPropertySpec {
        name: b"border-inline-end\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_inline_end_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_inline_end_setterinfo }
    },
    JSPropertySpec {
        name: b"borderInlineEnd\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderInlineEnd_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderInlineEnd_setterinfo }
    },
    JSPropertySpec {
        name: b"content\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &content_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &content_setterinfo }
    },
    JSPropertySpec {
        name: b"color\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &color_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &color_setterinfo }
    },
    JSPropertySpec {
        name: b"display\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &display_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &display_setterinfo }
    },
    JSPropertySpec {
        name: b"opacity\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &opacity_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &opacity_setterinfo }
    },
    JSPropertySpec {
        name: b"visibility\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &visibility_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &visibility_setterinfo }
    },
    JSPropertySpec {
        name: b"cursor\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &cursor_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &cursor_setterinfo }
    },
    JSPropertySpec {
        name: b"boxSizing\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &boxSizing_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &boxSizing_setterinfo }
    },
    JSPropertySpec {
        name: b"box-sizing\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &box_sizing_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &box_sizing_setterinfo }
    },
    JSPropertySpec {
        name: b"boxShadow\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &boxShadow_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &boxShadow_setterinfo }
    },
    JSPropertySpec {
        name: b"box-shadow\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &box_shadow_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &box_shadow_setterinfo }
    },
    JSPropertySpec {
        name: b"textShadow\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &textShadow_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &textShadow_setterinfo }
    },
    JSPropertySpec {
        name: b"text-shadow\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &text_shadow_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &text_shadow_setterinfo }
    },
    JSPropertySpec {
        name: b"float\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &float_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &float_setterinfo }
    },
    JSPropertySpec {
        name: b"clear\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &clear_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &clear_setterinfo }
    },
    JSPropertySpec {
        name: b"clip\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &clip_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &clip_setterinfo }
    },
    JSPropertySpec {
        name: b"transform\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &transform_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &transform_setterinfo }
    },
    JSPropertySpec {
        name: b"transformOrigin\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &transformOrigin_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &transformOrigin_setterinfo }
    },
    JSPropertySpec {
        name: b"transform-origin\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &transform_origin_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &transform_origin_setterinfo }
    },
    JSPropertySpec {
        name: b"perspective\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &perspective_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &perspective_setterinfo }
    },
    JSPropertySpec {
        name: b"perspectiveOrigin\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &perspectiveOrigin_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &perspectiveOrigin_setterinfo }
    },
    JSPropertySpec {
        name: b"perspective-origin\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &perspective_origin_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &perspective_origin_setterinfo }
    },
    JSPropertySpec {
        name: b"transformStyle\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &transformStyle_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &transformStyle_setterinfo }
    },
    JSPropertySpec {
        name: b"transform-style\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &transform_style_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &transform_style_setterinfo }
    },
    JSPropertySpec {
        name: b"backfaceVisibility\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &backfaceVisibility_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &backfaceVisibility_setterinfo }
    },
    JSPropertySpec {
        name: b"backface-visibility\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &backface_visibility_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &backface_visibility_setterinfo }
    },
    JSPropertySpec {
        name: b"rotate\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &rotate_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &rotate_setterinfo }
    },
    JSPropertySpec {
        name: b"scale\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &scale_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &scale_setterinfo }
    },
    JSPropertySpec {
        name: b"translate\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &translate_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &translate_setterinfo }
    },
    JSPropertySpec {
        name: b"direction\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &direction_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &direction_setterinfo }
    },
    JSPropertySpec {
        name: b"unicodeBidi\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &unicodeBidi_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &unicodeBidi_setterinfo }
    },
    JSPropertySpec {
        name: b"unicode-bidi\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &unicode_bidi_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &unicode_bidi_setterinfo }
    },
    JSPropertySpec {
        name: b"filter\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &filter_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &filter_setterinfo }
    },
    JSPropertySpec {
        name: b"lineHeight\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &lineHeight_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &lineHeight_setterinfo }
    },
    JSPropertySpec {
        name: b"line-height\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &line_height_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &line_height_setterinfo }
    },
    JSPropertySpec {
        name: b"mixBlendMode\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &mixBlendMode_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &mixBlendMode_setterinfo }
    },
    JSPropertySpec {
        name: b"mix-blend-mode\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &mix_blend_mode_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &mix_blend_mode_setterinfo }
    },
    JSPropertySpec {
        name: b"verticalAlign\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &verticalAlign_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &verticalAlign_setterinfo }
    },
    JSPropertySpec {
        name: b"vertical-align\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &vertical_align_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &vertical_align_setterinfo }
    },
    JSPropertySpec {
        name: b"listStyle\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &listStyle_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &listStyle_setterinfo }
    },
    JSPropertySpec {
        name: b"list-style\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &list_style_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &list_style_setterinfo }
    },
    JSPropertySpec {
        name: b"listStylePosition\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &listStylePosition_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &listStylePosition_setterinfo }
    },
    JSPropertySpec {
        name: b"list-style-position\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &list_style_position_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &list_style_position_setterinfo }
    },
    JSPropertySpec {
        name: b"listStyleType\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &listStyleType_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &listStyleType_setterinfo }
    },
    JSPropertySpec {
        name: b"list-style-type\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &list_style_type_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &list_style_type_setterinfo }
    },
    JSPropertySpec {
        name: b"listStyleImage\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &listStyleImage_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &listStyleImage_setterinfo }
    },
    JSPropertySpec {
        name: b"list-style-image\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &list_style_image_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &list_style_image_setterinfo }
    },
    JSPropertySpec {
        name: b"quotes\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &quotes_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &quotes_setterinfo }
    },
    JSPropertySpec {
        name: b"counterIncrement\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &counterIncrement_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &counterIncrement_setterinfo }
    },
    JSPropertySpec {
        name: b"counter-increment\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &counter_increment_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &counter_increment_setterinfo }
    },
    JSPropertySpec {
        name: b"counterReset\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &counterReset_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &counterReset_setterinfo }
    },
    JSPropertySpec {
        name: b"counter-reset\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &counter_reset_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &counter_reset_setterinfo }
    },
    JSPropertySpec {
        name: b"overflow\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &overflow_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &overflow_setterinfo }
    },
    JSPropertySpec {
        name: b"overflowX\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &overflowX_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &overflowX_setterinfo }
    },
    JSPropertySpec {
        name: b"overflow-x\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &overflow_x_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &overflow_x_setterinfo }
    },
    JSPropertySpec {
        name: b"overflowY\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &overflowY_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &overflowY_setterinfo }
    },
    JSPropertySpec {
        name: b"overflow-y\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &overflow_y_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &overflow_y_setterinfo }
    },
    JSPropertySpec {
        name: b"overflowWrap\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &overflowWrap_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &overflowWrap_setterinfo }
    },
    JSPropertySpec {
        name: b"overflow-wrap\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &overflow_wrap_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &overflow_wrap_setterinfo }
    },
    JSPropertySpec {
        name: b"tableLayout\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &tableLayout_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &tableLayout_setterinfo }
    },
    JSPropertySpec {
        name: b"table-layout\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &table_layout_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &table_layout_setterinfo }
    },
    JSPropertySpec {
        name: b"borderCollapse\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderCollapse_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderCollapse_setterinfo }
    },
    JSPropertySpec {
        name: b"border-collapse\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_collapse_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_collapse_setterinfo }
    },
    JSPropertySpec {
        name: b"emptyCells\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &emptyCells_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &emptyCells_setterinfo }
    },
    JSPropertySpec {
        name: b"empty-cells\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &empty_cells_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &empty_cells_setterinfo }
    },
    JSPropertySpec {
        name: b"captionSide\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &captionSide_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &captionSide_setterinfo }
    },
    JSPropertySpec {
        name: b"caption-side\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &caption_side_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &caption_side_setterinfo }
    },
    JSPropertySpec {
        name: b"whiteSpace\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &whiteSpace_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &whiteSpace_setterinfo }
    },
    JSPropertySpec {
        name: b"white-space\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &white_space_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &white_space_setterinfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]
,
&[
    JSPropertySpec {
        name: b"writingMode\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &writingMode_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &writingMode_setterinfo }
    },
    JSPropertySpec {
        name: b"writing-mode\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &writing_mode_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &writing_mode_setterinfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]
,
&[
    JSPropertySpec {
        name: b"letterSpacing\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &letterSpacing_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &letterSpacing_setterinfo }
    },
    JSPropertySpec {
        name: b"letter-spacing\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &letter_spacing_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &letter_spacing_setterinfo }
    },
    JSPropertySpec {
        name: b"wordBreak\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &wordBreak_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &wordBreak_setterinfo }
    },
    JSPropertySpec {
        name: b"word-break\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &word_break_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &word_break_setterinfo }
    },
    JSPropertySpec {
        name: b"wordSpacing\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &wordSpacing_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &wordSpacing_setterinfo }
    },
    JSPropertySpec {
        name: b"word-spacing\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &word_spacing_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &word_spacing_setterinfo }
    },
    JSPropertySpec {
        name: b"wordWrap\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &wordWrap_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &wordWrap_setterinfo }
    },
    JSPropertySpec {
        name: b"word-wrap\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &word_wrap_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &word_wrap_setterinfo }
    },
    JSPropertySpec {
        name: b"textOverflow\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &textOverflow_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &textOverflow_setterinfo }
    },
    JSPropertySpec {
        name: b"text-overflow\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &text_overflow_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &text_overflow_setterinfo }
    },
    JSPropertySpec {
        name: b"textAlign\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &textAlign_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &textAlign_setterinfo }
    },
    JSPropertySpec {
        name: b"text-align\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &text_align_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &text_align_setterinfo }
    },
    JSPropertySpec {
        name: b"textDecoration\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &textDecoration_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &textDecoration_setterinfo }
    },
    JSPropertySpec {
        name: b"text-decoration\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &text_decoration_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &text_decoration_setterinfo }
    },
    JSPropertySpec {
        name: b"textDecorationLine\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &textDecorationLine_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &textDecorationLine_setterinfo }
    },
    JSPropertySpec {
        name: b"text-decoration-line\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &text_decoration_line_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &text_decoration_line_setterinfo }
    },
    JSPropertySpec {
        name: b"textIndent\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &textIndent_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &textIndent_setterinfo }
    },
    JSPropertySpec {
        name: b"text-indent\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &text_indent_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &text_indent_setterinfo }
    },
    JSPropertySpec {
        name: b"textJustify\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &textJustify_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &textJustify_setterinfo }
    },
    JSPropertySpec {
        name: b"text-justify\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &text_justify_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &text_justify_setterinfo }
    },
    JSPropertySpec {
        name: b"textRendering\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &textRendering_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &textRendering_setterinfo }
    },
    JSPropertySpec {
        name: b"text-rendering\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &text_rendering_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &text_rendering_setterinfo }
    },
    JSPropertySpec {
        name: b"textTransform\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &textTransform_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &textTransform_setterinfo }
    },
    JSPropertySpec {
        name: b"text-transform\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &text_transform_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &text_transform_setterinfo }
    },
    JSPropertySpec {
        name: b"font\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &font_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &font_setterinfo }
    },
    JSPropertySpec {
        name: b"fontFamily\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &fontFamily_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &fontFamily_setterinfo }
    },
    JSPropertySpec {
        name: b"font-family\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &font_family_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &font_family_setterinfo }
    },
    JSPropertySpec {
        name: b"fontSize\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &fontSize_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &fontSize_setterinfo }
    },
    JSPropertySpec {
        name: b"font-size\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &font_size_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &font_size_setterinfo }
    },
    JSPropertySpec {
        name: b"fontStretch\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &fontStretch_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &fontStretch_setterinfo }
    },
    JSPropertySpec {
        name: b"font-stretch\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &font_stretch_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &font_stretch_setterinfo }
    },
    JSPropertySpec {
        name: b"fontStyle\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &fontStyle_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &fontStyle_setterinfo }
    },
    JSPropertySpec {
        name: b"font-style\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &font_style_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &font_style_setterinfo }
    },
    JSPropertySpec {
        name: b"fontVariant\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &fontVariant_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &fontVariant_setterinfo }
    },
    JSPropertySpec {
        name: b"font-variant\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &font_variant_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &font_variant_setterinfo }
    },
    JSPropertySpec {
        name: b"fontVariantCaps\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &fontVariantCaps_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &fontVariantCaps_setterinfo }
    },
    JSPropertySpec {
        name: b"font-variant-caps\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &font_variant_caps_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &font_variant_caps_setterinfo }
    },
    JSPropertySpec {
        name: b"fontWeight\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &fontWeight_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &fontWeight_setterinfo }
    },
    JSPropertySpec {
        name: b"font-weight\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &font_weight_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &font_weight_setterinfo }
    },
    JSPropertySpec {
        name: b"margin\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &margin_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &margin_setterinfo }
    },
    JSPropertySpec {
        name: b"marginBottom\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &marginBottom_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &marginBottom_setterinfo }
    },
    JSPropertySpec {
        name: b"margin-bottom\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &margin_bottom_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &margin_bottom_setterinfo }
    },
    JSPropertySpec {
        name: b"marginLeft\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &marginLeft_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &marginLeft_setterinfo }
    },
    JSPropertySpec {
        name: b"margin-left\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &margin_left_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &margin_left_setterinfo }
    },
    JSPropertySpec {
        name: b"marginRight\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &marginRight_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &marginRight_setterinfo }
    },
    JSPropertySpec {
        name: b"margin-right\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &margin_right_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &margin_right_setterinfo }
    },
    JSPropertySpec {
        name: b"marginTop\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &marginTop_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &marginTop_setterinfo }
    },
    JSPropertySpec {
        name: b"margin-top\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &margin_top_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &margin_top_setterinfo }
    },
    JSPropertySpec {
        name: b"margin-block-start\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &margin_block_start_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &margin_block_start_setterinfo }
    },
    JSPropertySpec {
        name: b"marginBlockStart\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &marginBlockStart_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &marginBlockStart_setterinfo }
    },
    JSPropertySpec {
        name: b"margin-block-end\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &margin_block_end_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &margin_block_end_setterinfo }
    },
    JSPropertySpec {
        name: b"marginBlockEnd\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &marginBlockEnd_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &marginBlockEnd_setterinfo }
    },
    JSPropertySpec {
        name: b"margin-inline-start\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &margin_inline_start_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &margin_inline_start_setterinfo }
    },
    JSPropertySpec {
        name: b"marginInlineStart\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &marginInlineStart_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &marginInlineStart_setterinfo }
    },
    JSPropertySpec {
        name: b"margin-inline-end\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &margin_inline_end_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &margin_inline_end_setterinfo }
    },
    JSPropertySpec {
        name: b"marginInlineEnd\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &marginInlineEnd_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &marginInlineEnd_setterinfo }
    },
    JSPropertySpec {
        name: b"padding\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &padding_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &padding_setterinfo }
    },
    JSPropertySpec {
        name: b"paddingBottom\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &paddingBottom_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &paddingBottom_setterinfo }
    },
    JSPropertySpec {
        name: b"padding-bottom\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &padding_bottom_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &padding_bottom_setterinfo }
    },
    JSPropertySpec {
        name: b"paddingLeft\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &paddingLeft_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &paddingLeft_setterinfo }
    },
    JSPropertySpec {
        name: b"padding-left\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &padding_left_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &padding_left_setterinfo }
    },
    JSPropertySpec {
        name: b"paddingRight\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &paddingRight_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &paddingRight_setterinfo }
    },
    JSPropertySpec {
        name: b"padding-right\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &padding_right_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &padding_right_setterinfo }
    },
    JSPropertySpec {
        name: b"paddingTop\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &paddingTop_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &paddingTop_setterinfo }
    },
    JSPropertySpec {
        name: b"padding-top\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &padding_top_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &padding_top_setterinfo }
    },
    JSPropertySpec {
        name: b"padding-block-start\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &padding_block_start_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &padding_block_start_setterinfo }
    },
    JSPropertySpec {
        name: b"paddingBlockStart\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &paddingBlockStart_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &paddingBlockStart_setterinfo }
    },
    JSPropertySpec {
        name: b"padding-block-end\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &padding_block_end_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &padding_block_end_setterinfo }
    },
    JSPropertySpec {
        name: b"paddingBlockEnd\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &paddingBlockEnd_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &paddingBlockEnd_setterinfo }
    },
    JSPropertySpec {
        name: b"padding-inline-start\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &padding_inline_start_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &padding_inline_start_setterinfo }
    },
    JSPropertySpec {
        name: b"paddingInlineStart\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &paddingInlineStart_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &paddingInlineStart_setterinfo }
    },
    JSPropertySpec {
        name: b"padding-inline-end\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &padding_inline_end_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &padding_inline_end_setterinfo }
    },
    JSPropertySpec {
        name: b"paddingInlineEnd\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &paddingInlineEnd_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &paddingInlineEnd_setterinfo }
    },
    JSPropertySpec {
        name: b"outline\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &outline_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &outline_setterinfo }
    },
    JSPropertySpec {
        name: b"outlineColor\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &outlineColor_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &outlineColor_setterinfo }
    },
    JSPropertySpec {
        name: b"outline-color\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &outline_color_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &outline_color_setterinfo }
    },
    JSPropertySpec {
        name: b"outlineStyle\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &outlineStyle_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &outlineStyle_setterinfo }
    },
    JSPropertySpec {
        name: b"outline-style\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &outline_style_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &outline_style_setterinfo }
    },
    JSPropertySpec {
        name: b"outlineWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &outlineWidth_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &outlineWidth_setterinfo }
    },
    JSPropertySpec {
        name: b"outline-width\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &outline_width_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &outline_width_setterinfo }
    },
    JSPropertySpec {
        name: b"outlineOffset\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &outlineOffset_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &outlineOffset_setterinfo }
    },
    JSPropertySpec {
        name: b"outline-offset\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &outline_offset_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &outline_offset_setterinfo }
    },
    JSPropertySpec {
        name: b"position\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &position_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &position_setterinfo }
    },
    JSPropertySpec {
        name: b"pointerEvents\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &pointerEvents_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &pointerEvents_setterinfo }
    },
    JSPropertySpec {
        name: b"pointer-events\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &pointer_events_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &pointer_events_setterinfo }
    },
    JSPropertySpec {
        name: b"top\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &top_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &top_setterinfo }
    },
    JSPropertySpec {
        name: b"right\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &right_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &right_setterinfo }
    },
    JSPropertySpec {
        name: b"left\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &left_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &left_setterinfo }
    },
    JSPropertySpec {
        name: b"bottom\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &bottom_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &bottom_setterinfo }
    },
    JSPropertySpec {
        name: b"offset-block-start\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &offset_block_start_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &offset_block_start_setterinfo }
    },
    JSPropertySpec {
        name: b"offsetBlockStart\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &offsetBlockStart_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &offsetBlockStart_setterinfo }
    },
    JSPropertySpec {
        name: b"offset-block-end\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &offset_block_end_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &offset_block_end_setterinfo }
    },
    JSPropertySpec {
        name: b"offsetBlockEnd\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &offsetBlockEnd_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &offsetBlockEnd_setterinfo }
    },
    JSPropertySpec {
        name: b"offset-inline-start\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &offset_inline_start_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &offset_inline_start_setterinfo }
    },
    JSPropertySpec {
        name: b"offsetInlineStart\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &offsetInlineStart_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &offsetInlineStart_setterinfo }
    },
    JSPropertySpec {
        name: b"offset-inline-end\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &offset_inline_end_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &offset_inline_end_setterinfo }
    },
    JSPropertySpec {
        name: b"offsetInlineEnd\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &offsetInlineEnd_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &offsetInlineEnd_setterinfo }
    },
    JSPropertySpec {
        name: b"height\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &height_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &height_setterinfo }
    },
    JSPropertySpec {
        name: b"minHeight\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &minHeight_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &minHeight_setterinfo }
    },
    JSPropertySpec {
        name: b"min-height\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &min_height_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &min_height_setterinfo }
    },
    JSPropertySpec {
        name: b"maxHeight\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &maxHeight_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &maxHeight_setterinfo }
    },
    JSPropertySpec {
        name: b"max-height\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &max_height_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &max_height_setterinfo }
    },
    JSPropertySpec {
        name: b"width\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &width_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &width_setterinfo }
    },
    JSPropertySpec {
        name: b"minWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &minWidth_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &minWidth_setterinfo }
    },
    JSPropertySpec {
        name: b"min-width\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &min_width_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &min_width_setterinfo }
    },
    JSPropertySpec {
        name: b"maxWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &maxWidth_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &maxWidth_setterinfo }
    },
    JSPropertySpec {
        name: b"max-width\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &max_width_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &max_width_setterinfo }
    },
    JSPropertySpec {
        name: b"block-size\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &block_size_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &block_size_setterinfo }
    },
    JSPropertySpec {
        name: b"blockSize\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &blockSize_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &blockSize_setterinfo }
    },
    JSPropertySpec {
        name: b"inline-size\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &inline_size_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &inline_size_setterinfo }
    },
    JSPropertySpec {
        name: b"inlineSize\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &inlineSize_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &inlineSize_setterinfo }
    },
    JSPropertySpec {
        name: b"max-block-size\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &max_block_size_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &max_block_size_setterinfo }
    },
    JSPropertySpec {
        name: b"maxBlockSize\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &maxBlockSize_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &maxBlockSize_setterinfo }
    },
    JSPropertySpec {
        name: b"max-inline-size\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &max_inline_size_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &max_inline_size_setterinfo }
    },
    JSPropertySpec {
        name: b"maxInlineSize\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &maxInlineSize_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &maxInlineSize_setterinfo }
    },
    JSPropertySpec {
        name: b"min-block-size\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &min_block_size_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &min_block_size_setterinfo }
    },
    JSPropertySpec {
        name: b"minBlockSize\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &minBlockSize_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &minBlockSize_setterinfo }
    },
    JSPropertySpec {
        name: b"min-inline-size\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &min_inline_size_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &min_inline_size_setterinfo }
    },
    JSPropertySpec {
        name: b"minInlineSize\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &minInlineSize_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &minInlineSize_setterinfo }
    },
    JSPropertySpec {
        name: b"zIndex\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &zIndex_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &zIndex_setterinfo }
    },
    JSPropertySpec {
        name: b"z-index\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &z_index_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &z_index_setterinfo }
    },
    JSPropertySpec {
        name: b"imageRendering\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &imageRendering_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &imageRendering_setterinfo }
    },
    JSPropertySpec {
        name: b"image-rendering\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &image_rendering_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &image_rendering_setterinfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]
,
&[
    JSPropertySpec {
        name: b"columnCount\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &columnCount_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &columnCount_setterinfo }
    },
    JSPropertySpec {
        name: b"column-count\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &column_count_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &column_count_setterinfo }
    },
    JSPropertySpec {
        name: b"columnWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &columnWidth_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &columnWidth_setterinfo }
    },
    JSPropertySpec {
        name: b"column-width\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &column_width_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &column_width_setterinfo }
    },
    JSPropertySpec {
        name: b"columns\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &columns_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &columns_setterinfo }
    },
    JSPropertySpec {
        name: b"columnGap\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &columnGap_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &columnGap_setterinfo }
    },
    JSPropertySpec {
        name: b"column-gap\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &column_gap_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &column_gap_setterinfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]
,
&[
    JSPropertySpec {
        name: b"transition\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &transition_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &transition_setterinfo }
    },
    JSPropertySpec {
        name: b"transitionDuration\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &transitionDuration_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &transitionDuration_setterinfo }
    },
    JSPropertySpec {
        name: b"transition-duration\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &transition_duration_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &transition_duration_setterinfo }
    },
    JSPropertySpec {
        name: b"transitionTimingFunction\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &transitionTimingFunction_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &transitionTimingFunction_setterinfo }
    },
    JSPropertySpec {
        name: b"transition-timing-function\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &transition_timing_function_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &transition_timing_function_setterinfo }
    },
    JSPropertySpec {
        name: b"transitionProperty\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &transitionProperty_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &transitionProperty_setterinfo }
    },
    JSPropertySpec {
        name: b"transition-property\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &transition_property_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &transition_property_setterinfo }
    },
    JSPropertySpec {
        name: b"transitionDelay\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &transitionDelay_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &transitionDelay_setterinfo }
    },
    JSPropertySpec {
        name: b"transition-delay\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &transition_delay_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &transition_delay_setterinfo }
    },
    JSPropertySpec {
        name: b"flex\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &flex_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &flex_setterinfo }
    },
    JSPropertySpec {
        name: b"flexFlow\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &flexFlow_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &flexFlow_setterinfo }
    },
    JSPropertySpec {
        name: b"flex-flow\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &flex_flow_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &flex_flow_setterinfo }
    },
    JSPropertySpec {
        name: b"flexDirection\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &flexDirection_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &flexDirection_setterinfo }
    },
    JSPropertySpec {
        name: b"flex-direction\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &flex_direction_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &flex_direction_setterinfo }
    },
    JSPropertySpec {
        name: b"flexWrap\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &flexWrap_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &flexWrap_setterinfo }
    },
    JSPropertySpec {
        name: b"flex-wrap\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &flex_wrap_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &flex_wrap_setterinfo }
    },
    JSPropertySpec {
        name: b"justifyContent\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &justifyContent_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &justifyContent_setterinfo }
    },
    JSPropertySpec {
        name: b"justify-content\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &justify_content_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &justify_content_setterinfo }
    },
    JSPropertySpec {
        name: b"alignItems\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &alignItems_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &alignItems_setterinfo }
    },
    JSPropertySpec {
        name: b"align-items\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &align_items_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &align_items_setterinfo }
    },
    JSPropertySpec {
        name: b"alignContent\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &alignContent_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &alignContent_setterinfo }
    },
    JSPropertySpec {
        name: b"align-content\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &align_content_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &align_content_setterinfo }
    },
    JSPropertySpec {
        name: b"order\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &order_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &order_setterinfo }
    },
    JSPropertySpec {
        name: b"flexBasis\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &flexBasis_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &flexBasis_setterinfo }
    },
    JSPropertySpec {
        name: b"flex-basis\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &flex_basis_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &flex_basis_setterinfo }
    },
    JSPropertySpec {
        name: b"flexGrow\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &flexGrow_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &flexGrow_setterinfo }
    },
    JSPropertySpec {
        name: b"flex-grow\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &flex_grow_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &flex_grow_setterinfo }
    },
    JSPropertySpec {
        name: b"flexShrink\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &flexShrink_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &flexShrink_setterinfo }
    },
    JSPropertySpec {
        name: b"flex-shrink\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &flex_shrink_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &flex_shrink_setterinfo }
    },
    JSPropertySpec {
        name: b"alignSelf\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &alignSelf_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &alignSelf_setterinfo }
    },
    JSPropertySpec {
        name: b"align-self\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &align_self_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &align_self_setterinfo }
    },
    JSPropertySpec {
        name: b"animation\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animation_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animation_setterinfo }
    },
    JSPropertySpec {
        name: b"animation-name\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animation_name_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animation_name_setterinfo }
    },
    JSPropertySpec {
        name: b"animationName\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animationName_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animationName_setterinfo }
    },
    JSPropertySpec {
        name: b"animation-duration\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animation_duration_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animation_duration_setterinfo }
    },
    JSPropertySpec {
        name: b"animationDuration\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animationDuration_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animationDuration_setterinfo }
    },
    JSPropertySpec {
        name: b"animation-timing-function\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animation_timing_function_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animation_timing_function_setterinfo }
    },
    JSPropertySpec {
        name: b"animationTimingFunction\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animationTimingFunction_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animationTimingFunction_setterinfo }
    },
    JSPropertySpec {
        name: b"animation-iteration-count\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animation_iteration_count_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animation_iteration_count_setterinfo }
    },
    JSPropertySpec {
        name: b"animationIterationCount\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animationIterationCount_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animationIterationCount_setterinfo }
    },
    JSPropertySpec {
        name: b"animation-direction\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animation_direction_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animation_direction_setterinfo }
    },
    JSPropertySpec {
        name: b"animationDirection\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animationDirection_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animationDirection_setterinfo }
    },
    JSPropertySpec {
        name: b"animation-play-state\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animation_play_state_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animation_play_state_setterinfo }
    },
    JSPropertySpec {
        name: b"animationPlayState\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animationPlayState_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animationPlayState_setterinfo }
    },
    JSPropertySpec {
        name: b"animation-fill-mode\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animation_fill_mode_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animation_fill_mode_setterinfo }
    },
    JSPropertySpec {
        name: b"animationFillMode\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animationFillMode_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animationFillMode_setterinfo }
    },
    JSPropertySpec {
        name: b"animation-delay\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animation_delay_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animation_delay_setterinfo }
    },
    JSPropertySpec {
        name: b"animationDelay\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animationDelay_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animationDelay_setterinfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]

];
const sAttributes: &'static [Guard<&'static [JSPropertySpec]>] = &[
    Guard::new(Condition::Satisfied, sAttributes_specs[0]),
    Guard::new(Condition::Pref("layout.writing-mode.enabled"), sAttributes_specs[1]),
    Guard::new(Condition::Satisfied, sAttributes_specs[2]),
    Guard::new(Condition::Pref("layout.columns.enabled"), sAttributes_specs[3]),
    Guard::new(Condition::Satisfied, sAttributes_specs[4])
];

pub unsafe fn GetProtoObject<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject, mut rval: MutableHandleObject) {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    assert!(((*get_object_class(global.get())).flags & JSCLASS_DOM_GLOBAL) != 0);

    /* Check to see whether the interface objects are already installed */
    let proto_or_iface_array = get_proto_or_iface_array(global.get());
    rval.set((*proto_or_iface_array)[PrototypeList::ID::CSSStyleDeclaration as usize]);
    if !rval.get().is_null() {
        return;
    }

    CreateInterfaceObjects::<TH>(cx, global, proto_or_iface_array);
    rval.set((*proto_or_iface_array)[PrototypeList::ID::CSSStyleDeclaration as usize]);
    assert!(!rval.get().is_null());

}

static PrototypeClass: JSClass = JSClass {
    name: b"CSSStyleDeclarationPrototype\0" as *const u8 as *const libc::c_char,
    flags:
        // JSCLASS_HAS_RESERVED_SLOTS(0)
        (0 & JSCLASS_RESERVED_SLOTS_MASK) << JSCLASS_RESERVED_SLOTS_SHIFT,
    cOps: 0 as *const _,
    reserved: [0 as *mut os::raw::c_void; 3]
};

static INTERFACE_OBJECT_CLASS: NonCallbackInterfaceObjectClass =
    NonCallbackInterfaceObjectClass::new(
        &InterfaceConstructorBehavior::throw(),
        b"function CSSStyleDeclaration() {\n    [native code]\n}",
        PrototypeList::ID::CSSStyleDeclaration,
        0);

pub unsafe fn DefineDOMInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject) {
    assert!(!global.get().is_null());

    if !ConstructorEnabled::<TH>(cx, global) {
        return;
    }

    rooted!(in(cx) let mut proto = ptr::null_mut::<JSObject>());
    GetProtoObject::<TH>(cx, global, proto.handle_mut());
    assert!(!proto.is_null());
}

unsafe fn ConstructorEnabled<TH: TypeHolderTrait>
(aCx: *mut JSContext, aObj: HandleObject) -> bool {
    is_exposed_in(aObj, InterfaceObjectMap::Globals::WINDOW)
}

unsafe fn CreateInterfaceObjects<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject, cache: *mut ProtoOrIfaceArray) {
    rooted!(in(cx) let mut prototype_proto = ptr::null_mut::<JSObject>());
    prototype_proto.set(JS_GetObjectPrototype(cx, global));
    assert!(!prototype_proto.is_null());

    rooted!(in(cx) let mut prototype = ptr::null_mut::<JSObject>());
    create_interface_prototype_object(cx,
                                      prototype_proto.handle().into(),
                                      &PrototypeClass,
                                      sMethods,
                                      sAttributes,
                                      &[],
                                      &[],
                                      prototype.handle_mut().into());
    assert!(!prototype.is_null());
    assert!((*cache)[PrototypeList::ID::CSSStyleDeclaration as usize].is_null());
    (*cache)[PrototypeList::ID::CSSStyleDeclaration as usize] = prototype.get();
    <*mut JSObject>::post_barrier((*cache).as_mut_ptr().offset(PrototypeList::ID::CSSStyleDeclaration as isize),
                                  ptr::null_mut(),
                                  prototype.get());


    rooted!(in(cx) let interface_proto = JS_GetFunctionPrototype(cx, global));
    assert!(!interface_proto.is_null());

    rooted!(in(cx) let mut interface = ptr::null_mut::<JSObject>());
    create_noncallback_interface_object(cx,
                                        global.into(),
                                        interface_proto.handle(),
                                        &INTERFACE_OBJECT_CLASS,
                                        &[],
                                        &[],
                                        &[],
                                        prototype.handle(),
                                        b"CSSStyleDeclaration\0",
                                        0,
                                        interface.handle_mut());
    assert!(!interface.is_null());
}
} // mod CSSStyleDeclarationBinding


