/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */

#![allow(non_camel_case_types,non_upper_case_globals,unused_imports,unused_variables,unused_assignments,unused_mut)]
use dom;
use dom::bindings;
use dom::bindings::callback::CallSetup;
use dom::bindings::callback::CallbackContainer;
use dom::bindings::callback::CallbackFunction;
use dom::bindings::callback::CallbackInterface;
use dom::bindings::callback::CallbackObject;
use dom::bindings::callback::ExceptionHandling;
use dom::bindings::callback::wrap_call_this_object;
use dom::bindings::codegen::InterfaceObjectMap;
use dom::bindings::codegen::PrototypeList;
use dom::bindings::codegen::RegisterBindings;
use dom::bindings::codegen::UnionTypes;
use dom::bindings::constant::ConstantSpec;
use dom::bindings::constant::ConstantVal;
use dom::bindings::conversions::ConversionBehavior;
use dom::bindings::conversions::ConversionResult;
use dom::bindings::conversions::DOM_OBJECT_SLOT;
use dom::bindings::conversions::FromJSValConvertible;
use dom::bindings::conversions::IDLInterface;
use dom::bindings::conversions::StringificationBehavior;
use dom::bindings::conversions::ToJSValConvertible;
use dom::bindings::conversions::is_array_like;
use dom::bindings::conversions::jsid_to_string;
use dom::bindings::conversions::native_from_handlevalue;
use dom::bindings::conversions::native_from_object;
use dom::bindings::conversions::private_from_object;
use dom::bindings::conversions::root_from_handleobject;
use dom::bindings::conversions::root_from_handlevalue;
use dom::bindings::conversions::root_from_object;
use dom::bindings::error::Error;
use dom::bindings::error::Error::JSFailed;
use dom::bindings::error::ErrorResult;
use dom::bindings::error::Fallible;
use dom::bindings::error::throw_dom_exception;
use dom::bindings::guard::Condition;
use dom::bindings::guard::Guard;
use dom::bindings::htmlconstructor::html_constructor;
use dom::bindings::htmlconstructor::pop_current_element_queue;
use dom::bindings::htmlconstructor::push_new_element_queue;
use dom::bindings::inheritance::Castable;
use dom::bindings::interface::ConstructorClassHook;
use dom::bindings::interface::InterfaceConstructorBehavior;
use dom::bindings::interface::NonCallbackInterfaceObjectClass;
use dom::bindings::interface::create_callback_interface_object;
use dom::bindings::interface::create_global_object;
use dom::bindings::interface::create_interface_prototype_object;
use dom::bindings::interface::create_named_constructors;
use dom::bindings::interface::create_noncallback_interface_object;
use dom::bindings::interface::define_guarded_constants;
use dom::bindings::interface::define_guarded_methods;
use dom::bindings::interface::define_guarded_properties;
use dom::bindings::interface::is_exposed_in;
use dom::bindings::iterable::Iterable;
use dom::bindings::iterable::IteratorType;
use dom::bindings::mozmap::MozMap;
use dom::bindings::namespace::NamespaceObjectClass;
use dom::bindings::namespace::create_namespace_object;
use dom::bindings::num::Finite;
use dom::bindings::proxyhandler;
use dom::bindings::proxyhandler::ensure_expando_object;
use dom::bindings::proxyhandler::fill_property_descriptor;
use dom::bindings::proxyhandler::get_expando_object;
use dom::bindings::proxyhandler::get_property_descriptor;
use dom::bindings::reflector::DomObject;
use dom::bindings::reflector::MutDomObject;
use dom::bindings::root::Dom;
use dom::bindings::root::DomRoot;
use dom::bindings::root::OptionalHeapSetter;
use dom::bindings::root::RootedReference;
use dom::bindings::str::ByteString;
use dom::bindings::str::DOMString;
use dom::bindings::str::USVString;
use dom::bindings::trace::JSTraceable;
use dom::bindings::trace::RootedTraceable;
use dom::bindings::trace::RootedTraceableBox;
use dom::bindings::utils::AsVoidPtr;
use dom::bindings::utils::DOMClass;
use dom::bindings::utils::DOMJSClass;
use dom::bindings::utils::DOM_PROTO_UNFORGEABLE_HOLDER_SLOT;
use dom::bindings::utils::JSCLASS_DOM_GLOBAL;
use dom::bindings::utils::ProtoOrIfaceArray;
use dom::bindings::utils::enumerate_global;
use dom::bindings::utils::finalize_global;
use dom::bindings::utils::find_enum_value;
use dom::bindings::utils::generic_getter;
use dom::bindings::utils::generic_lenient_getter;
use dom::bindings::utils::generic_lenient_setter;
use dom::bindings::utils::generic_method;
use dom::bindings::utils::generic_setter;
use dom::bindings::utils::get_array_index_from_id;
use dom::bindings::utils::get_dictionary_property;
use dom::bindings::utils::get_property_on_prototype;
use dom::bindings::utils::get_proto_or_iface_array;
use dom::bindings::utils::has_property_on_prototype;
use dom::bindings::utils::is_platform_object;
use dom::bindings::utils::resolve_global;
use dom::bindings::utils::set_dictionary_property;
use dom::bindings::utils::trace_global;
use dom::bindings::weakref::DOM_WEAK_SLOT;
use dom::bindings::weakref::WeakBox;
use dom::bindings::weakref::WeakReferenceable;
use dom::globalscope::GlobalScope;
use dom::windowproxy::WindowProxy;
use js;
use js::JSCLASS_GLOBAL_SLOT_COUNT;
use js::JSCLASS_IS_DOMJSCLASS;
use js::JSCLASS_IS_GLOBAL;
use js::JSCLASS_RESERVED_SLOTS_MASK;
use js::JS_CALLEE;
use js::error::throw_internal_error;
use js::error::throw_type_error;
use js::glue::AppendToAutoIdVector;
use js::glue::CallJitGetterOp;
use js::glue::CallJitMethodOp;
use js::glue::CallJitSetterOp;
use js::glue::CreateProxyHandler;
use js::glue::GetProxyPrivate;
use js::glue::ProxyTraps;
use js::glue::RUST_JSID_IS_INT;
use js::glue::RUST_JSID_IS_STRING;
use js::glue::RUST_SYMBOL_TO_JSID;
use js::glue::UnwrapObject;
use js::glue::int_to_jsid;
use js::jsapi::AutoIdVector;
use js::jsapi::CallArgs;
use js::jsapi::CurrentGlobalOrNull;
use js::jsapi::FreeOp;
use js::jsapi::GetWellKnownSymbol;
use js::jsapi::Handle as RawHandle;
use js::jsapi::HandleId as RawHandleId;
use js::jsapi::HandleObject as RawHandleObject;
use js::jsapi::HandleValue as RawHandleValue;
use js::jsapi::HandleValueArray;
use js::jsapi::Heap;
use js::jsapi::INTERNED_STRING_TO_JSID;
use js::jsapi::IsCallable;
use js::jsapi::JSAutoCompartment;
use js::jsapi::JSCLASS_RESERVED_SLOTS_SHIFT;
use js::jsapi::JSClass;
use js::jsapi::JSContext;
use js::jsapi::JSFreeOp;
use js::jsapi::JSFunctionSpec;
use js::jsapi::JSITER_HIDDEN;
use js::jsapi::JSITER_OWNONLY;
use js::jsapi::JSITER_SYMBOLS;
use js::jsapi::JSJitGetterCallArgs;
use js::jsapi::JSJitInfo;
use js::jsapi::JSJitInfo_AliasSet;
use js::jsapi::JSJitInfo_ArgType;
use js::jsapi::JSJitInfo_OpType;
use js::jsapi::JSJitMethodCallArgs;
use js::jsapi::JSJitSetterCallArgs;
use js::jsapi::JSNative;
use js::jsapi::JSNativeWrapper;
use js::jsapi::JSObject;
use js::jsapi::JSPROP_ENUMERATE;
use js::jsapi::JSPROP_PERMANENT;
use js::jsapi::JSPROP_READONLY;
use js::jsapi::JSPROP_SHARED;
use js::jsapi::JSPropertySpec;
use js::jsapi::JSString;
use js::jsapi::JSTracer;
use js::jsapi::JSType;
use js::jsapi::JSTypedMethodJitInfo;
use js::jsapi::JSValueType;
use js::jsapi::JS_AtomizeAndPinString;
use js::jsapi::JS_ForwardGetPropertyTo;
use js::jsapi::JS_GetErrorPrototype;
use js::jsapi::JS_GetGlobalForObject;
use js::jsapi::JS_GetIteratorPrototype;
use js::jsapi::JS_GetPropertyById;
use js::jsapi::JS_GetPropertyDescriptorById;
use js::jsapi::JS_GetReservedSlot;
use js::jsapi::JS_HasProperty;
use js::jsapi::JS_HasPropertyById;
use js::jsapi::JS_NewObject;
use js::jsapi::JS_SetReservedSlot;
use js::jsapi::MutableHandle as RawMutableHandle;
use js::jsapi::MutableHandleObject as RawMutableHandleObject;
use js::jsapi::MutableHandleValue as RawMutableHandleValue;
use js::jsapi::ObjectOpResult;
use js::jsapi::PropertyDescriptor;
use js::jsapi::Rooted;
use js::jsapi::RootedId;
use js::jsapi::RootedObject;
use js::jsapi::RootedString;
use js::jsapi::SymbolCode;
use js::jsapi::jsid;
use js::jsval::JSVal;
use js::jsval::NullValue;
use js::jsval::ObjectOrNullValue;
use js::jsval::ObjectValue;
use js::jsval::PrivateValue;
use js::jsval::UndefinedValue;
use js::panic::maybe_resume_unwind;
use js::panic::wrap_panic;
use js::rust::CustomAutoRooterGuard;
use js::rust::GCMethods;
use js::rust::Handle;
use js::rust::HandleId;
use js::rust::HandleObject;
use js::rust::HandleValue;
use js::rust::MutableHandle;
use js::rust::MutableHandleObject;
use js::rust::MutableHandleValue;
use js::rust::define_methods;
use js::rust::define_properties;
use js::rust::get_object_class;
use js::rust::wrappers::Call;
use js::rust::wrappers::GetPropertyKeys;
use js::rust::wrappers::JS_CallFunctionValue;
use js::rust::wrappers::JS_CopyPropertiesFrom;
use js::rust::wrappers::JS_DefineProperty;
use js::rust::wrappers::JS_DefinePropertyById2;
use js::rust::wrappers::JS_GetFunctionPrototype;
use js::rust::wrappers::JS_GetObjectPrototype;
use js::rust::wrappers::JS_GetProperty;
use js::rust::wrappers::JS_InitializePropertiesFromCompatibleNativeObject;
use js::rust::wrappers::JS_NewObjectWithGivenProto;
use js::rust::wrappers::JS_NewObjectWithoutMetadata;
use js::rust::wrappers::JS_ObjectIsDate;
use js::rust::wrappers::JS_SetImmutablePrototype;
use js::rust::wrappers::JS_SetProperty;
use js::rust::wrappers::JS_SetPrototype;
use js::rust::wrappers::JS_SplicePrototype;
use js::rust::wrappers::JS_WrapObject;
use js::rust::wrappers::JS_WrapValue;
use js::rust::wrappers::NewProxyObject;
use js::typedarray;
use libc;
use malloc_size_of::MallocSizeOfOps;
use mem::malloc_size_of_including_raw_self;
use servo_config::prefs::PREFS;
use std::borrow::ToOwned;
use std::cmp;
use std::default::Default;
use std::ffi::CString;
use std::mem;
use std::num;
use std::os;
use std::os::raw::c_void;
use std::panic;
use std::ptr;
use std::ptr::NonNull;
use std::rc;
use std::rc::Rc;
use std::str;
use typeholder::TypeHolderTrait;

pub use self::CSSStyleDeclarationBinding::{Wrap, CSSStyleDeclarationMethods, GetProtoObject, DefineDOMInterface};
pub mod CSSStyleDeclarationBinding {
#![allow(non_camel_case_types,non_upper_case_globals,unused_imports,unused_variables,unused_assignments,unused_mut)]
use dom;
use dom::bindings;
use dom::bindings::callback::CallSetup;
use dom::bindings::callback::CallbackContainer;
use dom::bindings::callback::CallbackFunction;
use dom::bindings::callback::CallbackInterface;
use dom::bindings::callback::CallbackObject;
use dom::bindings::callback::ExceptionHandling;
use dom::bindings::callback::wrap_call_this_object;
use dom::bindings::codegen::InterfaceObjectMap;
use dom::bindings::codegen::PrototypeList;
use dom::bindings::codegen::RegisterBindings;
use dom::bindings::codegen::UnionTypes;
use dom::bindings::constant::ConstantSpec;
use dom::bindings::constant::ConstantVal;
use dom::bindings::conversions::ConversionBehavior;
use dom::bindings::conversions::ConversionResult;
use dom::bindings::conversions::DOM_OBJECT_SLOT;
use dom::bindings::conversions::FromJSValConvertible;
use dom::bindings::conversions::IDLInterface;
use dom::bindings::conversions::StringificationBehavior;
use dom::bindings::conversions::ToJSValConvertible;
use dom::bindings::conversions::is_array_like;
use dom::bindings::conversions::jsid_to_string;
use dom::bindings::conversions::native_from_handlevalue;
use dom::bindings::conversions::native_from_object;
use dom::bindings::conversions::private_from_object;
use dom::bindings::conversions::root_from_handleobject;
use dom::bindings::conversions::root_from_handlevalue;
use dom::bindings::conversions::root_from_object;
use dom::bindings::error::Error;
use dom::bindings::error::Error::JSFailed;
use dom::bindings::error::ErrorResult;
use dom::bindings::error::Fallible;
use dom::bindings::error::throw_dom_exception;
use dom::bindings::guard::Condition;
use dom::bindings::guard::Guard;
use dom::bindings::htmlconstructor::html_constructor;
use dom::bindings::htmlconstructor::pop_current_element_queue;
use dom::bindings::htmlconstructor::push_new_element_queue;
use dom::bindings::inheritance::Castable;
use dom::bindings::interface::ConstructorClassHook;
use dom::bindings::interface::InterfaceConstructorBehavior;
use dom::bindings::interface::NonCallbackInterfaceObjectClass;
use dom::bindings::interface::create_callback_interface_object;
use dom::bindings::interface::create_global_object;
use dom::bindings::interface::create_interface_prototype_object;
use dom::bindings::interface::create_named_constructors;
use dom::bindings::interface::create_noncallback_interface_object;
use dom::bindings::interface::define_guarded_constants;
use dom::bindings::interface::define_guarded_methods;
use dom::bindings::interface::define_guarded_properties;
use dom::bindings::interface::is_exposed_in;
use dom::bindings::iterable::Iterable;
use dom::bindings::iterable::IteratorType;
use dom::bindings::mozmap::MozMap;
use dom::bindings::namespace::NamespaceObjectClass;
use dom::bindings::namespace::create_namespace_object;
use dom::bindings::num::Finite;
use dom::bindings::proxyhandler;
use dom::bindings::proxyhandler::ensure_expando_object;
use dom::bindings::proxyhandler::fill_property_descriptor;
use dom::bindings::proxyhandler::get_expando_object;
use dom::bindings::proxyhandler::get_property_descriptor;
use dom::bindings::reflector::DomObject;
use dom::bindings::reflector::MutDomObject;
use dom::bindings::root::Dom;
use dom::bindings::root::DomRoot;
use dom::bindings::root::OptionalHeapSetter;
use dom::bindings::root::RootedReference;
use dom::bindings::str::ByteString;
use dom::bindings::str::DOMString;
use dom::bindings::str::USVString;
use dom::bindings::trace::JSTraceable;
use dom::bindings::trace::RootedTraceable;
use dom::bindings::trace::RootedTraceableBox;
use dom::bindings::utils::AsVoidPtr;
use dom::bindings::utils::DOMClass;
use dom::bindings::utils::DOMJSClass;
use dom::bindings::utils::DOM_PROTO_UNFORGEABLE_HOLDER_SLOT;
use dom::bindings::utils::JSCLASS_DOM_GLOBAL;
use dom::bindings::utils::ProtoOrIfaceArray;
use dom::bindings::utils::enumerate_global;
use dom::bindings::utils::finalize_global;
use dom::bindings::utils::find_enum_value;
use dom::bindings::utils::generic_getter;
use dom::bindings::utils::generic_lenient_getter;
use dom::bindings::utils::generic_lenient_setter;
use dom::bindings::utils::generic_method;
use dom::bindings::utils::generic_setter;
use dom::bindings::utils::get_array_index_from_id;
use dom::bindings::utils::get_dictionary_property;
use dom::bindings::utils::get_property_on_prototype;
use dom::bindings::utils::get_proto_or_iface_array;
use dom::bindings::utils::has_property_on_prototype;
use dom::bindings::utils::is_platform_object;
use dom::bindings::utils::resolve_global;
use dom::bindings::utils::set_dictionary_property;
use dom::bindings::utils::trace_global;
use dom::bindings::weakref::DOM_WEAK_SLOT;
use dom::bindings::weakref::WeakBox;
use dom::bindings::weakref::WeakReferenceable;
use dom::globalscope::GlobalScope;
use dom::types::CSSStyleDeclaration;
use dom::windowproxy::WindowProxy;
use js;
use js::JSCLASS_GLOBAL_SLOT_COUNT;
use js::JSCLASS_IS_DOMJSCLASS;
use js::JSCLASS_IS_GLOBAL;
use js::JSCLASS_RESERVED_SLOTS_MASK;
use js::JS_CALLEE;
use js::error::throw_internal_error;
use js::error::throw_type_error;
use js::glue::AppendToAutoIdVector;
use js::glue::CallJitGetterOp;
use js::glue::CallJitMethodOp;
use js::glue::CallJitSetterOp;
use js::glue::CreateProxyHandler;
use js::glue::GetProxyPrivate;
use js::glue::ProxyTraps;
use js::glue::RUST_JSID_IS_INT;
use js::glue::RUST_JSID_IS_STRING;
use js::glue::RUST_SYMBOL_TO_JSID;
use js::glue::UnwrapObject;
use js::glue::int_to_jsid;
use js::jsapi::AutoIdVector;
use js::jsapi::CallArgs;
use js::jsapi::CurrentGlobalOrNull;
use js::jsapi::FreeOp;
use js::jsapi::GetWellKnownSymbol;
use js::jsapi::Handle as RawHandle;
use js::jsapi::HandleId as RawHandleId;
use js::jsapi::HandleObject as RawHandleObject;
use js::jsapi::HandleValue as RawHandleValue;
use js::jsapi::HandleValueArray;
use js::jsapi::Heap;
use js::jsapi::INTERNED_STRING_TO_JSID;
use js::jsapi::IsCallable;
use js::jsapi::JSAutoCompartment;
use js::jsapi::JSCLASS_RESERVED_SLOTS_SHIFT;
use js::jsapi::JSClass;
use js::jsapi::JSContext;
use js::jsapi::JSFreeOp;
use js::jsapi::JSFunctionSpec;
use js::jsapi::JSITER_HIDDEN;
use js::jsapi::JSITER_OWNONLY;
use js::jsapi::JSITER_SYMBOLS;
use js::jsapi::JSJitGetterCallArgs;
use js::jsapi::JSJitInfo;
use js::jsapi::JSJitInfo_AliasSet;
use js::jsapi::JSJitInfo_ArgType;
use js::jsapi::JSJitInfo_OpType;
use js::jsapi::JSJitMethodCallArgs;
use js::jsapi::JSJitSetterCallArgs;
use js::jsapi::JSNative;
use js::jsapi::JSNativeWrapper;
use js::jsapi::JSObject;
use js::jsapi::JSPROP_ENUMERATE;
use js::jsapi::JSPROP_PERMANENT;
use js::jsapi::JSPROP_READONLY;
use js::jsapi::JSPROP_SHARED;
use js::jsapi::JSPropertySpec;
use js::jsapi::JSString;
use js::jsapi::JSTracer;
use js::jsapi::JSType;
use js::jsapi::JSTypedMethodJitInfo;
use js::jsapi::JSValueType;
use js::jsapi::JS_AtomizeAndPinString;
use js::jsapi::JS_ForwardGetPropertyTo;
use js::jsapi::JS_GetErrorPrototype;
use js::jsapi::JS_GetGlobalForObject;
use js::jsapi::JS_GetIteratorPrototype;
use js::jsapi::JS_GetPropertyById;
use js::jsapi::JS_GetPropertyDescriptorById;
use js::jsapi::JS_GetReservedSlot;
use js::jsapi::JS_HasProperty;
use js::jsapi::JS_HasPropertyById;
use js::jsapi::JS_NewObject;
use js::jsapi::JS_SetReservedSlot;
use js::jsapi::MutableHandle as RawMutableHandle;
use js::jsapi::MutableHandleObject as RawMutableHandleObject;
use js::jsapi::MutableHandleValue as RawMutableHandleValue;
use js::jsapi::ObjectOpResult;
use js::jsapi::PropertyDescriptor;
use js::jsapi::Rooted;
use js::jsapi::RootedId;
use js::jsapi::RootedObject;
use js::jsapi::RootedString;
use js::jsapi::SymbolCode;
use js::jsapi::jsid;
use js::jsval::JSVal;
use js::jsval::NullValue;
use js::jsval::ObjectOrNullValue;
use js::jsval::ObjectValue;
use js::jsval::PrivateValue;
use js::jsval::UndefinedValue;
use js::panic::maybe_resume_unwind;
use js::panic::wrap_panic;
use js::rust::CustomAutoRooterGuard;
use js::rust::GCMethods;
use js::rust::Handle;
use js::rust::HandleId;
use js::rust::HandleObject;
use js::rust::HandleValue;
use js::rust::MutableHandle;
use js::rust::MutableHandleObject;
use js::rust::MutableHandleValue;
use js::rust::define_methods;
use js::rust::define_properties;
use js::rust::get_object_class;
use js::rust::wrappers::Call;
use js::rust::wrappers::GetPropertyKeys;
use js::rust::wrappers::JS_CallFunctionValue;
use js::rust::wrappers::JS_CopyPropertiesFrom;
use js::rust::wrappers::JS_DefineProperty;
use js::rust::wrappers::JS_DefinePropertyById2;
use js::rust::wrappers::JS_GetFunctionPrototype;
use js::rust::wrappers::JS_GetObjectPrototype;
use js::rust::wrappers::JS_GetProperty;
use js::rust::wrappers::JS_InitializePropertiesFromCompatibleNativeObject;
use js::rust::wrappers::JS_NewObjectWithGivenProto;
use js::rust::wrappers::JS_NewObjectWithoutMetadata;
use js::rust::wrappers::JS_ObjectIsDate;
use js::rust::wrappers::JS_SetImmutablePrototype;
use js::rust::wrappers::JS_SetProperty;
use js::rust::wrappers::JS_SetPrototype;
use js::rust::wrappers::JS_SplicePrototype;
use js::rust::wrappers::JS_WrapObject;
use js::rust::wrappers::JS_WrapValue;
use js::rust::wrappers::NewProxyObject;
use js::typedarray;
use libc;
use malloc_size_of::MallocSizeOfOps;
use mem::malloc_size_of_including_raw_self;
use servo_config::prefs::PREFS;
use std::borrow::ToOwned;
use std::cmp;
use std::default::Default;
use std::ffi::CString;
use std::mem;
use std::num;
use std::os;
use std::os::raw::c_void;
use std::panic;
use std::ptr;
use std::ptr::NonNull;
use std::rc;
use std::rc::Rc;
use std::str;
use typeholder::TypeHolderTrait;

unsafe extern fn get_cssText<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.CssText();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_cssText<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetCssText(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn cssText_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_cssText::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn cssText_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_cssText::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_length<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: u32 = this.Length();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn length_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_length::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn item<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"CSSStyleDeclaration.item\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: DOMString = this.Item(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn item_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: item::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getPropertyValue<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"CSSStyleDeclaration.getPropertyValue\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: DOMString = this.GetPropertyValue(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn getPropertyValue_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: getPropertyValue::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getPropertyPriority<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"CSSStyleDeclaration.getPropertyPriority\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: DOMString = this.GetPropertyPriority(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn getPropertyPriority_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: getPropertyPriority::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn setProperty<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"CSSStyleDeclaration.setProperty\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let arg1: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(1), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let arg2: DOMString = if args.get(2).is_undefined() {
            DOMString::from("")
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(2), StringificationBehavior::Empty) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetProperty(arg0, arg1, arg2);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn setProperty_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: setProperty::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn setPropertyValue<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"CSSStyleDeclaration.setPropertyValue\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let arg1: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(1), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetPropertyValue(arg0, arg1);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn setPropertyValue_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: setPropertyValue::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn setPropertyPriority<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"CSSStyleDeclaration.setPropertyPriority\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let arg1: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(1), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetPropertyPriority(arg0, arg1);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn setPropertyPriority_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: setPropertyPriority::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn removeProperty<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"CSSStyleDeclaration.removeProperty\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<DOMString, Error<TH>> = this.RemoveProperty(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn removeProperty_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: removeProperty::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_cssFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.CssFloat();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_cssFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetCssFloat(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn cssFloat_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_cssFloat::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn cssFloat_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_cssFloat::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_all<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.All();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_all<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetAll(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn all_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_all::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn all_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_all::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_background<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Background();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_background<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBackground(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn background_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_background::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn background_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_background::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_backgroundColor<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BackgroundColor();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_backgroundColor<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBackgroundColor(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn backgroundColor_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_backgroundColor::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn backgroundColor_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_backgroundColor::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_background_color<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Background_color();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_background_color<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBackground_color(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn background_color_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_background_color::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn background_color_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_background_color::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_backgroundPosition<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BackgroundPosition();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_backgroundPosition<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBackgroundPosition(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn backgroundPosition_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_backgroundPosition::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn backgroundPosition_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_backgroundPosition::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_background_position<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Background_position();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_background_position<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBackground_position(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn background_position_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_background_position::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn background_position_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_background_position::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_backgroundPositionX<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BackgroundPositionX();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_backgroundPositionX<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBackgroundPositionX(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn backgroundPositionX_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_backgroundPositionX::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn backgroundPositionX_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_backgroundPositionX::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_background_position_x<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Background_position_x();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_background_position_x<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBackground_position_x(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn background_position_x_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_background_position_x::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn background_position_x_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_background_position_x::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_backgroundPositionY<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BackgroundPositionY();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_backgroundPositionY<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBackgroundPositionY(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn backgroundPositionY_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_backgroundPositionY::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn backgroundPositionY_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_backgroundPositionY::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_background_position_y<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Background_position_y();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_background_position_y<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBackground_position_y(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn background_position_y_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_background_position_y::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn background_position_y_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_background_position_y::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_backgroundRepeat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BackgroundRepeat();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_backgroundRepeat<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBackgroundRepeat(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn backgroundRepeat_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_backgroundRepeat::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn backgroundRepeat_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_backgroundRepeat::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_background_repeat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Background_repeat();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_background_repeat<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBackground_repeat(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn background_repeat_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_background_repeat::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn background_repeat_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_background_repeat::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_backgroundImage<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BackgroundImage();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_backgroundImage<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBackgroundImage(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn backgroundImage_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_backgroundImage::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn backgroundImage_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_backgroundImage::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_background_image<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Background_image();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_background_image<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBackground_image(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn background_image_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_background_image::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn background_image_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_background_image::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_backgroundAttachment<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BackgroundAttachment();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_backgroundAttachment<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBackgroundAttachment(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn backgroundAttachment_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_backgroundAttachment::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn backgroundAttachment_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_backgroundAttachment::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_background_attachment<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Background_attachment();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_background_attachment<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBackground_attachment(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn background_attachment_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_background_attachment::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn background_attachment_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_background_attachment::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_backgroundSize<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BackgroundSize();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_backgroundSize<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBackgroundSize(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn backgroundSize_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_backgroundSize::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn backgroundSize_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_backgroundSize::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_background_size<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Background_size();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_background_size<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBackground_size(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn background_size_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_background_size::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn background_size_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_background_size::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_backgroundOrigin<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BackgroundOrigin();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_backgroundOrigin<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBackgroundOrigin(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn backgroundOrigin_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_backgroundOrigin::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn backgroundOrigin_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_backgroundOrigin::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_background_origin<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Background_origin();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_background_origin<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBackground_origin(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn background_origin_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_background_origin::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn background_origin_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_background_origin::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_backgroundClip<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BackgroundClip();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_backgroundClip<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBackgroundClip(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn backgroundClip_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_backgroundClip::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn backgroundClip_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_backgroundClip::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_background_clip<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Background_clip();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_background_clip<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBackground_clip(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn background_clip_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_background_clip::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn background_clip_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_background_clip::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderColor<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderColor();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderColor<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderColor(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderColor_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderColor::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderColor_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderColor::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_color<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_color();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_color<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_color(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_color_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_color::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_color_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_color::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderRadius<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderRadius();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderRadius<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderRadius(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderRadius_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderRadius::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderRadius_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderRadius::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_radius<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_radius();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_radius<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_radius(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_radius_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_radius::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_radius_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_radius::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderSpacing<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderSpacing();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderSpacing<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderSpacing(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderSpacing_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderSpacing::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderSpacing_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderSpacing::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_spacing<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_spacing();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_spacing<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_spacing(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_spacing_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_spacing::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_spacing_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_spacing::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderStyle();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderStyle(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderStyle_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderStyle::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderStyle_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderStyle::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_style<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_style();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_style<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_style(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_style_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_style::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_style_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_style::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderWidth();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderWidth(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderWidth_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderWidth_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_width<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_width();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_width<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_width(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_width_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_width::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_width_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_width::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderBottom<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderBottom();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderBottom<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderBottom(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderBottom_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderBottom::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderBottom_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderBottom::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_bottom<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_bottom();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_bottom<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_bottom(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_bottom_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_bottom::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_bottom_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_bottom::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderBottomColor<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderBottomColor();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderBottomColor<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderBottomColor(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderBottomColor_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderBottomColor::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderBottomColor_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderBottomColor::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_bottom_color<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_bottom_color();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_bottom_color<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_bottom_color(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_bottom_color_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_bottom_color::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_bottom_color_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_bottom_color::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderBottomLeftRadius<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderBottomLeftRadius();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderBottomLeftRadius<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderBottomLeftRadius(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderBottomLeftRadius_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderBottomLeftRadius::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderBottomLeftRadius_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderBottomLeftRadius::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_bottom_left_radius<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_bottom_left_radius();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_bottom_left_radius<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_bottom_left_radius(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_bottom_left_radius_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_bottom_left_radius::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_bottom_left_radius_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_bottom_left_radius::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderBottomRightRadius<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderBottomRightRadius();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderBottomRightRadius<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderBottomRightRadius(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderBottomRightRadius_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderBottomRightRadius::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderBottomRightRadius_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderBottomRightRadius::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_bottom_right_radius<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_bottom_right_radius();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_bottom_right_radius<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_bottom_right_radius(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_bottom_right_radius_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_bottom_right_radius::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_bottom_right_radius_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_bottom_right_radius::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderBottomStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderBottomStyle();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderBottomStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderBottomStyle(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderBottomStyle_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderBottomStyle::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderBottomStyle_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderBottomStyle::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_bottom_style<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_bottom_style();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_bottom_style<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_bottom_style(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_bottom_style_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_bottom_style::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_bottom_style_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_bottom_style::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderBottomWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderBottomWidth();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderBottomWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderBottomWidth(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderBottomWidth_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderBottomWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderBottomWidth_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderBottomWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_bottom_width<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_bottom_width();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_bottom_width<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_bottom_width(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_bottom_width_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_bottom_width::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_bottom_width_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_bottom_width::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderLeft<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderLeft();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderLeft<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderLeft(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderLeft_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderLeft::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderLeft_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderLeft::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_left<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_left();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_left<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_left(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_left_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_left::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_left_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_left::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderLeftColor<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderLeftColor();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderLeftColor<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderLeftColor(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderLeftColor_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderLeftColor::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderLeftColor_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderLeftColor::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_left_color<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_left_color();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_left_color<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_left_color(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_left_color_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_left_color::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_left_color_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_left_color::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderLeftStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderLeftStyle();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderLeftStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderLeftStyle(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderLeftStyle_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderLeftStyle::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderLeftStyle_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderLeftStyle::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_left_style<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_left_style();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_left_style<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_left_style(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_left_style_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_left_style::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_left_style_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_left_style::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderLeftWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderLeftWidth();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderLeftWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderLeftWidth(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderLeftWidth_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderLeftWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderLeftWidth_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderLeftWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_left_width<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_left_width();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_left_width<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_left_width(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_left_width_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_left_width::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_left_width_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_left_width::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderRight<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderRight();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderRight<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderRight(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderRight_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderRight::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderRight_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderRight::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_right<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_right();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_right<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_right(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_right_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_right::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_right_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_right::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderRightColor<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderRightColor();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderRightColor<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderRightColor(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderRightColor_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderRightColor::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderRightColor_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderRightColor::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_right_color<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_right_color();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_right_color<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_right_color(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_right_color_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_right_color::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_right_color_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_right_color::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderRightStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderRightStyle();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderRightStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderRightStyle(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderRightStyle_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderRightStyle::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderRightStyle_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderRightStyle::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_right_style<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_right_style();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_right_style<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_right_style(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_right_style_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_right_style::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_right_style_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_right_style::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderRightWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderRightWidth();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderRightWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderRightWidth(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderRightWidth_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderRightWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderRightWidth_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderRightWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_right_width<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_right_width();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_right_width<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_right_width(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_right_width_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_right_width::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_right_width_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_right_width::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderTop<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderTop();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderTop<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderTop(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderTop_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderTop::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderTop_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderTop::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_top<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_top();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_top<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_top(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_top_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_top::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_top_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_top::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderTopColor<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderTopColor();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderTopColor<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderTopColor(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderTopColor_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderTopColor::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderTopColor_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderTopColor::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_top_color<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_top_color();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_top_color<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_top_color(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_top_color_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_top_color::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_top_color_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_top_color::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderTopLeftRadius<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderTopLeftRadius();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderTopLeftRadius<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderTopLeftRadius(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderTopLeftRadius_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderTopLeftRadius::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderTopLeftRadius_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderTopLeftRadius::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_top_left_radius<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_top_left_radius();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_top_left_radius<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_top_left_radius(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_top_left_radius_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_top_left_radius::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_top_left_radius_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_top_left_radius::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderTopRightRadius<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderTopRightRadius();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderTopRightRadius<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderTopRightRadius(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderTopRightRadius_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderTopRightRadius::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderTopRightRadius_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderTopRightRadius::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_top_right_radius<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_top_right_radius();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_top_right_radius<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_top_right_radius(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_top_right_radius_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_top_right_radius::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_top_right_radius_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_top_right_radius::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderTopStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderTopStyle();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderTopStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderTopStyle(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderTopStyle_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderTopStyle::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderTopStyle_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderTopStyle::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_top_style<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_top_style();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_top_style<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_top_style(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_top_style_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_top_style::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_top_style_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_top_style::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderTopWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderTopWidth();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderTopWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderTopWidth(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderTopWidth_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderTopWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderTopWidth_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderTopWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_top_width<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_top_width();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_top_width<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_top_width(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_top_width_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_top_width::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_top_width_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_top_width::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_image_source<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_image_source();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_image_source<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_image_source(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_image_source_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_image_source::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_image_source_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_image_source::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderImageSource<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderImageSource();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderImageSource<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderImageSource(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderImageSource_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderImageSource::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderImageSource_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderImageSource::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_image_slice<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_image_slice();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_image_slice<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_image_slice(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_image_slice_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_image_slice::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_image_slice_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_image_slice::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderImageSlice<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderImageSlice();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderImageSlice<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderImageSlice(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderImageSlice_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderImageSlice::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderImageSlice_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderImageSlice::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_image_repeat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_image_repeat();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_image_repeat<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_image_repeat(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_image_repeat_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_image_repeat::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_image_repeat_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_image_repeat::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderImageRepeat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderImageRepeat();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderImageRepeat<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderImageRepeat(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderImageRepeat_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderImageRepeat::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderImageRepeat_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderImageRepeat::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_image_outset<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_image_outset();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_image_outset<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_image_outset(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_image_outset_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_image_outset::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_image_outset_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_image_outset::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderImageOutset<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderImageOutset();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderImageOutset<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderImageOutset(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderImageOutset_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderImageOutset::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderImageOutset_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderImageOutset::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_image_width<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_image_width();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_image_width<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_image_width(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_image_width_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_image_width::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_image_width_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_image_width::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderImageWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderImageWidth();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderImageWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderImageWidth(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderImageWidth_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderImageWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderImageWidth_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderImageWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_image<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_image();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_image<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_image(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_image_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_image::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_image_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_image::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderImage<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderImage();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderImage<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderImage(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderImage_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderImage::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderImage_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderImage::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_block_start_color<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_block_start_color();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_block_start_color<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_block_start_color(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_block_start_color_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_block_start_color::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_block_start_color_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_block_start_color::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderBlockStartColor<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderBlockStartColor();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderBlockStartColor<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderBlockStartColor(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderBlockStartColor_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderBlockStartColor::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderBlockStartColor_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderBlockStartColor::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_block_start_width<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_block_start_width();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_block_start_width<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_block_start_width(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_block_start_width_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_block_start_width::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_block_start_width_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_block_start_width::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderBlockStartWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderBlockStartWidth();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderBlockStartWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderBlockStartWidth(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderBlockStartWidth_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderBlockStartWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderBlockStartWidth_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderBlockStartWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_block_start_style<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_block_start_style();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_block_start_style<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_block_start_style(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_block_start_style_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_block_start_style::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_block_start_style_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_block_start_style::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderBlockStartStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderBlockStartStyle();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderBlockStartStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderBlockStartStyle(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderBlockStartStyle_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderBlockStartStyle::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderBlockStartStyle_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderBlockStartStyle::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_block_end_color<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_block_end_color();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_block_end_color<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_block_end_color(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_block_end_color_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_block_end_color::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_block_end_color_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_block_end_color::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderBlockEndColor<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderBlockEndColor();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderBlockEndColor<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderBlockEndColor(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderBlockEndColor_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderBlockEndColor::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderBlockEndColor_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderBlockEndColor::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_block_end_width<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_block_end_width();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_block_end_width<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_block_end_width(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_block_end_width_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_block_end_width::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_block_end_width_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_block_end_width::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderBlockEndWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderBlockEndWidth();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderBlockEndWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderBlockEndWidth(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderBlockEndWidth_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderBlockEndWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderBlockEndWidth_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderBlockEndWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_block_end_style<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_block_end_style();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_block_end_style<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_block_end_style(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_block_end_style_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_block_end_style::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_block_end_style_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_block_end_style::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderBlockEndStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderBlockEndStyle();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderBlockEndStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderBlockEndStyle(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderBlockEndStyle_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderBlockEndStyle::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderBlockEndStyle_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderBlockEndStyle::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_inline_start_color<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_inline_start_color();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_inline_start_color<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_inline_start_color(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_inline_start_color_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_inline_start_color::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_inline_start_color_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_inline_start_color::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderInlineStartColor<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderInlineStartColor();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderInlineStartColor<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderInlineStartColor(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderInlineStartColor_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderInlineStartColor::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderInlineStartColor_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderInlineStartColor::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_inline_start_width<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_inline_start_width();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_inline_start_width<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_inline_start_width(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_inline_start_width_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_inline_start_width::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_inline_start_width_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_inline_start_width::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderInlineStartWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderInlineStartWidth();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderInlineStartWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderInlineStartWidth(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderInlineStartWidth_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderInlineStartWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderInlineStartWidth_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderInlineStartWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_inline_start_style<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_inline_start_style();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_inline_start_style<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_inline_start_style(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_inline_start_style_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_inline_start_style::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_inline_start_style_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_inline_start_style::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderInlineStartStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderInlineStartStyle();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderInlineStartStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderInlineStartStyle(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderInlineStartStyle_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderInlineStartStyle::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderInlineStartStyle_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderInlineStartStyle::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_inline_end_color<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_inline_end_color();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_inline_end_color<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_inline_end_color(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_inline_end_color_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_inline_end_color::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_inline_end_color_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_inline_end_color::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderInlineEndColor<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderInlineEndColor();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderInlineEndColor<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderInlineEndColor(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderInlineEndColor_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderInlineEndColor::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderInlineEndColor_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderInlineEndColor::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_inline_end_width<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_inline_end_width();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_inline_end_width<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_inline_end_width(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_inline_end_width_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_inline_end_width::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_inline_end_width_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_inline_end_width::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderInlineEndWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderInlineEndWidth();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderInlineEndWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderInlineEndWidth(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderInlineEndWidth_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderInlineEndWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderInlineEndWidth_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderInlineEndWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_inline_end_style<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_inline_end_style();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_inline_end_style<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_inline_end_style(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_inline_end_style_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_inline_end_style::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_inline_end_style_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_inline_end_style::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderInlineEndStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderInlineEndStyle();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderInlineEndStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderInlineEndStyle(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderInlineEndStyle_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderInlineEndStyle::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderInlineEndStyle_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderInlineEndStyle::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_block_start<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_block_start();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_block_start<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_block_start(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_block_start_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_block_start::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_block_start_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_block_start::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderBlockStart<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderBlockStart();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderBlockStart<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderBlockStart(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderBlockStart_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderBlockStart::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderBlockStart_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderBlockStart::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_block_end<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_block_end();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_block_end<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_block_end(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_block_end_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_block_end::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_block_end_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_block_end::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderBlockEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderBlockEnd();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderBlockEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderBlockEnd(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderBlockEnd_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderBlockEnd::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderBlockEnd_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderBlockEnd::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_inline_start<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_inline_start();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_inline_start<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_inline_start(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_inline_start_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_inline_start::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_inline_start_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_inline_start::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderInlineStart<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderInlineStart();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderInlineStart<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderInlineStart(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderInlineStart_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderInlineStart::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderInlineStart_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderInlineStart::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_inline_end<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_inline_end();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_inline_end<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_inline_end(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_inline_end_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_inline_end::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_inline_end_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_inline_end::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderInlineEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderInlineEnd();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderInlineEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderInlineEnd(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderInlineEnd_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderInlineEnd::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderInlineEnd_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderInlineEnd::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_content<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Content();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_content<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetContent(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn content_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_content::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn content_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_content::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_color<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Color();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_color<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetColor(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn color_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_color::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn color_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_color::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_display<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Display();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_display<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetDisplay(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn display_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_display::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn display_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_display::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_opacity<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Opacity();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_opacity<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetOpacity(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn opacity_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_opacity::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn opacity_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_opacity::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_visibility<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Visibility();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_visibility<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetVisibility(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn visibility_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_visibility::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn visibility_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_visibility::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_cursor<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Cursor();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_cursor<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetCursor(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn cursor_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_cursor::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn cursor_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_cursor::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_boxSizing<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BoxSizing();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_boxSizing<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBoxSizing(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn boxSizing_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_boxSizing::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn boxSizing_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_boxSizing::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_box_sizing<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Box_sizing();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_box_sizing<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBox_sizing(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn box_sizing_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_box_sizing::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn box_sizing_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_box_sizing::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_boxShadow<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BoxShadow();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_boxShadow<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBoxShadow(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn boxShadow_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_boxShadow::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn boxShadow_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_boxShadow::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_box_shadow<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Box_shadow();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_box_shadow<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBox_shadow(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn box_shadow_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_box_shadow::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn box_shadow_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_box_shadow::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_textShadow<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.TextShadow();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_textShadow<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetTextShadow(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn textShadow_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_textShadow::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn textShadow_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_textShadow::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_text_shadow<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Text_shadow();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_text_shadow<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetText_shadow(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn text_shadow_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_text_shadow::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn text_shadow_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_text_shadow::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_float<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Float();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_float<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetFloat(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn float_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_float::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn float_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_float::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_clear<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Clear();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_clear<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetClear(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn clear_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_clear::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn clear_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_clear::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_clip<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Clip();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_clip<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetClip(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn clip_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_clip::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn clip_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_clip::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_transform<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Transform();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_transform<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetTransform(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn transform_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_transform::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn transform_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_transform::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_transformOrigin<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.TransformOrigin();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_transformOrigin<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetTransformOrigin(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn transformOrigin_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_transformOrigin::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn transformOrigin_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_transformOrigin::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_transform_origin<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Transform_origin();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_transform_origin<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetTransform_origin(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn transform_origin_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_transform_origin::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn transform_origin_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_transform_origin::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_perspective<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Perspective();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_perspective<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetPerspective(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn perspective_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_perspective::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn perspective_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_perspective::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_perspectiveOrigin<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.PerspectiveOrigin();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_perspectiveOrigin<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetPerspectiveOrigin(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn perspectiveOrigin_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_perspectiveOrigin::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn perspectiveOrigin_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_perspectiveOrigin::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_perspective_origin<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Perspective_origin();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_perspective_origin<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetPerspective_origin(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn perspective_origin_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_perspective_origin::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn perspective_origin_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_perspective_origin::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_transformStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.TransformStyle();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_transformStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetTransformStyle(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn transformStyle_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_transformStyle::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn transformStyle_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_transformStyle::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_transform_style<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Transform_style();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_transform_style<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetTransform_style(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn transform_style_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_transform_style::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn transform_style_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_transform_style::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_backfaceVisibility<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BackfaceVisibility();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_backfaceVisibility<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBackfaceVisibility(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn backfaceVisibility_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_backfaceVisibility::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn backfaceVisibility_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_backfaceVisibility::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_backface_visibility<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Backface_visibility();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_backface_visibility<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBackface_visibility(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn backface_visibility_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_backface_visibility::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn backface_visibility_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_backface_visibility::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_rotate<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Rotate();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_rotate<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetRotate(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn rotate_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_rotate::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn rotate_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_rotate::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_scale<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Scale();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_scale<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetScale(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn scale_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_scale::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn scale_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_scale::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_translate<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Translate();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_translate<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetTranslate(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn translate_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_translate::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn translate_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_translate::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_direction<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Direction();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_direction<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetDirection(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn direction_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_direction::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn direction_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_direction::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_unicodeBidi<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.UnicodeBidi();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_unicodeBidi<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetUnicodeBidi(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn unicodeBidi_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_unicodeBidi::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn unicodeBidi_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_unicodeBidi::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_unicode_bidi<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Unicode_bidi();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_unicode_bidi<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetUnicode_bidi(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn unicode_bidi_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_unicode_bidi::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn unicode_bidi_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_unicode_bidi::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_filter<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Filter();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_filter<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetFilter(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn filter_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_filter::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn filter_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_filter::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_lineHeight<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.LineHeight();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_lineHeight<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetLineHeight(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn lineHeight_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_lineHeight::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn lineHeight_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_lineHeight::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_line_height<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Line_height();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_line_height<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetLine_height(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn line_height_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_line_height::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn line_height_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_line_height::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_mixBlendMode<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.MixBlendMode();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_mixBlendMode<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMixBlendMode(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn mixBlendMode_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_mixBlendMode::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn mixBlendMode_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_mixBlendMode::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_mix_blend_mode<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Mix_blend_mode();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_mix_blend_mode<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMix_blend_mode(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn mix_blend_mode_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_mix_blend_mode::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn mix_blend_mode_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_mix_blend_mode::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_verticalAlign<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.VerticalAlign();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_verticalAlign<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetVerticalAlign(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn verticalAlign_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_verticalAlign::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn verticalAlign_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_verticalAlign::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_vertical_align<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Vertical_align();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_vertical_align<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetVertical_align(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn vertical_align_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_vertical_align::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn vertical_align_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_vertical_align::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_listStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.ListStyle();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_listStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetListStyle(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn listStyle_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_listStyle::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn listStyle_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_listStyle::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_list_style<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.List_style();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_list_style<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetList_style(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn list_style_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_list_style::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn list_style_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_list_style::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_listStylePosition<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.ListStylePosition();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_listStylePosition<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetListStylePosition(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn listStylePosition_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_listStylePosition::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn listStylePosition_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_listStylePosition::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_list_style_position<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.List_style_position();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_list_style_position<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetList_style_position(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn list_style_position_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_list_style_position::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn list_style_position_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_list_style_position::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_listStyleType<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.ListStyleType();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_listStyleType<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetListStyleType(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn listStyleType_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_listStyleType::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn listStyleType_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_listStyleType::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_list_style_type<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.List_style_type();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_list_style_type<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetList_style_type(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn list_style_type_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_list_style_type::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn list_style_type_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_list_style_type::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_listStyleImage<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.ListStyleImage();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_listStyleImage<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetListStyleImage(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn listStyleImage_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_listStyleImage::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn listStyleImage_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_listStyleImage::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_list_style_image<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.List_style_image();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_list_style_image<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetList_style_image(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn list_style_image_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_list_style_image::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn list_style_image_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_list_style_image::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_quotes<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Quotes();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_quotes<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetQuotes(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn quotes_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_quotes::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn quotes_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_quotes::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_counterIncrement<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.CounterIncrement();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_counterIncrement<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetCounterIncrement(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn counterIncrement_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_counterIncrement::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn counterIncrement_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_counterIncrement::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_counter_increment<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Counter_increment();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_counter_increment<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetCounter_increment(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn counter_increment_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_counter_increment::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn counter_increment_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_counter_increment::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_counterReset<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.CounterReset();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_counterReset<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetCounterReset(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn counterReset_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_counterReset::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn counterReset_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_counterReset::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_counter_reset<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Counter_reset();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_counter_reset<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetCounter_reset(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn counter_reset_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_counter_reset::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn counter_reset_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_counter_reset::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_overflow<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Overflow();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_overflow<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetOverflow(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn overflow_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_overflow::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn overflow_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_overflow::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_overflowX<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.OverflowX();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_overflowX<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetOverflowX(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn overflowX_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_overflowX::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn overflowX_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_overflowX::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_overflow_x<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Overflow_x();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_overflow_x<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetOverflow_x(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn overflow_x_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_overflow_x::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn overflow_x_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_overflow_x::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_overflowY<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.OverflowY();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_overflowY<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetOverflowY(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn overflowY_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_overflowY::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn overflowY_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_overflowY::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_overflow_y<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Overflow_y();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_overflow_y<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetOverflow_y(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn overflow_y_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_overflow_y::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn overflow_y_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_overflow_y::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_overflowWrap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.OverflowWrap();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_overflowWrap<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetOverflowWrap(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn overflowWrap_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_overflowWrap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn overflowWrap_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_overflowWrap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_overflow_wrap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Overflow_wrap();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_overflow_wrap<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetOverflow_wrap(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn overflow_wrap_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_overflow_wrap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn overflow_wrap_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_overflow_wrap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_tableLayout<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.TableLayout();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_tableLayout<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetTableLayout(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn tableLayout_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_tableLayout::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn tableLayout_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_tableLayout::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_table_layout<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Table_layout();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_table_layout<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetTable_layout(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn table_layout_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_table_layout::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn table_layout_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_table_layout::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_borderCollapse<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BorderCollapse();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_borderCollapse<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorderCollapse(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn borderCollapse_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_borderCollapse::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn borderCollapse_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_borderCollapse::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_border_collapse<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Border_collapse();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_border_collapse<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBorder_collapse(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn border_collapse_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_border_collapse::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn border_collapse_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_border_collapse::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_emptyCells<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.EmptyCells();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_emptyCells<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetEmptyCells(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn emptyCells_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_emptyCells::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn emptyCells_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_emptyCells::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_empty_cells<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Empty_cells();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_empty_cells<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetEmpty_cells(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn empty_cells_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_empty_cells::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn empty_cells_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_empty_cells::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_captionSide<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.CaptionSide();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_captionSide<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetCaptionSide(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn captionSide_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_captionSide::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn captionSide_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_captionSide::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_caption_side<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Caption_side();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_caption_side<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetCaption_side(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn caption_side_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_caption_side::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn caption_side_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_caption_side::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_whiteSpace<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.WhiteSpace();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_whiteSpace<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetWhiteSpace(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn whiteSpace_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_whiteSpace::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn whiteSpace_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_whiteSpace::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_white_space<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.White_space();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_white_space<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetWhite_space(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn white_space_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_white_space::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn white_space_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_white_space::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_writingMode<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.WritingMode();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_writingMode<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetWritingMode(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn writingMode_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_writingMode::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn writingMode_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_writingMode::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_writing_mode<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Writing_mode();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_writing_mode<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetWriting_mode(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn writing_mode_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_writing_mode::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn writing_mode_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_writing_mode::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_letterSpacing<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.LetterSpacing();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_letterSpacing<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetLetterSpacing(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn letterSpacing_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_letterSpacing::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn letterSpacing_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_letterSpacing::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_letter_spacing<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Letter_spacing();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_letter_spacing<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetLetter_spacing(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn letter_spacing_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_letter_spacing::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn letter_spacing_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_letter_spacing::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_wordBreak<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.WordBreak();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_wordBreak<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetWordBreak(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn wordBreak_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_wordBreak::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn wordBreak_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_wordBreak::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_word_break<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Word_break();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_word_break<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetWord_break(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn word_break_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_word_break::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn word_break_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_word_break::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_wordSpacing<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.WordSpacing();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_wordSpacing<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetWordSpacing(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn wordSpacing_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_wordSpacing::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn wordSpacing_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_wordSpacing::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_word_spacing<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Word_spacing();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_word_spacing<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetWord_spacing(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn word_spacing_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_word_spacing::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn word_spacing_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_word_spacing::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_wordWrap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.WordWrap();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_wordWrap<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetWordWrap(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn wordWrap_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_wordWrap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn wordWrap_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_wordWrap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_word_wrap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Word_wrap();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_word_wrap<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetWord_wrap(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn word_wrap_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_word_wrap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn word_wrap_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_word_wrap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_textOverflow<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.TextOverflow();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_textOverflow<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetTextOverflow(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn textOverflow_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_textOverflow::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn textOverflow_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_textOverflow::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_text_overflow<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Text_overflow();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_text_overflow<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetText_overflow(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn text_overflow_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_text_overflow::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn text_overflow_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_text_overflow::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_textAlign<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.TextAlign();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_textAlign<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetTextAlign(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn textAlign_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_textAlign::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn textAlign_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_textAlign::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_text_align<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Text_align();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_text_align<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetText_align(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn text_align_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_text_align::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn text_align_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_text_align::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_textDecoration<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.TextDecoration();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_textDecoration<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetTextDecoration(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn textDecoration_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_textDecoration::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn textDecoration_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_textDecoration::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_text_decoration<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Text_decoration();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_text_decoration<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetText_decoration(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn text_decoration_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_text_decoration::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn text_decoration_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_text_decoration::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_textDecorationLine<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.TextDecorationLine();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_textDecorationLine<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetTextDecorationLine(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn textDecorationLine_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_textDecorationLine::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn textDecorationLine_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_textDecorationLine::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_text_decoration_line<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Text_decoration_line();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_text_decoration_line<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetText_decoration_line(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn text_decoration_line_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_text_decoration_line::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn text_decoration_line_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_text_decoration_line::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_textIndent<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.TextIndent();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_textIndent<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetTextIndent(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn textIndent_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_textIndent::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn textIndent_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_textIndent::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_text_indent<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Text_indent();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_text_indent<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetText_indent(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn text_indent_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_text_indent::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn text_indent_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_text_indent::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_textJustify<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.TextJustify();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_textJustify<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetTextJustify(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn textJustify_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_textJustify::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn textJustify_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_textJustify::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_text_justify<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Text_justify();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_text_justify<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetText_justify(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn text_justify_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_text_justify::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn text_justify_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_text_justify::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_textRendering<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.TextRendering();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_textRendering<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetTextRendering(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn textRendering_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_textRendering::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn textRendering_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_textRendering::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_text_rendering<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Text_rendering();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_text_rendering<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetText_rendering(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn text_rendering_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_text_rendering::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn text_rendering_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_text_rendering::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_textTransform<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.TextTransform();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_textTransform<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetTextTransform(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn textTransform_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_textTransform::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn textTransform_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_textTransform::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_text_transform<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Text_transform();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_text_transform<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetText_transform(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn text_transform_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_text_transform::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn text_transform_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_text_transform::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_font<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Font();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_font<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetFont(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn font_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_font::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn font_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_font::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_fontFamily<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.FontFamily();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_fontFamily<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetFontFamily(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn fontFamily_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_fontFamily::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn fontFamily_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_fontFamily::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_font_family<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Font_family();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_font_family<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetFont_family(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn font_family_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_font_family::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn font_family_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_font_family::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_fontSize<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.FontSize();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_fontSize<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetFontSize(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn fontSize_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_fontSize::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn fontSize_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_fontSize::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_font_size<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Font_size();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_font_size<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetFont_size(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn font_size_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_font_size::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn font_size_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_font_size::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_fontStretch<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.FontStretch();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_fontStretch<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetFontStretch(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn fontStretch_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_fontStretch::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn fontStretch_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_fontStretch::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_font_stretch<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Font_stretch();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_font_stretch<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetFont_stretch(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn font_stretch_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_font_stretch::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn font_stretch_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_font_stretch::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_fontStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.FontStyle();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_fontStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetFontStyle(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn fontStyle_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_fontStyle::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn fontStyle_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_fontStyle::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_font_style<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Font_style();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_font_style<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetFont_style(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn font_style_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_font_style::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn font_style_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_font_style::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_fontVariant<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.FontVariant();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_fontVariant<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetFontVariant(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn fontVariant_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_fontVariant::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn fontVariant_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_fontVariant::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_font_variant<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Font_variant();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_font_variant<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetFont_variant(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn font_variant_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_font_variant::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn font_variant_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_font_variant::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_fontVariantCaps<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.FontVariantCaps();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_fontVariantCaps<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetFontVariantCaps(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn fontVariantCaps_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_fontVariantCaps::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn fontVariantCaps_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_fontVariantCaps::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_font_variant_caps<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Font_variant_caps();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_font_variant_caps<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetFont_variant_caps(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn font_variant_caps_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_font_variant_caps::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn font_variant_caps_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_font_variant_caps::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_fontWeight<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.FontWeight();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_fontWeight<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetFontWeight(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn fontWeight_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_fontWeight::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn fontWeight_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_fontWeight::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_font_weight<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Font_weight();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_font_weight<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetFont_weight(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn font_weight_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_font_weight::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn font_weight_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_font_weight::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_margin<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Margin();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_margin<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMargin(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn margin_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_margin::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn margin_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_margin::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_marginBottom<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.MarginBottom();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_marginBottom<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMarginBottom(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn marginBottom_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_marginBottom::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn marginBottom_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_marginBottom::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_margin_bottom<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Margin_bottom();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_margin_bottom<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMargin_bottom(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn margin_bottom_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_margin_bottom::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn margin_bottom_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_margin_bottom::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_marginLeft<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.MarginLeft();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_marginLeft<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMarginLeft(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn marginLeft_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_marginLeft::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn marginLeft_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_marginLeft::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_margin_left<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Margin_left();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_margin_left<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMargin_left(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn margin_left_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_margin_left::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn margin_left_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_margin_left::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_marginRight<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.MarginRight();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_marginRight<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMarginRight(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn marginRight_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_marginRight::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn marginRight_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_marginRight::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_margin_right<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Margin_right();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_margin_right<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMargin_right(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn margin_right_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_margin_right::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn margin_right_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_margin_right::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_marginTop<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.MarginTop();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_marginTop<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMarginTop(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn marginTop_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_marginTop::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn marginTop_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_marginTop::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_margin_top<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Margin_top();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_margin_top<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMargin_top(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn margin_top_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_margin_top::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn margin_top_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_margin_top::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_margin_block_start<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Margin_block_start();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_margin_block_start<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMargin_block_start(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn margin_block_start_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_margin_block_start::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn margin_block_start_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_margin_block_start::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_marginBlockStart<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.MarginBlockStart();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_marginBlockStart<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMarginBlockStart(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn marginBlockStart_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_marginBlockStart::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn marginBlockStart_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_marginBlockStart::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_margin_block_end<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Margin_block_end();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_margin_block_end<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMargin_block_end(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn margin_block_end_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_margin_block_end::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn margin_block_end_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_margin_block_end::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_marginBlockEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.MarginBlockEnd();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_marginBlockEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMarginBlockEnd(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn marginBlockEnd_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_marginBlockEnd::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn marginBlockEnd_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_marginBlockEnd::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_margin_inline_start<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Margin_inline_start();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_margin_inline_start<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMargin_inline_start(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn margin_inline_start_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_margin_inline_start::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn margin_inline_start_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_margin_inline_start::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_marginInlineStart<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.MarginInlineStart();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_marginInlineStart<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMarginInlineStart(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn marginInlineStart_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_marginInlineStart::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn marginInlineStart_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_marginInlineStart::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_margin_inline_end<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Margin_inline_end();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_margin_inline_end<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMargin_inline_end(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn margin_inline_end_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_margin_inline_end::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn margin_inline_end_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_margin_inline_end::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_marginInlineEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.MarginInlineEnd();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_marginInlineEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMarginInlineEnd(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn marginInlineEnd_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_marginInlineEnd::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn marginInlineEnd_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_marginInlineEnd::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_padding<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Padding();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_padding<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetPadding(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn padding_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_padding::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn padding_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_padding::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_paddingBottom<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.PaddingBottom();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_paddingBottom<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetPaddingBottom(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn paddingBottom_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_paddingBottom::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn paddingBottom_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_paddingBottom::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_padding_bottom<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Padding_bottom();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_padding_bottom<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetPadding_bottom(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn padding_bottom_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_padding_bottom::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn padding_bottom_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_padding_bottom::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_paddingLeft<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.PaddingLeft();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_paddingLeft<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetPaddingLeft(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn paddingLeft_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_paddingLeft::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn paddingLeft_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_paddingLeft::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_padding_left<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Padding_left();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_padding_left<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetPadding_left(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn padding_left_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_padding_left::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn padding_left_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_padding_left::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_paddingRight<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.PaddingRight();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_paddingRight<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetPaddingRight(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn paddingRight_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_paddingRight::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn paddingRight_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_paddingRight::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_padding_right<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Padding_right();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_padding_right<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetPadding_right(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn padding_right_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_padding_right::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn padding_right_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_padding_right::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_paddingTop<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.PaddingTop();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_paddingTop<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetPaddingTop(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn paddingTop_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_paddingTop::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn paddingTop_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_paddingTop::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_padding_top<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Padding_top();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_padding_top<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetPadding_top(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn padding_top_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_padding_top::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn padding_top_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_padding_top::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_padding_block_start<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Padding_block_start();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_padding_block_start<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetPadding_block_start(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn padding_block_start_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_padding_block_start::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn padding_block_start_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_padding_block_start::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_paddingBlockStart<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.PaddingBlockStart();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_paddingBlockStart<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetPaddingBlockStart(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn paddingBlockStart_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_paddingBlockStart::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn paddingBlockStart_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_paddingBlockStart::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_padding_block_end<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Padding_block_end();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_padding_block_end<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetPadding_block_end(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn padding_block_end_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_padding_block_end::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn padding_block_end_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_padding_block_end::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_paddingBlockEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.PaddingBlockEnd();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_paddingBlockEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetPaddingBlockEnd(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn paddingBlockEnd_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_paddingBlockEnd::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn paddingBlockEnd_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_paddingBlockEnd::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_padding_inline_start<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Padding_inline_start();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_padding_inline_start<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetPadding_inline_start(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn padding_inline_start_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_padding_inline_start::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn padding_inline_start_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_padding_inline_start::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_paddingInlineStart<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.PaddingInlineStart();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_paddingInlineStart<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetPaddingInlineStart(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn paddingInlineStart_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_paddingInlineStart::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn paddingInlineStart_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_paddingInlineStart::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_padding_inline_end<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Padding_inline_end();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_padding_inline_end<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetPadding_inline_end(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn padding_inline_end_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_padding_inline_end::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn padding_inline_end_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_padding_inline_end::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_paddingInlineEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.PaddingInlineEnd();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_paddingInlineEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetPaddingInlineEnd(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn paddingInlineEnd_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_paddingInlineEnd::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn paddingInlineEnd_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_paddingInlineEnd::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_outline<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Outline();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_outline<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetOutline(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn outline_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_outline::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn outline_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_outline::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_outlineColor<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.OutlineColor();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_outlineColor<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetOutlineColor(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn outlineColor_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_outlineColor::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn outlineColor_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_outlineColor::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_outline_color<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Outline_color();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_outline_color<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetOutline_color(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn outline_color_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_outline_color::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn outline_color_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_outline_color::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_outlineStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.OutlineStyle();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_outlineStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetOutlineStyle(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn outlineStyle_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_outlineStyle::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn outlineStyle_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_outlineStyle::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_outline_style<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Outline_style();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_outline_style<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetOutline_style(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn outline_style_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_outline_style::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn outline_style_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_outline_style::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_outlineWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.OutlineWidth();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_outlineWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetOutlineWidth(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn outlineWidth_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_outlineWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn outlineWidth_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_outlineWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_outline_width<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Outline_width();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_outline_width<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetOutline_width(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn outline_width_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_outline_width::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn outline_width_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_outline_width::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_outlineOffset<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.OutlineOffset();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_outlineOffset<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetOutlineOffset(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn outlineOffset_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_outlineOffset::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn outlineOffset_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_outlineOffset::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_outline_offset<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Outline_offset();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_outline_offset<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetOutline_offset(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn outline_offset_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_outline_offset::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn outline_offset_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_outline_offset::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_position<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Position();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_position<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetPosition(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn position_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_position::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn position_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_position::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_pointerEvents<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.PointerEvents();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_pointerEvents<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetPointerEvents(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn pointerEvents_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_pointerEvents::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn pointerEvents_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_pointerEvents::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_pointer_events<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Pointer_events();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_pointer_events<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetPointer_events(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn pointer_events_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_pointer_events::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn pointer_events_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_pointer_events::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_top<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Top();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_top<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetTop(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn top_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_top::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn top_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_top::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_right<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Right();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_right<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetRight(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn right_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_right::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn right_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_right::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_left<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Left();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_left<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetLeft(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn left_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_left::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn left_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_left::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_bottom<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Bottom();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_bottom<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBottom(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn bottom_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_bottom::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn bottom_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_bottom::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_offset_block_start<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Offset_block_start();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_offset_block_start<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetOffset_block_start(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn offset_block_start_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_offset_block_start::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn offset_block_start_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_offset_block_start::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_offsetBlockStart<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.OffsetBlockStart();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_offsetBlockStart<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetOffsetBlockStart(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn offsetBlockStart_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_offsetBlockStart::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn offsetBlockStart_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_offsetBlockStart::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_offset_block_end<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Offset_block_end();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_offset_block_end<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetOffset_block_end(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn offset_block_end_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_offset_block_end::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn offset_block_end_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_offset_block_end::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_offsetBlockEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.OffsetBlockEnd();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_offsetBlockEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetOffsetBlockEnd(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn offsetBlockEnd_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_offsetBlockEnd::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn offsetBlockEnd_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_offsetBlockEnd::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_offset_inline_start<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Offset_inline_start();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_offset_inline_start<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetOffset_inline_start(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn offset_inline_start_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_offset_inline_start::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn offset_inline_start_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_offset_inline_start::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_offsetInlineStart<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.OffsetInlineStart();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_offsetInlineStart<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetOffsetInlineStart(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn offsetInlineStart_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_offsetInlineStart::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn offsetInlineStart_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_offsetInlineStart::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_offset_inline_end<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Offset_inline_end();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_offset_inline_end<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetOffset_inline_end(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn offset_inline_end_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_offset_inline_end::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn offset_inline_end_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_offset_inline_end::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_offsetInlineEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.OffsetInlineEnd();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_offsetInlineEnd<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetOffsetInlineEnd(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn offsetInlineEnd_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_offsetInlineEnd::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn offsetInlineEnd_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_offsetInlineEnd::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_height<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Height();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_height<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetHeight(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn height_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_height::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn height_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_height::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_minHeight<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.MinHeight();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_minHeight<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMinHeight(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn minHeight_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_minHeight::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn minHeight_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_minHeight::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_min_height<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Min_height();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_min_height<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMin_height(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn min_height_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_min_height::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn min_height_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_min_height::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_maxHeight<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.MaxHeight();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_maxHeight<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMaxHeight(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn maxHeight_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_maxHeight::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn maxHeight_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_maxHeight::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_max_height<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Max_height();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_max_height<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMax_height(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn max_height_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_max_height::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn max_height_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_max_height::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_width<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Width();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_width<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetWidth(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn width_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_width::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn width_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_width::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_minWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.MinWidth();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_minWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMinWidth(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn minWidth_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_minWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn minWidth_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_minWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_min_width<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Min_width();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_min_width<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMin_width(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn min_width_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_min_width::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn min_width_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_min_width::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_maxWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.MaxWidth();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_maxWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMaxWidth(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn maxWidth_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_maxWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn maxWidth_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_maxWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_max_width<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Max_width();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_max_width<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMax_width(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn max_width_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_max_width::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn max_width_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_max_width::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_block_size<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Block_size();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_block_size<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBlock_size(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn block_size_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_block_size::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn block_size_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_block_size::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_blockSize<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BlockSize();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_blockSize<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetBlockSize(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn blockSize_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_blockSize::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn blockSize_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_blockSize::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_inline_size<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Inline_size();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_inline_size<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetInline_size(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn inline_size_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_inline_size::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn inline_size_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_inline_size::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_inlineSize<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.InlineSize();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_inlineSize<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetInlineSize(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn inlineSize_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_inlineSize::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn inlineSize_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_inlineSize::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_max_block_size<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Max_block_size();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_max_block_size<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMax_block_size(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn max_block_size_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_max_block_size::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn max_block_size_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_max_block_size::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_maxBlockSize<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.MaxBlockSize();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_maxBlockSize<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMaxBlockSize(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn maxBlockSize_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_maxBlockSize::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn maxBlockSize_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_maxBlockSize::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_max_inline_size<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Max_inline_size();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_max_inline_size<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMax_inline_size(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn max_inline_size_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_max_inline_size::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn max_inline_size_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_max_inline_size::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_maxInlineSize<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.MaxInlineSize();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_maxInlineSize<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMaxInlineSize(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn maxInlineSize_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_maxInlineSize::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn maxInlineSize_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_maxInlineSize::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_min_block_size<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Min_block_size();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_min_block_size<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMin_block_size(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn min_block_size_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_min_block_size::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn min_block_size_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_min_block_size::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_minBlockSize<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.MinBlockSize();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_minBlockSize<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMinBlockSize(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn minBlockSize_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_minBlockSize::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn minBlockSize_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_minBlockSize::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_min_inline_size<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Min_inline_size();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_min_inline_size<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMin_inline_size(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn min_inline_size_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_min_inline_size::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn min_inline_size_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_min_inline_size::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_minInlineSize<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.MinInlineSize();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_minInlineSize<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetMinInlineSize(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn minInlineSize_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_minInlineSize::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn minInlineSize_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_minInlineSize::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_zIndex<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.ZIndex();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_zIndex<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetZIndex(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn zIndex_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_zIndex::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn zIndex_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_zIndex::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_z_index<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Z_index();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_z_index<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetZ_index(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn z_index_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_z_index::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn z_index_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_z_index::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_imageRendering<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.ImageRendering();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_imageRendering<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetImageRendering(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn imageRendering_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_imageRendering::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn imageRendering_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_imageRendering::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_image_rendering<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Image_rendering();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_image_rendering<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetImage_rendering(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn image_rendering_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_image_rendering::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn image_rendering_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_image_rendering::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_columnCount<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.ColumnCount();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_columnCount<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetColumnCount(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn columnCount_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_columnCount::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn columnCount_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_columnCount::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_column_count<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Column_count();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_column_count<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetColumn_count(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn column_count_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_column_count::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn column_count_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_column_count::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_columnWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.ColumnWidth();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_columnWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetColumnWidth(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn columnWidth_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_columnWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn columnWidth_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_columnWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_column_width<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Column_width();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_column_width<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetColumn_width(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn column_width_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_column_width::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn column_width_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_column_width::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_columns<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Columns();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_columns<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetColumns(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn columns_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_columns::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn columns_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_columns::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_columnGap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.ColumnGap();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_columnGap<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetColumnGap(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn columnGap_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_columnGap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn columnGap_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_columnGap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_column_gap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Column_gap();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_column_gap<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetColumn_gap(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn column_gap_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_column_gap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn column_gap_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_column_gap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_transition<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Transition();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_transition<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetTransition(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn transition_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_transition::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn transition_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_transition::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_transitionDuration<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.TransitionDuration();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_transitionDuration<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetTransitionDuration(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn transitionDuration_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_transitionDuration::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn transitionDuration_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_transitionDuration::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_transition_duration<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Transition_duration();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_transition_duration<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetTransition_duration(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn transition_duration_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_transition_duration::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn transition_duration_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_transition_duration::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_transitionTimingFunction<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.TransitionTimingFunction();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_transitionTimingFunction<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetTransitionTimingFunction(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn transitionTimingFunction_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_transitionTimingFunction::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn transitionTimingFunction_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_transitionTimingFunction::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_transition_timing_function<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Transition_timing_function();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_transition_timing_function<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetTransition_timing_function(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn transition_timing_function_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_transition_timing_function::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn transition_timing_function_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_transition_timing_function::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_transitionProperty<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.TransitionProperty();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_transitionProperty<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetTransitionProperty(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn transitionProperty_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_transitionProperty::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn transitionProperty_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_transitionProperty::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_transition_property<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Transition_property();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_transition_property<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetTransition_property(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn transition_property_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_transition_property::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn transition_property_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_transition_property::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_transitionDelay<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.TransitionDelay();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_transitionDelay<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetTransitionDelay(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn transitionDelay_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_transitionDelay::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn transitionDelay_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_transitionDelay::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_transition_delay<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Transition_delay();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_transition_delay<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetTransition_delay(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn transition_delay_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_transition_delay::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn transition_delay_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_transition_delay::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_flex<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Flex();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_flex<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetFlex(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn flex_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_flex::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn flex_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_flex::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_flexFlow<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.FlexFlow();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_flexFlow<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetFlexFlow(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn flexFlow_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_flexFlow::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn flexFlow_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_flexFlow::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_flex_flow<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Flex_flow();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_flex_flow<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetFlex_flow(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn flex_flow_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_flex_flow::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn flex_flow_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_flex_flow::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_flexDirection<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.FlexDirection();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_flexDirection<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetFlexDirection(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn flexDirection_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_flexDirection::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn flexDirection_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_flexDirection::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_flex_direction<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Flex_direction();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_flex_direction<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetFlex_direction(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn flex_direction_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_flex_direction::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn flex_direction_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_flex_direction::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_flexWrap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.FlexWrap();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_flexWrap<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetFlexWrap(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn flexWrap_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_flexWrap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn flexWrap_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_flexWrap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_flex_wrap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Flex_wrap();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_flex_wrap<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetFlex_wrap(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn flex_wrap_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_flex_wrap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn flex_wrap_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_flex_wrap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_justifyContent<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.JustifyContent();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_justifyContent<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetJustifyContent(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn justifyContent_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_justifyContent::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn justifyContent_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_justifyContent::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_justify_content<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Justify_content();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_justify_content<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetJustify_content(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn justify_content_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_justify_content::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn justify_content_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_justify_content::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_alignItems<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.AlignItems();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_alignItems<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetAlignItems(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn alignItems_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_alignItems::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn alignItems_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_alignItems::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_align_items<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Align_items();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_align_items<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetAlign_items(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn align_items_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_align_items::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn align_items_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_align_items::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_alignContent<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.AlignContent();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_alignContent<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetAlignContent(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn alignContent_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_alignContent::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn alignContent_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_alignContent::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_align_content<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Align_content();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_align_content<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetAlign_content(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn align_content_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_align_content::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn align_content_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_align_content::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_order<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Order();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_order<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetOrder(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn order_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_order::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn order_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_order::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_flexBasis<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.FlexBasis();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_flexBasis<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetFlexBasis(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn flexBasis_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_flexBasis::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn flexBasis_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_flexBasis::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_flex_basis<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Flex_basis();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_flex_basis<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetFlex_basis(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn flex_basis_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_flex_basis::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn flex_basis_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_flex_basis::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_flexGrow<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.FlexGrow();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_flexGrow<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetFlexGrow(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn flexGrow_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_flexGrow::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn flexGrow_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_flexGrow::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_flex_grow<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Flex_grow();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_flex_grow<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetFlex_grow(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn flex_grow_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_flex_grow::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn flex_grow_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_flex_grow::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_flexShrink<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.FlexShrink();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_flexShrink<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetFlexShrink(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn flexShrink_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_flexShrink::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn flexShrink_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_flexShrink::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_flex_shrink<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Flex_shrink();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_flex_shrink<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetFlex_shrink(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn flex_shrink_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_flex_shrink::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn flex_shrink_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_flex_shrink::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_alignSelf<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.AlignSelf();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_alignSelf<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetAlignSelf(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn alignSelf_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_alignSelf::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn alignSelf_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_alignSelf::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_align_self<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Align_self();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_align_self<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetAlign_self(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn align_self_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_align_self::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn align_self_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_align_self::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_animation<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Animation();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animation<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetAnimation(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn animation_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_animation::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn animation_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_animation::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_animation_name<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Animation_name();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animation_name<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetAnimation_name(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn animation_name_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_animation_name::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn animation_name_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_animation_name::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_animationName<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.AnimationName();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animationName<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetAnimationName(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn animationName_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_animationName::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn animationName_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_animationName::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_animation_duration<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Animation_duration();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animation_duration<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetAnimation_duration(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn animation_duration_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_animation_duration::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn animation_duration_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_animation_duration::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_animationDuration<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.AnimationDuration();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animationDuration<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetAnimationDuration(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn animationDuration_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_animationDuration::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn animationDuration_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_animationDuration::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_animation_timing_function<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Animation_timing_function();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animation_timing_function<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetAnimation_timing_function(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn animation_timing_function_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_animation_timing_function::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn animation_timing_function_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_animation_timing_function::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_animationTimingFunction<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.AnimationTimingFunction();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animationTimingFunction<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetAnimationTimingFunction(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn animationTimingFunction_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_animationTimingFunction::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn animationTimingFunction_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_animationTimingFunction::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_animation_iteration_count<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Animation_iteration_count();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animation_iteration_count<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetAnimation_iteration_count(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn animation_iteration_count_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_animation_iteration_count::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn animation_iteration_count_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_animation_iteration_count::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_animationIterationCount<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.AnimationIterationCount();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animationIterationCount<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetAnimationIterationCount(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn animationIterationCount_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_animationIterationCount::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn animationIterationCount_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_animationIterationCount::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_animation_direction<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Animation_direction();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animation_direction<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetAnimation_direction(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn animation_direction_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_animation_direction::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn animation_direction_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_animation_direction::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_animationDirection<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.AnimationDirection();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animationDirection<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetAnimationDirection(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn animationDirection_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_animationDirection::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn animationDirection_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_animationDirection::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_animation_play_state<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Animation_play_state();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animation_play_state<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetAnimation_play_state(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn animation_play_state_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_animation_play_state::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn animation_play_state_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_animation_play_state::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_animationPlayState<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.AnimationPlayState();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animationPlayState<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetAnimationPlayState(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn animationPlayState_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_animationPlayState::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn animationPlayState_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_animationPlayState::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_animation_fill_mode<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Animation_fill_mode();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animation_fill_mode<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetAnimation_fill_mode(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn animation_fill_mode_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_animation_fill_mode::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn animation_fill_mode_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_animation_fill_mode::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_animationFillMode<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.AnimationFillMode();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animationFillMode<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetAnimationFillMode(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn animationFillMode_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_animationFillMode::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn animationFillMode_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_animationFillMode::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_animation_delay<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Animation_delay();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animation_delay<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetAnimation_delay(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn animation_delay_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_animation_delay::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn animation_delay_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_animation_delay::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_animationDelay<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.AnimationDelay();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_animationDelay<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const CSSStyleDeclaration<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetAnimationDelay(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn animationDelay_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_animationDelay::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn animationDelay_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_animationDelay::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::CSSStyleDeclaration as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn _finalize<TH: TypeHolderTrait>
(_fop: *mut JSFreeOp, obj: *mut JSObject) {
    return wrap_panic(panic::AssertUnwindSafe(|| {

        let this = native_from_object::<CSSStyleDeclaration<TH>, TH>(obj).unwrap();
            if !this.is_null() {
                // The pointer can be null if the object is the unforgeable holder of that interface.
                let _ = Box::from_raw(this as *mut CSSStyleDeclaration<TH>);
            }
            debug!("CSSStyleDeclaration<TH> finalize: {:p}", this);
    }), ());
}

unsafe extern fn _trace<TH: TypeHolderTrait>
(trc: *mut JSTracer, obj: *mut JSObject) {
    return wrap_panic(panic::AssertUnwindSafe(|| {

        let this = native_from_object::<CSSStyleDeclaration<TH>, TH>(obj).unwrap();
        if this.is_null() { return; } // GC during obj creation
        (*this).trace(trc);
    }), ());
}

pub unsafe fn DefineProxyHandler<TH: TypeHolderTrait>
() -> *const libc::c_void {
    let traps = ProxyTraps {
        enter: None,
        getOwnPropertyDescriptor: Some(getOwnPropertyDescriptor),
        defineProperty: Some(proxyhandler::define_property),
        ownPropertyKeys: Some(own_property_keys),
        delete_: Some(proxyhandler::delete),
        enumerate: None,
        getPrototypeIfOrdinary: Some(proxyhandler::get_prototype_if_ordinary),
        preventExtensions: Some(proxyhandler::prevent_extensions),
        isExtensible: Some(proxyhandler::is_extensible),
        has: None,
        get: Some(get),
        set: None,
        call: None,
        construct: None,
        getPropertyDescriptor: Some(get_property_descriptor),
        hasOwn: Some(hasOwn),
        getOwnEnumerablePropertyKeys: Some(own_property_keys),
        nativeCall: None,
        hasInstance: None,
        objectClassIs: None,
        className: Some(className),
        fun_toString: None,
        boxedValue_unbox: None,
        defaultValue: None,
        trace: Some(_trace::<TH>),
        finalize: Some(_finalize::<TH>),
        objectMoved: None,
        isCallable: None,
        isConstructor: None,
    };

    CreateProxyHandler(&traps, Class::<TH>().as_void_ptr())
}

#[inline] unsafe fn UnwrapProxy<TH: TypeHolderTrait>
(obj: RawHandleObject) -> *const CSSStyleDeclaration<TH> {
    /*if (xpc::WrapperFactory::IsXrayWrapper(obj)) {
        obj = js::UnwrapObject(obj);
    }*/
    //MOZ_ASSERT(IsProxy(obj));
    let box_ = GetProxyPrivate(obj.get()).to_private() as *const CSSStyleDeclaration<TH>;
    return box_;
}

fn Class<TH: TypeHolderTrait>() -> DOMClass { DOMClass {
    interface_chain: [ PrototypeList::ID::CSSStyleDeclaration, PrototypeList::ID::Last, PrototypeList::ID::Last, PrototypeList::ID::Last, PrototypeList::ID::Last, PrototypeList::ID::Last ],
    type_id: ::dom::bindings::codegen::InheritTypes::TopTypeId { alone: () },
    global: InterfaceObjectMap::Globals::EMPTY,
   	malloc_size_of: malloc_size_of_including_raw_self::<CSSStyleDeclaration<TH>> as unsafe fn(&mut _, _) -> _,
}}

unsafe extern fn own_property_keys<TH: TypeHolderTrait>
(cx: *mut JSContext, proxy: RawHandleObject, props: *mut AutoIdVector) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let unwrapped_proxy = UnwrapProxy(proxy);
        for i in 0..(*unwrapped_proxy).Length() {
            rooted!(in(cx) let rooted_jsid = int_to_jsid(i as i32));
            AppendToAutoIdVector(props, rooted_jsid.handle().get());
        }
        rooted!(in(cx) let mut expando = ptr::null_mut::<JSObject>());
        get_expando_object(proxy, expando.handle_mut());
        if !expando.is_null() {
            GetPropertyKeys(cx, expando.handle(), JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, props);
        }

        return true;

    }), false);
}

unsafe extern fn getOwnPropertyDescriptor<TH: TypeHolderTrait>
(cx: *mut JSContext, proxy: RawHandleObject, id: RawHandleId, desc: RawMutableHandle<PropertyDescriptor>) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let index = get_array_index_from_id(cx, Handle::from_raw(id));
        if let Some(index) = index {
            let this = UnwrapProxy(proxy);
            let this = &*this;
            let result: Option<DOMString> = this.IndexedGetter(index);

            if let Some(result) = result {
                rooted!(in(cx) let mut result_root = UndefinedValue());
                (result).to_jsval(cx, result_root.handle_mut());
                desc.get().value = result_root.get();
                fill_property_descriptor(MutableHandle::from_raw(desc), proxy.get(), JSPROP_ENUMERATE | JSPROP_READONLY);
                return true;
            }
        }
        rooted!(in(cx) let mut expando = ptr::null_mut::<JSObject>());
        get_expando_object(proxy, expando.handle_mut());
        //if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = GetExpandoObject(proxy))) {
        let proxy_lt = Handle::from_raw(proxy);
        let id_lt = Handle::from_raw(id);
        if !expando.is_null() {
            if !JS_GetPropertyDescriptorById(cx, expando.handle().into(), id, desc) {
                return false;
            }
            if !desc.obj.is_null() {
                // Pretend the property lives on the wrapper.
                desc.get().obj = proxy.get();
                return true;
            }
        }
        desc.get().obj = ptr::null_mut();
        return true;
    }), false);
}

unsafe extern fn className<TH: TypeHolderTrait>
(cx: *mut JSContext, _proxy: RawHandleObject) -> *const i8 {
    b"CSSStyleDeclaration\0" as *const u8 as *const i8
}

unsafe extern fn get<TH: TypeHolderTrait>
(cx: *mut JSContext, proxy: RawHandleObject, receiver: RawHandleValue, id: RawHandleId, vp: RawMutableHandleValue) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        //MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
        //"Should not have a XrayWrapper here");
        let proxy_lt = Handle::from_raw(proxy);
        let vp_lt = MutableHandle::from_raw(vp);
        let id_lt = Handle::from_raw(id);
        let receiver_lt = Handle::from_raw(receiver);

        let index = get_array_index_from_id(cx, id_lt);
        if let Some(index) = index {
            let this = UnwrapProxy(proxy);
            let this = &*this;
            let result: Option<DOMString> = this.IndexedGetter(index);

            if let Some(result) = result {

                (result).to_jsval(cx, vp_lt);
                return true;
            }    // Even if we don't have this index, we don't forward the
            // get on to our expando object.
        } else {
            rooted!(in(cx) let mut expando = ptr::null_mut::<JSObject>());
            get_expando_object(proxy, expando.handle_mut());
            if !expando.is_null() {
                let mut hasProp = false;
                if !JS_HasPropertyById(cx, expando.handle().into(), id, &mut hasProp) {
                    return false;
                }

                if hasProp {
                    return JS_ForwardGetPropertyTo(cx, expando.handle().into(), id, receiver, vp);
                }
            }
        }

        let mut found = false;
        if !get_property_on_prototype(cx, proxy_lt, receiver_lt, id_lt, &mut found, vp_lt) {
            return false;
        }

        if found {
            return true;
        }

        vp.set(UndefinedValue());
        return true;
    }), false);
}

unsafe extern fn hasOwn<TH: TypeHolderTrait>
(cx: *mut JSContext, proxy: RawHandleObject, id: RawHandleId, bp: *mut bool) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let index = get_array_index_from_id(cx, Handle::from_raw(id));
        if let Some(index) = index {
            let this = UnwrapProxy(proxy);
            let this = &*this;
            let result: Option<DOMString> = this.IndexedGetter(index);

            *bp = result.is_some();
            return true;
        }

        rooted!(in(cx) let mut expando = ptr::null_mut::<JSObject>());
        let proxy_lt = Handle::from_raw(proxy);
        let id_lt = Handle::from_raw(id);
        get_expando_object(proxy, expando.handle_mut());
        if !expando.is_null() {
            let ok = JS_HasPropertyById(cx, expando.handle().into(), id, bp);
            if !ok || *bp {
                return ok;
            }
        }
        *bp = false;
        return true;
    }), false);
}

pub unsafe fn Wrap<TH: TypeHolderTrait>
(cx: *mut JSContext, scope: &GlobalScope<TH>, object: Box<CSSStyleDeclaration<TH>>) -> DomRoot<CSSStyleDeclaration<TH>> {
    let scope = scope.reflector().get_jsobject();
    assert!(!scope.get().is_null());
    assert!(((*get_object_class(scope.get())).flags & JSCLASS_IS_GLOBAL) != 0);

    rooted!(in(cx) let mut proto = ptr::null_mut::<JSObject>());
    let _ac = JSAutoCompartment::new(cx, scope.get());
    GetProtoObject(cx, scope, proto.handle_mut());
    assert!(!proto.is_null());

    let raw = Box::into_raw(object);
    let _rt = RootedTraceable::new(&*raw);

    let handler = RegisterBindings::PROXY_HANDLERS[PrototypeList::Proxies::CSSStyleDeclaration as usize];
    rooted!(in(cx) let private = PrivateValue(raw as *const libc::c_void));
    let obj = NewProxyObject(cx, handler,
                             private.handle(),
                             proto.get(), scope.get(),
                             ptr::null_mut(), ptr::null_mut());
    assert!(!obj.is_null());
    rooted!(in(cx) let obj = obj);


    (*raw).init_reflector(obj.get());

    DomRoot::from_ref(&*raw)
}

impl<TH: TypeHolderTrait> IDLInterface for CSSStyleDeclaration<TH> {
    #[inline]
    fn derives(class: &'static DOMClass) -> bool {
        class as *const _ == &Class as *const _
    }
}

impl<TH: TypeHolderTrait> PartialEq for CSSStyleDeclaration<TH> {
    fn eq(&self, other: &CSSStyleDeclaration<TH>) -> bool {
        self as *const CSSStyleDeclaration<TH> == &*other
    }
}

pub trait CSSStyleDeclarationMethods<TH: TypeHolderTrait> {
    fn CssText(&self) -> DOMString;
    fn SetCssText(&self, value: DOMString) -> ErrorResult<TH>;
    fn Length(&self) -> u32;
    fn Item(&self, index: u32) -> DOMString;
    fn GetPropertyValue(&self, property: DOMString) -> DOMString;
    fn GetPropertyPriority(&self, property: DOMString) -> DOMString;
    fn SetProperty(&self, property: DOMString, value: DOMString, priority: DOMString) -> Fallible<(), TH>;
    fn SetPropertyValue(&self, property: DOMString, value: DOMString) -> Fallible<(), TH>;
    fn SetPropertyPriority(&self, property: DOMString, priority: DOMString) -> Fallible<(), TH>;
    fn RemoveProperty(&self, property: DOMString) -> Fallible<DOMString, TH>;
    fn CssFloat(&self) -> DOMString;
    fn SetCssFloat(&self, value: DOMString) -> ErrorResult<TH>;
    fn All(&self) -> DOMString;
    fn SetAll(&self, value: DOMString) -> ErrorResult<TH>;
    fn Background(&self) -> DOMString;
    fn SetBackground(&self, value: DOMString) -> ErrorResult<TH>;
    fn BackgroundColor(&self) -> DOMString;
    fn SetBackgroundColor(&self, value: DOMString) -> ErrorResult<TH>;
    fn Background_color(&self) -> DOMString;
    fn SetBackground_color(&self, value: DOMString) -> ErrorResult<TH>;
    fn BackgroundPosition(&self) -> DOMString;
    fn SetBackgroundPosition(&self, value: DOMString) -> ErrorResult<TH>;
    fn Background_position(&self) -> DOMString;
    fn SetBackground_position(&self, value: DOMString) -> ErrorResult<TH>;
    fn BackgroundPositionX(&self) -> DOMString;
    fn SetBackgroundPositionX(&self, value: DOMString) -> ErrorResult<TH>;
    fn Background_position_x(&self) -> DOMString;
    fn SetBackground_position_x(&self, value: DOMString) -> ErrorResult<TH>;
    fn BackgroundPositionY(&self) -> DOMString;
    fn SetBackgroundPositionY(&self, value: DOMString) -> ErrorResult<TH>;
    fn Background_position_y(&self) -> DOMString;
    fn SetBackground_position_y(&self, value: DOMString) -> ErrorResult<TH>;
    fn BackgroundRepeat(&self) -> DOMString;
    fn SetBackgroundRepeat(&self, value: DOMString) -> ErrorResult<TH>;
    fn Background_repeat(&self) -> DOMString;
    fn SetBackground_repeat(&self, value: DOMString) -> ErrorResult<TH>;
    fn BackgroundImage(&self) -> DOMString;
    fn SetBackgroundImage(&self, value: DOMString) -> ErrorResult<TH>;
    fn Background_image(&self) -> DOMString;
    fn SetBackground_image(&self, value: DOMString) -> ErrorResult<TH>;
    fn BackgroundAttachment(&self) -> DOMString;
    fn SetBackgroundAttachment(&self, value: DOMString) -> ErrorResult<TH>;
    fn Background_attachment(&self) -> DOMString;
    fn SetBackground_attachment(&self, value: DOMString) -> ErrorResult<TH>;
    fn BackgroundSize(&self) -> DOMString;
    fn SetBackgroundSize(&self, value: DOMString) -> ErrorResult<TH>;
    fn Background_size(&self) -> DOMString;
    fn SetBackground_size(&self, value: DOMString) -> ErrorResult<TH>;
    fn BackgroundOrigin(&self) -> DOMString;
    fn SetBackgroundOrigin(&self, value: DOMString) -> ErrorResult<TH>;
    fn Background_origin(&self) -> DOMString;
    fn SetBackground_origin(&self, value: DOMString) -> ErrorResult<TH>;
    fn BackgroundClip(&self) -> DOMString;
    fn SetBackgroundClip(&self, value: DOMString) -> ErrorResult<TH>;
    fn Background_clip(&self) -> DOMString;
    fn SetBackground_clip(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border(&self) -> DOMString;
    fn SetBorder(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderColor(&self) -> DOMString;
    fn SetBorderColor(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_color(&self) -> DOMString;
    fn SetBorder_color(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderRadius(&self) -> DOMString;
    fn SetBorderRadius(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_radius(&self) -> DOMString;
    fn SetBorder_radius(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderSpacing(&self) -> DOMString;
    fn SetBorderSpacing(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_spacing(&self) -> DOMString;
    fn SetBorder_spacing(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderStyle(&self) -> DOMString;
    fn SetBorderStyle(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_style(&self) -> DOMString;
    fn SetBorder_style(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderWidth(&self) -> DOMString;
    fn SetBorderWidth(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_width(&self) -> DOMString;
    fn SetBorder_width(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderBottom(&self) -> DOMString;
    fn SetBorderBottom(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_bottom(&self) -> DOMString;
    fn SetBorder_bottom(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderBottomColor(&self) -> DOMString;
    fn SetBorderBottomColor(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_bottom_color(&self) -> DOMString;
    fn SetBorder_bottom_color(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderBottomLeftRadius(&self) -> DOMString;
    fn SetBorderBottomLeftRadius(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_bottom_left_radius(&self) -> DOMString;
    fn SetBorder_bottom_left_radius(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderBottomRightRadius(&self) -> DOMString;
    fn SetBorderBottomRightRadius(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_bottom_right_radius(&self) -> DOMString;
    fn SetBorder_bottom_right_radius(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderBottomStyle(&self) -> DOMString;
    fn SetBorderBottomStyle(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_bottom_style(&self) -> DOMString;
    fn SetBorder_bottom_style(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderBottomWidth(&self) -> DOMString;
    fn SetBorderBottomWidth(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_bottom_width(&self) -> DOMString;
    fn SetBorder_bottom_width(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderLeft(&self) -> DOMString;
    fn SetBorderLeft(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_left(&self) -> DOMString;
    fn SetBorder_left(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderLeftColor(&self) -> DOMString;
    fn SetBorderLeftColor(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_left_color(&self) -> DOMString;
    fn SetBorder_left_color(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderLeftStyle(&self) -> DOMString;
    fn SetBorderLeftStyle(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_left_style(&self) -> DOMString;
    fn SetBorder_left_style(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderLeftWidth(&self) -> DOMString;
    fn SetBorderLeftWidth(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_left_width(&self) -> DOMString;
    fn SetBorder_left_width(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderRight(&self) -> DOMString;
    fn SetBorderRight(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_right(&self) -> DOMString;
    fn SetBorder_right(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderRightColor(&self) -> DOMString;
    fn SetBorderRightColor(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_right_color(&self) -> DOMString;
    fn SetBorder_right_color(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderRightStyle(&self) -> DOMString;
    fn SetBorderRightStyle(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_right_style(&self) -> DOMString;
    fn SetBorder_right_style(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderRightWidth(&self) -> DOMString;
    fn SetBorderRightWidth(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_right_width(&self) -> DOMString;
    fn SetBorder_right_width(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderTop(&self) -> DOMString;
    fn SetBorderTop(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_top(&self) -> DOMString;
    fn SetBorder_top(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderTopColor(&self) -> DOMString;
    fn SetBorderTopColor(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_top_color(&self) -> DOMString;
    fn SetBorder_top_color(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderTopLeftRadius(&self) -> DOMString;
    fn SetBorderTopLeftRadius(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_top_left_radius(&self) -> DOMString;
    fn SetBorder_top_left_radius(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderTopRightRadius(&self) -> DOMString;
    fn SetBorderTopRightRadius(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_top_right_radius(&self) -> DOMString;
    fn SetBorder_top_right_radius(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderTopStyle(&self) -> DOMString;
    fn SetBorderTopStyle(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_top_style(&self) -> DOMString;
    fn SetBorder_top_style(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderTopWidth(&self) -> DOMString;
    fn SetBorderTopWidth(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_top_width(&self) -> DOMString;
    fn SetBorder_top_width(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_image_source(&self) -> DOMString;
    fn SetBorder_image_source(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderImageSource(&self) -> DOMString;
    fn SetBorderImageSource(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_image_slice(&self) -> DOMString;
    fn SetBorder_image_slice(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderImageSlice(&self) -> DOMString;
    fn SetBorderImageSlice(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_image_repeat(&self) -> DOMString;
    fn SetBorder_image_repeat(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderImageRepeat(&self) -> DOMString;
    fn SetBorderImageRepeat(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_image_outset(&self) -> DOMString;
    fn SetBorder_image_outset(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderImageOutset(&self) -> DOMString;
    fn SetBorderImageOutset(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_image_width(&self) -> DOMString;
    fn SetBorder_image_width(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderImageWidth(&self) -> DOMString;
    fn SetBorderImageWidth(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_image(&self) -> DOMString;
    fn SetBorder_image(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderImage(&self) -> DOMString;
    fn SetBorderImage(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_block_start_color(&self) -> DOMString;
    fn SetBorder_block_start_color(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderBlockStartColor(&self) -> DOMString;
    fn SetBorderBlockStartColor(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_block_start_width(&self) -> DOMString;
    fn SetBorder_block_start_width(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderBlockStartWidth(&self) -> DOMString;
    fn SetBorderBlockStartWidth(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_block_start_style(&self) -> DOMString;
    fn SetBorder_block_start_style(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderBlockStartStyle(&self) -> DOMString;
    fn SetBorderBlockStartStyle(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_block_end_color(&self) -> DOMString;
    fn SetBorder_block_end_color(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderBlockEndColor(&self) -> DOMString;
    fn SetBorderBlockEndColor(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_block_end_width(&self) -> DOMString;
    fn SetBorder_block_end_width(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderBlockEndWidth(&self) -> DOMString;
    fn SetBorderBlockEndWidth(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_block_end_style(&self) -> DOMString;
    fn SetBorder_block_end_style(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderBlockEndStyle(&self) -> DOMString;
    fn SetBorderBlockEndStyle(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_inline_start_color(&self) -> DOMString;
    fn SetBorder_inline_start_color(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderInlineStartColor(&self) -> DOMString;
    fn SetBorderInlineStartColor(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_inline_start_width(&self) -> DOMString;
    fn SetBorder_inline_start_width(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderInlineStartWidth(&self) -> DOMString;
    fn SetBorderInlineStartWidth(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_inline_start_style(&self) -> DOMString;
    fn SetBorder_inline_start_style(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderInlineStartStyle(&self) -> DOMString;
    fn SetBorderInlineStartStyle(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_inline_end_color(&self) -> DOMString;
    fn SetBorder_inline_end_color(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderInlineEndColor(&self) -> DOMString;
    fn SetBorderInlineEndColor(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_inline_end_width(&self) -> DOMString;
    fn SetBorder_inline_end_width(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderInlineEndWidth(&self) -> DOMString;
    fn SetBorderInlineEndWidth(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_inline_end_style(&self) -> DOMString;
    fn SetBorder_inline_end_style(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderInlineEndStyle(&self) -> DOMString;
    fn SetBorderInlineEndStyle(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_block_start(&self) -> DOMString;
    fn SetBorder_block_start(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderBlockStart(&self) -> DOMString;
    fn SetBorderBlockStart(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_block_end(&self) -> DOMString;
    fn SetBorder_block_end(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderBlockEnd(&self) -> DOMString;
    fn SetBorderBlockEnd(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_inline_start(&self) -> DOMString;
    fn SetBorder_inline_start(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderInlineStart(&self) -> DOMString;
    fn SetBorderInlineStart(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_inline_end(&self) -> DOMString;
    fn SetBorder_inline_end(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderInlineEnd(&self) -> DOMString;
    fn SetBorderInlineEnd(&self, value: DOMString) -> ErrorResult<TH>;
    fn Content(&self) -> DOMString;
    fn SetContent(&self, value: DOMString) -> ErrorResult<TH>;
    fn Color(&self) -> DOMString;
    fn SetColor(&self, value: DOMString) -> ErrorResult<TH>;
    fn Display(&self) -> DOMString;
    fn SetDisplay(&self, value: DOMString) -> ErrorResult<TH>;
    fn Opacity(&self) -> DOMString;
    fn SetOpacity(&self, value: DOMString) -> ErrorResult<TH>;
    fn Visibility(&self) -> DOMString;
    fn SetVisibility(&self, value: DOMString) -> ErrorResult<TH>;
    fn Cursor(&self) -> DOMString;
    fn SetCursor(&self, value: DOMString) -> ErrorResult<TH>;
    fn BoxSizing(&self) -> DOMString;
    fn SetBoxSizing(&self, value: DOMString) -> ErrorResult<TH>;
    fn Box_sizing(&self) -> DOMString;
    fn SetBox_sizing(&self, value: DOMString) -> ErrorResult<TH>;
    fn BoxShadow(&self) -> DOMString;
    fn SetBoxShadow(&self, value: DOMString) -> ErrorResult<TH>;
    fn Box_shadow(&self) -> DOMString;
    fn SetBox_shadow(&self, value: DOMString) -> ErrorResult<TH>;
    fn TextShadow(&self) -> DOMString;
    fn SetTextShadow(&self, value: DOMString) -> ErrorResult<TH>;
    fn Text_shadow(&self) -> DOMString;
    fn SetText_shadow(&self, value: DOMString) -> ErrorResult<TH>;
    fn Float(&self) -> DOMString;
    fn SetFloat(&self, value: DOMString) -> ErrorResult<TH>;
    fn Clear(&self) -> DOMString;
    fn SetClear(&self, value: DOMString) -> ErrorResult<TH>;
    fn Clip(&self) -> DOMString;
    fn SetClip(&self, value: DOMString) -> ErrorResult<TH>;
    fn Transform(&self) -> DOMString;
    fn SetTransform(&self, value: DOMString) -> ErrorResult<TH>;
    fn TransformOrigin(&self) -> DOMString;
    fn SetTransformOrigin(&self, value: DOMString) -> ErrorResult<TH>;
    fn Transform_origin(&self) -> DOMString;
    fn SetTransform_origin(&self, value: DOMString) -> ErrorResult<TH>;
    fn Perspective(&self) -> DOMString;
    fn SetPerspective(&self, value: DOMString) -> ErrorResult<TH>;
    fn PerspectiveOrigin(&self) -> DOMString;
    fn SetPerspectiveOrigin(&self, value: DOMString) -> ErrorResult<TH>;
    fn Perspective_origin(&self) -> DOMString;
    fn SetPerspective_origin(&self, value: DOMString) -> ErrorResult<TH>;
    fn TransformStyle(&self) -> DOMString;
    fn SetTransformStyle(&self, value: DOMString) -> ErrorResult<TH>;
    fn Transform_style(&self) -> DOMString;
    fn SetTransform_style(&self, value: DOMString) -> ErrorResult<TH>;
    fn BackfaceVisibility(&self) -> DOMString;
    fn SetBackfaceVisibility(&self, value: DOMString) -> ErrorResult<TH>;
    fn Backface_visibility(&self) -> DOMString;
    fn SetBackface_visibility(&self, value: DOMString) -> ErrorResult<TH>;
    fn Rotate(&self) -> DOMString;
    fn SetRotate(&self, value: DOMString) -> ErrorResult<TH>;
    fn Scale(&self) -> DOMString;
    fn SetScale(&self, value: DOMString) -> ErrorResult<TH>;
    fn Translate(&self) -> DOMString;
    fn SetTranslate(&self, value: DOMString) -> ErrorResult<TH>;
    fn Direction(&self) -> DOMString;
    fn SetDirection(&self, value: DOMString) -> ErrorResult<TH>;
    fn UnicodeBidi(&self) -> DOMString;
    fn SetUnicodeBidi(&self, value: DOMString) -> ErrorResult<TH>;
    fn Unicode_bidi(&self) -> DOMString;
    fn SetUnicode_bidi(&self, value: DOMString) -> ErrorResult<TH>;
    fn Filter(&self) -> DOMString;
    fn SetFilter(&self, value: DOMString) -> ErrorResult<TH>;
    fn LineHeight(&self) -> DOMString;
    fn SetLineHeight(&self, value: DOMString) -> ErrorResult<TH>;
    fn Line_height(&self) -> DOMString;
    fn SetLine_height(&self, value: DOMString) -> ErrorResult<TH>;
    fn MixBlendMode(&self) -> DOMString;
    fn SetMixBlendMode(&self, value: DOMString) -> ErrorResult<TH>;
    fn Mix_blend_mode(&self) -> DOMString;
    fn SetMix_blend_mode(&self, value: DOMString) -> ErrorResult<TH>;
    fn VerticalAlign(&self) -> DOMString;
    fn SetVerticalAlign(&self, value: DOMString) -> ErrorResult<TH>;
    fn Vertical_align(&self) -> DOMString;
    fn SetVertical_align(&self, value: DOMString) -> ErrorResult<TH>;
    fn ListStyle(&self) -> DOMString;
    fn SetListStyle(&self, value: DOMString) -> ErrorResult<TH>;
    fn List_style(&self) -> DOMString;
    fn SetList_style(&self, value: DOMString) -> ErrorResult<TH>;
    fn ListStylePosition(&self) -> DOMString;
    fn SetListStylePosition(&self, value: DOMString) -> ErrorResult<TH>;
    fn List_style_position(&self) -> DOMString;
    fn SetList_style_position(&self, value: DOMString) -> ErrorResult<TH>;
    fn ListStyleType(&self) -> DOMString;
    fn SetListStyleType(&self, value: DOMString) -> ErrorResult<TH>;
    fn List_style_type(&self) -> DOMString;
    fn SetList_style_type(&self, value: DOMString) -> ErrorResult<TH>;
    fn ListStyleImage(&self) -> DOMString;
    fn SetListStyleImage(&self, value: DOMString) -> ErrorResult<TH>;
    fn List_style_image(&self) -> DOMString;
    fn SetList_style_image(&self, value: DOMString) -> ErrorResult<TH>;
    fn Quotes(&self) -> DOMString;
    fn SetQuotes(&self, value: DOMString) -> ErrorResult<TH>;
    fn CounterIncrement(&self) -> DOMString;
    fn SetCounterIncrement(&self, value: DOMString) -> ErrorResult<TH>;
    fn Counter_increment(&self) -> DOMString;
    fn SetCounter_increment(&self, value: DOMString) -> ErrorResult<TH>;
    fn CounterReset(&self) -> DOMString;
    fn SetCounterReset(&self, value: DOMString) -> ErrorResult<TH>;
    fn Counter_reset(&self) -> DOMString;
    fn SetCounter_reset(&self, value: DOMString) -> ErrorResult<TH>;
    fn Overflow(&self) -> DOMString;
    fn SetOverflow(&self, value: DOMString) -> ErrorResult<TH>;
    fn OverflowX(&self) -> DOMString;
    fn SetOverflowX(&self, value: DOMString) -> ErrorResult<TH>;
    fn Overflow_x(&self) -> DOMString;
    fn SetOverflow_x(&self, value: DOMString) -> ErrorResult<TH>;
    fn OverflowY(&self) -> DOMString;
    fn SetOverflowY(&self, value: DOMString) -> ErrorResult<TH>;
    fn Overflow_y(&self) -> DOMString;
    fn SetOverflow_y(&self, value: DOMString) -> ErrorResult<TH>;
    fn OverflowWrap(&self) -> DOMString;
    fn SetOverflowWrap(&self, value: DOMString) -> ErrorResult<TH>;
    fn Overflow_wrap(&self) -> DOMString;
    fn SetOverflow_wrap(&self, value: DOMString) -> ErrorResult<TH>;
    fn TableLayout(&self) -> DOMString;
    fn SetTableLayout(&self, value: DOMString) -> ErrorResult<TH>;
    fn Table_layout(&self) -> DOMString;
    fn SetTable_layout(&self, value: DOMString) -> ErrorResult<TH>;
    fn BorderCollapse(&self) -> DOMString;
    fn SetBorderCollapse(&self, value: DOMString) -> ErrorResult<TH>;
    fn Border_collapse(&self) -> DOMString;
    fn SetBorder_collapse(&self, value: DOMString) -> ErrorResult<TH>;
    fn EmptyCells(&self) -> DOMString;
    fn SetEmptyCells(&self, value: DOMString) -> ErrorResult<TH>;
    fn Empty_cells(&self) -> DOMString;
    fn SetEmpty_cells(&self, value: DOMString) -> ErrorResult<TH>;
    fn CaptionSide(&self) -> DOMString;
    fn SetCaptionSide(&self, value: DOMString) -> ErrorResult<TH>;
    fn Caption_side(&self) -> DOMString;
    fn SetCaption_side(&self, value: DOMString) -> ErrorResult<TH>;
    fn WhiteSpace(&self) -> DOMString;
    fn SetWhiteSpace(&self, value: DOMString) -> ErrorResult<TH>;
    fn White_space(&self) -> DOMString;
    fn SetWhite_space(&self, value: DOMString) -> ErrorResult<TH>;
    fn WritingMode(&self) -> DOMString;
    fn SetWritingMode(&self, value: DOMString) -> ErrorResult<TH>;
    fn Writing_mode(&self) -> DOMString;
    fn SetWriting_mode(&self, value: DOMString) -> ErrorResult<TH>;
    fn LetterSpacing(&self) -> DOMString;
    fn SetLetterSpacing(&self, value: DOMString) -> ErrorResult<TH>;
    fn Letter_spacing(&self) -> DOMString;
    fn SetLetter_spacing(&self, value: DOMString) -> ErrorResult<TH>;
    fn WordBreak(&self) -> DOMString;
    fn SetWordBreak(&self, value: DOMString) -> ErrorResult<TH>;
    fn Word_break(&self) -> DOMString;
    fn SetWord_break(&self, value: DOMString) -> ErrorResult<TH>;
    fn WordSpacing(&self) -> DOMString;
    fn SetWordSpacing(&self, value: DOMString) -> ErrorResult<TH>;
    fn Word_spacing(&self) -> DOMString;
    fn SetWord_spacing(&self, value: DOMString) -> ErrorResult<TH>;
    fn WordWrap(&self) -> DOMString;
    fn SetWordWrap(&self, value: DOMString) -> ErrorResult<TH>;
    fn Word_wrap(&self) -> DOMString;
    fn SetWord_wrap(&self, value: DOMString) -> ErrorResult<TH>;
    fn TextOverflow(&self) -> DOMString;
    fn SetTextOverflow(&self, value: DOMString) -> ErrorResult<TH>;
    fn Text_overflow(&self) -> DOMString;
    fn SetText_overflow(&self, value: DOMString) -> ErrorResult<TH>;
    fn TextAlign(&self) -> DOMString;
    fn SetTextAlign(&self, value: DOMString) -> ErrorResult<TH>;
    fn Text_align(&self) -> DOMString;
    fn SetText_align(&self, value: DOMString) -> ErrorResult<TH>;
    fn TextDecoration(&self) -> DOMString;
    fn SetTextDecoration(&self, value: DOMString) -> ErrorResult<TH>;
    fn Text_decoration(&self) -> DOMString;
    fn SetText_decoration(&self, value: DOMString) -> ErrorResult<TH>;
    fn TextDecorationLine(&self) -> DOMString;
    fn SetTextDecorationLine(&self, value: DOMString) -> ErrorResult<TH>;
    fn Text_decoration_line(&self) -> DOMString;
    fn SetText_decoration_line(&self, value: DOMString) -> ErrorResult<TH>;
    fn TextIndent(&self) -> DOMString;
    fn SetTextIndent(&self, value: DOMString) -> ErrorResult<TH>;
    fn Text_indent(&self) -> DOMString;
    fn SetText_indent(&self, value: DOMString) -> ErrorResult<TH>;
    fn TextJustify(&self) -> DOMString;
    fn SetTextJustify(&self, value: DOMString) -> ErrorResult<TH>;
    fn Text_justify(&self) -> DOMString;
    fn SetText_justify(&self, value: DOMString) -> ErrorResult<TH>;
    fn TextRendering(&self) -> DOMString;
    fn SetTextRendering(&self, value: DOMString) -> ErrorResult<TH>;
    fn Text_rendering(&self) -> DOMString;
    fn SetText_rendering(&self, value: DOMString) -> ErrorResult<TH>;
    fn TextTransform(&self) -> DOMString;
    fn SetTextTransform(&self, value: DOMString) -> ErrorResult<TH>;
    fn Text_transform(&self) -> DOMString;
    fn SetText_transform(&self, value: DOMString) -> ErrorResult<TH>;
    fn Font(&self) -> DOMString;
    fn SetFont(&self, value: DOMString) -> ErrorResult<TH>;
    fn FontFamily(&self) -> DOMString;
    fn SetFontFamily(&self, value: DOMString) -> ErrorResult<TH>;
    fn Font_family(&self) -> DOMString;
    fn SetFont_family(&self, value: DOMString) -> ErrorResult<TH>;
    fn FontSize(&self) -> DOMString;
    fn SetFontSize(&self, value: DOMString) -> ErrorResult<TH>;
    fn Font_size(&self) -> DOMString;
    fn SetFont_size(&self, value: DOMString) -> ErrorResult<TH>;
    fn FontStretch(&self) -> DOMString;
    fn SetFontStretch(&self, value: DOMString) -> ErrorResult<TH>;
    fn Font_stretch(&self) -> DOMString;
    fn SetFont_stretch(&self, value: DOMString) -> ErrorResult<TH>;
    fn FontStyle(&self) -> DOMString;
    fn SetFontStyle(&self, value: DOMString) -> ErrorResult<TH>;
    fn Font_style(&self) -> DOMString;
    fn SetFont_style(&self, value: DOMString) -> ErrorResult<TH>;
    fn FontVariant(&self) -> DOMString;
    fn SetFontVariant(&self, value: DOMString) -> ErrorResult<TH>;
    fn Font_variant(&self) -> DOMString;
    fn SetFont_variant(&self, value: DOMString) -> ErrorResult<TH>;
    fn FontVariantCaps(&self) -> DOMString;
    fn SetFontVariantCaps(&self, value: DOMString) -> ErrorResult<TH>;
    fn Font_variant_caps(&self) -> DOMString;
    fn SetFont_variant_caps(&self, value: DOMString) -> ErrorResult<TH>;
    fn FontWeight(&self) -> DOMString;
    fn SetFontWeight(&self, value: DOMString) -> ErrorResult<TH>;
    fn Font_weight(&self) -> DOMString;
    fn SetFont_weight(&self, value: DOMString) -> ErrorResult<TH>;
    fn Margin(&self) -> DOMString;
    fn SetMargin(&self, value: DOMString) -> ErrorResult<TH>;
    fn MarginBottom(&self) -> DOMString;
    fn SetMarginBottom(&self, value: DOMString) -> ErrorResult<TH>;
    fn Margin_bottom(&self) -> DOMString;
    fn SetMargin_bottom(&self, value: DOMString) -> ErrorResult<TH>;
    fn MarginLeft(&self) -> DOMString;
    fn SetMarginLeft(&self, value: DOMString) -> ErrorResult<TH>;
    fn Margin_left(&self) -> DOMString;
    fn SetMargin_left(&self, value: DOMString) -> ErrorResult<TH>;
    fn MarginRight(&self) -> DOMString;
    fn SetMarginRight(&self, value: DOMString) -> ErrorResult<TH>;
    fn Margin_right(&self) -> DOMString;
    fn SetMargin_right(&self, value: DOMString) -> ErrorResult<TH>;
    fn MarginTop(&self) -> DOMString;
    fn SetMarginTop(&self, value: DOMString) -> ErrorResult<TH>;
    fn Margin_top(&self) -> DOMString;
    fn SetMargin_top(&self, value: DOMString) -> ErrorResult<TH>;
    fn Margin_block_start(&self) -> DOMString;
    fn SetMargin_block_start(&self, value: DOMString) -> ErrorResult<TH>;
    fn MarginBlockStart(&self) -> DOMString;
    fn SetMarginBlockStart(&self, value: DOMString) -> ErrorResult<TH>;
    fn Margin_block_end(&self) -> DOMString;
    fn SetMargin_block_end(&self, value: DOMString) -> ErrorResult<TH>;
    fn MarginBlockEnd(&self) -> DOMString;
    fn SetMarginBlockEnd(&self, value: DOMString) -> ErrorResult<TH>;
    fn Margin_inline_start(&self) -> DOMString;
    fn SetMargin_inline_start(&self, value: DOMString) -> ErrorResult<TH>;
    fn MarginInlineStart(&self) -> DOMString;
    fn SetMarginInlineStart(&self, value: DOMString) -> ErrorResult<TH>;
    fn Margin_inline_end(&self) -> DOMString;
    fn SetMargin_inline_end(&self, value: DOMString) -> ErrorResult<TH>;
    fn MarginInlineEnd(&self) -> DOMString;
    fn SetMarginInlineEnd(&self, value: DOMString) -> ErrorResult<TH>;
    fn Padding(&self) -> DOMString;
    fn SetPadding(&self, value: DOMString) -> ErrorResult<TH>;
    fn PaddingBottom(&self) -> DOMString;
    fn SetPaddingBottom(&self, value: DOMString) -> ErrorResult<TH>;
    fn Padding_bottom(&self) -> DOMString;
    fn SetPadding_bottom(&self, value: DOMString) -> ErrorResult<TH>;
    fn PaddingLeft(&self) -> DOMString;
    fn SetPaddingLeft(&self, value: DOMString) -> ErrorResult<TH>;
    fn Padding_left(&self) -> DOMString;
    fn SetPadding_left(&self, value: DOMString) -> ErrorResult<TH>;
    fn PaddingRight(&self) -> DOMString;
    fn SetPaddingRight(&self, value: DOMString) -> ErrorResult<TH>;
    fn Padding_right(&self) -> DOMString;
    fn SetPadding_right(&self, value: DOMString) -> ErrorResult<TH>;
    fn PaddingTop(&self) -> DOMString;
    fn SetPaddingTop(&self, value: DOMString) -> ErrorResult<TH>;
    fn Padding_top(&self) -> DOMString;
    fn SetPadding_top(&self, value: DOMString) -> ErrorResult<TH>;
    fn Padding_block_start(&self) -> DOMString;
    fn SetPadding_block_start(&self, value: DOMString) -> ErrorResult<TH>;
    fn PaddingBlockStart(&self) -> DOMString;
    fn SetPaddingBlockStart(&self, value: DOMString) -> ErrorResult<TH>;
    fn Padding_block_end(&self) -> DOMString;
    fn SetPadding_block_end(&self, value: DOMString) -> ErrorResult<TH>;
    fn PaddingBlockEnd(&self) -> DOMString;
    fn SetPaddingBlockEnd(&self, value: DOMString) -> ErrorResult<TH>;
    fn Padding_inline_start(&self) -> DOMString;
    fn SetPadding_inline_start(&self, value: DOMString) -> ErrorResult<TH>;
    fn PaddingInlineStart(&self) -> DOMString;
    fn SetPaddingInlineStart(&self, value: DOMString) -> ErrorResult<TH>;
    fn Padding_inline_end(&self) -> DOMString;
    fn SetPadding_inline_end(&self, value: DOMString) -> ErrorResult<TH>;
    fn PaddingInlineEnd(&self) -> DOMString;
    fn SetPaddingInlineEnd(&self, value: DOMString) -> ErrorResult<TH>;
    fn Outline(&self) -> DOMString;
    fn SetOutline(&self, value: DOMString) -> ErrorResult<TH>;
    fn OutlineColor(&self) -> DOMString;
    fn SetOutlineColor(&self, value: DOMString) -> ErrorResult<TH>;
    fn Outline_color(&self) -> DOMString;
    fn SetOutline_color(&self, value: DOMString) -> ErrorResult<TH>;
    fn OutlineStyle(&self) -> DOMString;
    fn SetOutlineStyle(&self, value: DOMString) -> ErrorResult<TH>;
    fn Outline_style(&self) -> DOMString;
    fn SetOutline_style(&self, value: DOMString) -> ErrorResult<TH>;
    fn OutlineWidth(&self) -> DOMString;
    fn SetOutlineWidth(&self, value: DOMString) -> ErrorResult<TH>;
    fn Outline_width(&self) -> DOMString;
    fn SetOutline_width(&self, value: DOMString) -> ErrorResult<TH>;
    fn OutlineOffset(&self) -> DOMString;
    fn SetOutlineOffset(&self, value: DOMString) -> ErrorResult<TH>;
    fn Outline_offset(&self) -> DOMString;
    fn SetOutline_offset(&self, value: DOMString) -> ErrorResult<TH>;
    fn Position(&self) -> DOMString;
    fn SetPosition(&self, value: DOMString) -> ErrorResult<TH>;
    fn PointerEvents(&self) -> DOMString;
    fn SetPointerEvents(&self, value: DOMString) -> ErrorResult<TH>;
    fn Pointer_events(&self) -> DOMString;
    fn SetPointer_events(&self, value: DOMString) -> ErrorResult<TH>;
    fn Top(&self) -> DOMString;
    fn SetTop(&self, value: DOMString) -> ErrorResult<TH>;
    fn Right(&self) -> DOMString;
    fn SetRight(&self, value: DOMString) -> ErrorResult<TH>;
    fn Left(&self) -> DOMString;
    fn SetLeft(&self, value: DOMString) -> ErrorResult<TH>;
    fn Bottom(&self) -> DOMString;
    fn SetBottom(&self, value: DOMString) -> ErrorResult<TH>;
    fn Offset_block_start(&self) -> DOMString;
    fn SetOffset_block_start(&self, value: DOMString) -> ErrorResult<TH>;
    fn OffsetBlockStart(&self) -> DOMString;
    fn SetOffsetBlockStart(&self, value: DOMString) -> ErrorResult<TH>;
    fn Offset_block_end(&self) -> DOMString;
    fn SetOffset_block_end(&self, value: DOMString) -> ErrorResult<TH>;
    fn OffsetBlockEnd(&self) -> DOMString;
    fn SetOffsetBlockEnd(&self, value: DOMString) -> ErrorResult<TH>;
    fn Offset_inline_start(&self) -> DOMString;
    fn SetOffset_inline_start(&self, value: DOMString) -> ErrorResult<TH>;
    fn OffsetInlineStart(&self) -> DOMString;
    fn SetOffsetInlineStart(&self, value: DOMString) -> ErrorResult<TH>;
    fn Offset_inline_end(&self) -> DOMString;
    fn SetOffset_inline_end(&self, value: DOMString) -> ErrorResult<TH>;
    fn OffsetInlineEnd(&self) -> DOMString;
    fn SetOffsetInlineEnd(&self, value: DOMString) -> ErrorResult<TH>;
    fn Height(&self) -> DOMString;
    fn SetHeight(&self, value: DOMString) -> ErrorResult<TH>;
    fn MinHeight(&self) -> DOMString;
    fn SetMinHeight(&self, value: DOMString) -> ErrorResult<TH>;
    fn Min_height(&self) -> DOMString;
    fn SetMin_height(&self, value: DOMString) -> ErrorResult<TH>;
    fn MaxHeight(&self) -> DOMString;
    fn SetMaxHeight(&self, value: DOMString) -> ErrorResult<TH>;
    fn Max_height(&self) -> DOMString;
    fn SetMax_height(&self, value: DOMString) -> ErrorResult<TH>;
    fn Width(&self) -> DOMString;
    fn SetWidth(&self, value: DOMString) -> ErrorResult<TH>;
    fn MinWidth(&self) -> DOMString;
    fn SetMinWidth(&self, value: DOMString) -> ErrorResult<TH>;
    fn Min_width(&self) -> DOMString;
    fn SetMin_width(&self, value: DOMString) -> ErrorResult<TH>;
    fn MaxWidth(&self) -> DOMString;
    fn SetMaxWidth(&self, value: DOMString) -> ErrorResult<TH>;
    fn Max_width(&self) -> DOMString;
    fn SetMax_width(&self, value: DOMString) -> ErrorResult<TH>;
    fn Block_size(&self) -> DOMString;
    fn SetBlock_size(&self, value: DOMString) -> ErrorResult<TH>;
    fn BlockSize(&self) -> DOMString;
    fn SetBlockSize(&self, value: DOMString) -> ErrorResult<TH>;
    fn Inline_size(&self) -> DOMString;
    fn SetInline_size(&self, value: DOMString) -> ErrorResult<TH>;
    fn InlineSize(&self) -> DOMString;
    fn SetInlineSize(&self, value: DOMString) -> ErrorResult<TH>;
    fn Max_block_size(&self) -> DOMString;
    fn SetMax_block_size(&self, value: DOMString) -> ErrorResult<TH>;
    fn MaxBlockSize(&self) -> DOMString;
    fn SetMaxBlockSize(&self, value: DOMString) -> ErrorResult<TH>;
    fn Max_inline_size(&self) -> DOMString;
    fn SetMax_inline_size(&self, value: DOMString) -> ErrorResult<TH>;
    fn MaxInlineSize(&self) -> DOMString;
    fn SetMaxInlineSize(&self, value: DOMString) -> ErrorResult<TH>;
    fn Min_block_size(&self) -> DOMString;
    fn SetMin_block_size(&self, value: DOMString) -> ErrorResult<TH>;
    fn MinBlockSize(&self) -> DOMString;
    fn SetMinBlockSize(&self, value: DOMString) -> ErrorResult<TH>;
    fn Min_inline_size(&self) -> DOMString;
    fn SetMin_inline_size(&self, value: DOMString) -> ErrorResult<TH>;
    fn MinInlineSize(&self) -> DOMString;
    fn SetMinInlineSize(&self, value: DOMString) -> ErrorResult<TH>;
    fn ZIndex(&self) -> DOMString;
    fn SetZIndex(&self, value: DOMString) -> ErrorResult<TH>;
    fn Z_index(&self) -> DOMString;
    fn SetZ_index(&self, value: DOMString) -> ErrorResult<TH>;
    fn ImageRendering(&self) -> DOMString;
    fn SetImageRendering(&self, value: DOMString) -> ErrorResult<TH>;
    fn Image_rendering(&self) -> DOMString;
    fn SetImage_rendering(&self, value: DOMString) -> ErrorResult<TH>;
    fn ColumnCount(&self) -> DOMString;
    fn SetColumnCount(&self, value: DOMString) -> ErrorResult<TH>;
    fn Column_count(&self) -> DOMString;
    fn SetColumn_count(&self, value: DOMString) -> ErrorResult<TH>;
    fn ColumnWidth(&self) -> DOMString;
    fn SetColumnWidth(&self, value: DOMString) -> ErrorResult<TH>;
    fn Column_width(&self) -> DOMString;
    fn SetColumn_width(&self, value: DOMString) -> ErrorResult<TH>;
    fn Columns(&self) -> DOMString;
    fn SetColumns(&self, value: DOMString) -> ErrorResult<TH>;
    fn ColumnGap(&self) -> DOMString;
    fn SetColumnGap(&self, value: DOMString) -> ErrorResult<TH>;
    fn Column_gap(&self) -> DOMString;
    fn SetColumn_gap(&self, value: DOMString) -> ErrorResult<TH>;
    fn Transition(&self) -> DOMString;
    fn SetTransition(&self, value: DOMString) -> ErrorResult<TH>;
    fn TransitionDuration(&self) -> DOMString;
    fn SetTransitionDuration(&self, value: DOMString) -> ErrorResult<TH>;
    fn Transition_duration(&self) -> DOMString;
    fn SetTransition_duration(&self, value: DOMString) -> ErrorResult<TH>;
    fn TransitionTimingFunction(&self) -> DOMString;
    fn SetTransitionTimingFunction(&self, value: DOMString) -> ErrorResult<TH>;
    fn Transition_timing_function(&self) -> DOMString;
    fn SetTransition_timing_function(&self, value: DOMString) -> ErrorResult<TH>;
    fn TransitionProperty(&self) -> DOMString;
    fn SetTransitionProperty(&self, value: DOMString) -> ErrorResult<TH>;
    fn Transition_property(&self) -> DOMString;
    fn SetTransition_property(&self, value: DOMString) -> ErrorResult<TH>;
    fn TransitionDelay(&self) -> DOMString;
    fn SetTransitionDelay(&self, value: DOMString) -> ErrorResult<TH>;
    fn Transition_delay(&self) -> DOMString;
    fn SetTransition_delay(&self, value: DOMString) -> ErrorResult<TH>;
    fn Flex(&self) -> DOMString;
    fn SetFlex(&self, value: DOMString) -> ErrorResult<TH>;
    fn FlexFlow(&self) -> DOMString;
    fn SetFlexFlow(&self, value: DOMString) -> ErrorResult<TH>;
    fn Flex_flow(&self) -> DOMString;
    fn SetFlex_flow(&self, value: DOMString) -> ErrorResult<TH>;
    fn FlexDirection(&self) -> DOMString;
    fn SetFlexDirection(&self, value: DOMString) -> ErrorResult<TH>;
    fn Flex_direction(&self) -> DOMString;
    fn SetFlex_direction(&self, value: DOMString) -> ErrorResult<TH>;
    fn FlexWrap(&self) -> DOMString;
    fn SetFlexWrap(&self, value: DOMString) -> ErrorResult<TH>;
    fn Flex_wrap(&self) -> DOMString;
    fn SetFlex_wrap(&self, value: DOMString) -> ErrorResult<TH>;
    fn JustifyContent(&self) -> DOMString;
    fn SetJustifyContent(&self, value: DOMString) -> ErrorResult<TH>;
    fn Justify_content(&self) -> DOMString;
    fn SetJustify_content(&self, value: DOMString) -> ErrorResult<TH>;
    fn AlignItems(&self) -> DOMString;
    fn SetAlignItems(&self, value: DOMString) -> ErrorResult<TH>;
    fn Align_items(&self) -> DOMString;
    fn SetAlign_items(&self, value: DOMString) -> ErrorResult<TH>;
    fn AlignContent(&self) -> DOMString;
    fn SetAlignContent(&self, value: DOMString) -> ErrorResult<TH>;
    fn Align_content(&self) -> DOMString;
    fn SetAlign_content(&self, value: DOMString) -> ErrorResult<TH>;
    fn Order(&self) -> DOMString;
    fn SetOrder(&self, value: DOMString) -> ErrorResult<TH>;
    fn FlexBasis(&self) -> DOMString;
    fn SetFlexBasis(&self, value: DOMString) -> ErrorResult<TH>;
    fn Flex_basis(&self) -> DOMString;
    fn SetFlex_basis(&self, value: DOMString) -> ErrorResult<TH>;
    fn FlexGrow(&self) -> DOMString;
    fn SetFlexGrow(&self, value: DOMString) -> ErrorResult<TH>;
    fn Flex_grow(&self) -> DOMString;
    fn SetFlex_grow(&self, value: DOMString) -> ErrorResult<TH>;
    fn FlexShrink(&self) -> DOMString;
    fn SetFlexShrink(&self, value: DOMString) -> ErrorResult<TH>;
    fn Flex_shrink(&self) -> DOMString;
    fn SetFlex_shrink(&self, value: DOMString) -> ErrorResult<TH>;
    fn AlignSelf(&self) -> DOMString;
    fn SetAlignSelf(&self, value: DOMString) -> ErrorResult<TH>;
    fn Align_self(&self) -> DOMString;
    fn SetAlign_self(&self, value: DOMString) -> ErrorResult<TH>;
    fn Animation(&self) -> DOMString;
    fn SetAnimation(&self, value: DOMString) -> ErrorResult<TH>;
    fn Animation_name(&self) -> DOMString;
    fn SetAnimation_name(&self, value: DOMString) -> ErrorResult<TH>;
    fn AnimationName(&self) -> DOMString;
    fn SetAnimationName(&self, value: DOMString) -> ErrorResult<TH>;
    fn Animation_duration(&self) -> DOMString;
    fn SetAnimation_duration(&self, value: DOMString) -> ErrorResult<TH>;
    fn AnimationDuration(&self) -> DOMString;
    fn SetAnimationDuration(&self, value: DOMString) -> ErrorResult<TH>;
    fn Animation_timing_function(&self) -> DOMString;
    fn SetAnimation_timing_function(&self, value: DOMString) -> ErrorResult<TH>;
    fn AnimationTimingFunction(&self) -> DOMString;
    fn SetAnimationTimingFunction(&self, value: DOMString) -> ErrorResult<TH>;
    fn Animation_iteration_count(&self) -> DOMString;
    fn SetAnimation_iteration_count(&self, value: DOMString) -> ErrorResult<TH>;
    fn AnimationIterationCount(&self) -> DOMString;
    fn SetAnimationIterationCount(&self, value: DOMString) -> ErrorResult<TH>;
    fn Animation_direction(&self) -> DOMString;
    fn SetAnimation_direction(&self, value: DOMString) -> ErrorResult<TH>;
    fn AnimationDirection(&self) -> DOMString;
    fn SetAnimationDirection(&self, value: DOMString) -> ErrorResult<TH>;
    fn Animation_play_state(&self) -> DOMString;
    fn SetAnimation_play_state(&self, value: DOMString) -> ErrorResult<TH>;
    fn AnimationPlayState(&self) -> DOMString;
    fn SetAnimationPlayState(&self, value: DOMString) -> ErrorResult<TH>;
    fn Animation_fill_mode(&self) -> DOMString;
    fn SetAnimation_fill_mode(&self, value: DOMString) -> ErrorResult<TH>;
    fn AnimationFillMode(&self) -> DOMString;
    fn SetAnimationFillMode(&self, value: DOMString) -> ErrorResult<TH>;
    fn Animation_delay(&self) -> DOMString;
    fn SetAnimation_delay(&self, value: DOMString) -> ErrorResult<TH>;
    fn AnimationDelay(&self) -> DOMString;
    fn SetAnimationDelay(&self, value: DOMString) -> ErrorResult<TH>;
    fn IndexedGetter(&self, index: u32) -> Option<DOMString>;
}
fn sMethods_specs<TH: TypeHolderTrait>() -> &'static [&'static[JSFunctionSpec]] { &[
&[
    JSFunctionSpec {
        name: b"item\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &item_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getPropertyValue\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getPropertyValue_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getPropertyPriority\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getPropertyPriority_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"setProperty\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &setProperty_methodinfo as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"setPropertyValue\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &setPropertyValue_methodinfo as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"setPropertyPriority\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &setPropertyPriority_methodinfo as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"removeProperty\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &removeProperty_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: (SymbolCode::iterator as i32 + 1) as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: b"ArrayValues\0" as *const u8 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]

]}
fn sMethods<TH: TypeHolderTrait>() -> &'static [Guard<&'static [JSFunctionSpec]>] { &[
    Guard::new(Condition::Satisfied, sMethods_specs::<TH>()[0])
]}
fn sAttributes_specs<TH: TypeHolderTrait>() -> &'static [&'static[JSPropertySpec]] { &[
&[
    JSPropertySpec {
        name: b"cssText\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &cssText_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &cssText_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"length\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &length_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"cssFloat\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &cssFloat_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &cssFloat_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"all\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &all_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &all_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"background\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &background_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &background_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"backgroundColor\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &backgroundColor_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &backgroundColor_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"background-color\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &background_color_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &background_color_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"backgroundPosition\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &backgroundPosition_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &backgroundPosition_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"background-position\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &background_position_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &background_position_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"backgroundPositionX\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &backgroundPositionX_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &backgroundPositionX_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"background-position-x\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &background_position_x_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &background_position_x_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"backgroundPositionY\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &backgroundPositionY_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &backgroundPositionY_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"background-position-y\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &background_position_y_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &background_position_y_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"backgroundRepeat\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &backgroundRepeat_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &backgroundRepeat_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"background-repeat\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &background_repeat_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &background_repeat_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"backgroundImage\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &backgroundImage_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &backgroundImage_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"background-image\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &background_image_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &background_image_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"backgroundAttachment\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &backgroundAttachment_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &backgroundAttachment_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"background-attachment\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &background_attachment_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &background_attachment_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"backgroundSize\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &backgroundSize_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &backgroundSize_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"background-size\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &background_size_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &background_size_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"backgroundOrigin\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &backgroundOrigin_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &backgroundOrigin_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"background-origin\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &background_origin_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &background_origin_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"backgroundClip\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &backgroundClip_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &backgroundClip_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"background-clip\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &background_clip_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &background_clip_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderColor\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderColor_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderColor_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-color\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_color_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_color_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderRadius\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderRadius_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderRadius_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-radius\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_radius_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_radius_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderSpacing\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderSpacing_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderSpacing_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-spacing\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_spacing_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_spacing_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderStyle\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderStyle_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderStyle_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-style\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_style_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_style_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderWidth_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderWidth_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-width\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_width_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_width_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderBottom\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderBottom_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderBottom_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-bottom\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_bottom_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_bottom_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderBottomColor\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderBottomColor_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderBottomColor_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-bottom-color\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_bottom_color_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_bottom_color_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderBottomLeftRadius\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderBottomLeftRadius_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderBottomLeftRadius_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-bottom-left-radius\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_bottom_left_radius_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_bottom_left_radius_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderBottomRightRadius\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderBottomRightRadius_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderBottomRightRadius_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-bottom-right-radius\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_bottom_right_radius_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_bottom_right_radius_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderBottomStyle\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderBottomStyle_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderBottomStyle_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-bottom-style\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_bottom_style_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_bottom_style_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderBottomWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderBottomWidth_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderBottomWidth_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-bottom-width\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_bottom_width_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_bottom_width_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderLeft\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderLeft_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderLeft_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-left\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_left_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_left_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderLeftColor\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderLeftColor_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderLeftColor_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-left-color\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_left_color_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_left_color_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderLeftStyle\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderLeftStyle_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderLeftStyle_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-left-style\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_left_style_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_left_style_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderLeftWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderLeftWidth_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderLeftWidth_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-left-width\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_left_width_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_left_width_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderRight\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderRight_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderRight_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-right\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_right_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_right_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderRightColor\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderRightColor_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderRightColor_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-right-color\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_right_color_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_right_color_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderRightStyle\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderRightStyle_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderRightStyle_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-right-style\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_right_style_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_right_style_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderRightWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderRightWidth_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderRightWidth_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-right-width\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_right_width_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_right_width_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderTop\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderTop_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderTop_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-top\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_top_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_top_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderTopColor\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderTopColor_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderTopColor_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-top-color\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_top_color_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_top_color_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderTopLeftRadius\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderTopLeftRadius_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderTopLeftRadius_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-top-left-radius\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_top_left_radius_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_top_left_radius_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderTopRightRadius\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderTopRightRadius_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderTopRightRadius_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-top-right-radius\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_top_right_radius_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_top_right_radius_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderTopStyle\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderTopStyle_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderTopStyle_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-top-style\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_top_style_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_top_style_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderTopWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderTopWidth_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderTopWidth_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-top-width\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_top_width_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_top_width_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-image-source\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_image_source_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_image_source_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderImageSource\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderImageSource_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderImageSource_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-image-slice\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_image_slice_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_image_slice_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderImageSlice\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderImageSlice_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderImageSlice_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-image-repeat\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_image_repeat_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_image_repeat_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderImageRepeat\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderImageRepeat_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderImageRepeat_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-image-outset\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_image_outset_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_image_outset_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderImageOutset\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderImageOutset_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderImageOutset_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-image-width\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_image_width_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_image_width_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderImageWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderImageWidth_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderImageWidth_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-image\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_image_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_image_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderImage\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderImage_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderImage_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-block-start-color\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_block_start_color_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_block_start_color_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderBlockStartColor\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderBlockStartColor_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderBlockStartColor_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-block-start-width\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_block_start_width_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_block_start_width_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderBlockStartWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderBlockStartWidth_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderBlockStartWidth_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-block-start-style\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_block_start_style_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_block_start_style_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderBlockStartStyle\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderBlockStartStyle_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderBlockStartStyle_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-block-end-color\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_block_end_color_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_block_end_color_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderBlockEndColor\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderBlockEndColor_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderBlockEndColor_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-block-end-width\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_block_end_width_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_block_end_width_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderBlockEndWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderBlockEndWidth_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderBlockEndWidth_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-block-end-style\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_block_end_style_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_block_end_style_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderBlockEndStyle\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderBlockEndStyle_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderBlockEndStyle_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-inline-start-color\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_inline_start_color_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_inline_start_color_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderInlineStartColor\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderInlineStartColor_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderInlineStartColor_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-inline-start-width\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_inline_start_width_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_inline_start_width_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderInlineStartWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderInlineStartWidth_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderInlineStartWidth_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-inline-start-style\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_inline_start_style_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_inline_start_style_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderInlineStartStyle\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderInlineStartStyle_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderInlineStartStyle_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-inline-end-color\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_inline_end_color_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_inline_end_color_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderInlineEndColor\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderInlineEndColor_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderInlineEndColor_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-inline-end-width\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_inline_end_width_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_inline_end_width_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderInlineEndWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderInlineEndWidth_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderInlineEndWidth_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-inline-end-style\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_inline_end_style_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_inline_end_style_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderInlineEndStyle\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderInlineEndStyle_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderInlineEndStyle_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-block-start\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_block_start_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_block_start_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderBlockStart\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderBlockStart_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderBlockStart_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-block-end\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_block_end_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_block_end_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderBlockEnd\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderBlockEnd_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderBlockEnd_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-inline-start\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_inline_start_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_inline_start_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderInlineStart\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderInlineStart_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderInlineStart_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-inline-end\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_inline_end_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_inline_end_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderInlineEnd\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderInlineEnd_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderInlineEnd_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"content\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &content_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &content_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"color\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &color_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &color_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"display\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &display_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &display_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"opacity\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &opacity_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &opacity_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"visibility\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &visibility_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &visibility_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"cursor\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &cursor_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &cursor_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"boxSizing\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &boxSizing_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &boxSizing_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"box-sizing\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &box_sizing_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &box_sizing_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"boxShadow\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &boxShadow_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &boxShadow_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"box-shadow\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &box_shadow_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &box_shadow_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"textShadow\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &textShadow_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &textShadow_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"text-shadow\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &text_shadow_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &text_shadow_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"float\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &float_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &float_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"clear\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &clear_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &clear_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"clip\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &clip_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &clip_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"transform\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &transform_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &transform_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"transformOrigin\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &transformOrigin_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &transformOrigin_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"transform-origin\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &transform_origin_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &transform_origin_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"perspective\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &perspective_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &perspective_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"perspectiveOrigin\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &perspectiveOrigin_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &perspectiveOrigin_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"perspective-origin\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &perspective_origin_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &perspective_origin_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"transformStyle\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &transformStyle_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &transformStyle_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"transform-style\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &transform_style_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &transform_style_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"backfaceVisibility\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &backfaceVisibility_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &backfaceVisibility_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"backface-visibility\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &backface_visibility_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &backface_visibility_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"rotate\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &rotate_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &rotate_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"scale\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &scale_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &scale_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"translate\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &translate_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &translate_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"direction\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &direction_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &direction_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"unicodeBidi\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &unicodeBidi_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &unicodeBidi_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"unicode-bidi\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &unicode_bidi_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &unicode_bidi_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"filter\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &filter_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &filter_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"lineHeight\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &lineHeight_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &lineHeight_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"line-height\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &line_height_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &line_height_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"mixBlendMode\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &mixBlendMode_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &mixBlendMode_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"mix-blend-mode\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &mix_blend_mode_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &mix_blend_mode_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"verticalAlign\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &verticalAlign_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &verticalAlign_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"vertical-align\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &vertical_align_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &vertical_align_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"listStyle\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &listStyle_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &listStyle_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"list-style\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &list_style_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &list_style_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"listStylePosition\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &listStylePosition_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &listStylePosition_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"list-style-position\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &list_style_position_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &list_style_position_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"listStyleType\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &listStyleType_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &listStyleType_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"list-style-type\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &list_style_type_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &list_style_type_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"listStyleImage\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &listStyleImage_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &listStyleImage_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"list-style-image\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &list_style_image_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &list_style_image_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"quotes\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &quotes_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &quotes_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"counterIncrement\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &counterIncrement_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &counterIncrement_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"counter-increment\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &counter_increment_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &counter_increment_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"counterReset\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &counterReset_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &counterReset_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"counter-reset\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &counter_reset_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &counter_reset_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"overflow\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &overflow_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &overflow_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"overflowX\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &overflowX_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &overflowX_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"overflow-x\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &overflow_x_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &overflow_x_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"overflowY\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &overflowY_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &overflowY_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"overflow-y\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &overflow_y_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &overflow_y_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"overflowWrap\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &overflowWrap_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &overflowWrap_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"overflow-wrap\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &overflow_wrap_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &overflow_wrap_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"tableLayout\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &tableLayout_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &tableLayout_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"table-layout\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &table_layout_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &table_layout_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"borderCollapse\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &borderCollapse_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &borderCollapse_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"border-collapse\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &border_collapse_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &border_collapse_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"emptyCells\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &emptyCells_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &emptyCells_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"empty-cells\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &empty_cells_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &empty_cells_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"captionSide\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &captionSide_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &captionSide_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"caption-side\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &caption_side_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &caption_side_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"whiteSpace\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &whiteSpace_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &whiteSpace_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"white-space\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &white_space_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &white_space_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]
,
&[
    JSPropertySpec {
        name: b"writingMode\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &writingMode_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &writingMode_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"writing-mode\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &writing_mode_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &writing_mode_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]
,
&[
    JSPropertySpec {
        name: b"letterSpacing\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &letterSpacing_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &letterSpacing_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"letter-spacing\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &letter_spacing_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &letter_spacing_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"wordBreak\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &wordBreak_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &wordBreak_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"word-break\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &word_break_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &word_break_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"wordSpacing\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &wordSpacing_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &wordSpacing_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"word-spacing\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &word_spacing_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &word_spacing_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"wordWrap\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &wordWrap_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &wordWrap_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"word-wrap\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &word_wrap_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &word_wrap_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"textOverflow\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &textOverflow_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &textOverflow_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"text-overflow\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &text_overflow_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &text_overflow_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"textAlign\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &textAlign_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &textAlign_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"text-align\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &text_align_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &text_align_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"textDecoration\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &textDecoration_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &textDecoration_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"text-decoration\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &text_decoration_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &text_decoration_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"textDecorationLine\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &textDecorationLine_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &textDecorationLine_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"text-decoration-line\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &text_decoration_line_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &text_decoration_line_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"textIndent\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &textIndent_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &textIndent_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"text-indent\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &text_indent_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &text_indent_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"textJustify\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &textJustify_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &textJustify_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"text-justify\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &text_justify_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &text_justify_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"textRendering\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &textRendering_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &textRendering_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"text-rendering\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &text_rendering_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &text_rendering_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"textTransform\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &textTransform_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &textTransform_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"text-transform\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &text_transform_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &text_transform_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"font\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &font_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &font_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"fontFamily\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &fontFamily_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &fontFamily_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"font-family\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &font_family_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &font_family_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"fontSize\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &fontSize_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &fontSize_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"font-size\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &font_size_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &font_size_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"fontStretch\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &fontStretch_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &fontStretch_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"font-stretch\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &font_stretch_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &font_stretch_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"fontStyle\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &fontStyle_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &fontStyle_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"font-style\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &font_style_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &font_style_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"fontVariant\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &fontVariant_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &fontVariant_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"font-variant\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &font_variant_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &font_variant_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"fontVariantCaps\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &fontVariantCaps_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &fontVariantCaps_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"font-variant-caps\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &font_variant_caps_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &font_variant_caps_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"fontWeight\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &fontWeight_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &fontWeight_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"font-weight\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &font_weight_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &font_weight_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"margin\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &margin_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &margin_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"marginBottom\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &marginBottom_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &marginBottom_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"margin-bottom\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &margin_bottom_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &margin_bottom_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"marginLeft\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &marginLeft_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &marginLeft_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"margin-left\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &margin_left_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &margin_left_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"marginRight\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &marginRight_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &marginRight_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"margin-right\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &margin_right_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &margin_right_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"marginTop\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &marginTop_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &marginTop_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"margin-top\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &margin_top_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &margin_top_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"margin-block-start\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &margin_block_start_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &margin_block_start_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"marginBlockStart\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &marginBlockStart_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &marginBlockStart_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"margin-block-end\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &margin_block_end_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &margin_block_end_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"marginBlockEnd\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &marginBlockEnd_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &marginBlockEnd_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"margin-inline-start\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &margin_inline_start_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &margin_inline_start_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"marginInlineStart\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &marginInlineStart_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &marginInlineStart_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"margin-inline-end\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &margin_inline_end_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &margin_inline_end_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"marginInlineEnd\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &marginInlineEnd_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &marginInlineEnd_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"padding\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &padding_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &padding_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"paddingBottom\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &paddingBottom_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &paddingBottom_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"padding-bottom\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &padding_bottom_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &padding_bottom_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"paddingLeft\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &paddingLeft_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &paddingLeft_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"padding-left\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &padding_left_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &padding_left_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"paddingRight\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &paddingRight_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &paddingRight_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"padding-right\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &padding_right_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &padding_right_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"paddingTop\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &paddingTop_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &paddingTop_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"padding-top\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &padding_top_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &padding_top_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"padding-block-start\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &padding_block_start_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &padding_block_start_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"paddingBlockStart\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &paddingBlockStart_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &paddingBlockStart_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"padding-block-end\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &padding_block_end_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &padding_block_end_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"paddingBlockEnd\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &paddingBlockEnd_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &paddingBlockEnd_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"padding-inline-start\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &padding_inline_start_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &padding_inline_start_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"paddingInlineStart\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &paddingInlineStart_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &paddingInlineStart_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"padding-inline-end\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &padding_inline_end_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &padding_inline_end_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"paddingInlineEnd\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &paddingInlineEnd_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &paddingInlineEnd_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"outline\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &outline_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &outline_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"outlineColor\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &outlineColor_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &outlineColor_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"outline-color\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &outline_color_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &outline_color_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"outlineStyle\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &outlineStyle_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &outlineStyle_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"outline-style\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &outline_style_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &outline_style_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"outlineWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &outlineWidth_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &outlineWidth_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"outline-width\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &outline_width_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &outline_width_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"outlineOffset\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &outlineOffset_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &outlineOffset_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"outline-offset\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &outline_offset_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &outline_offset_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"position\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &position_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &position_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"pointerEvents\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &pointerEvents_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &pointerEvents_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"pointer-events\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &pointer_events_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &pointer_events_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"top\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &top_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &top_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"right\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &right_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &right_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"left\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &left_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &left_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"bottom\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &bottom_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &bottom_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"offset-block-start\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &offset_block_start_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &offset_block_start_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"offsetBlockStart\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &offsetBlockStart_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &offsetBlockStart_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"offset-block-end\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &offset_block_end_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &offset_block_end_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"offsetBlockEnd\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &offsetBlockEnd_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &offsetBlockEnd_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"offset-inline-start\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &offset_inline_start_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &offset_inline_start_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"offsetInlineStart\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &offsetInlineStart_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &offsetInlineStart_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"offset-inline-end\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &offset_inline_end_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &offset_inline_end_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"offsetInlineEnd\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &offsetInlineEnd_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &offsetInlineEnd_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"height\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &height_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &height_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"minHeight\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &minHeight_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &minHeight_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"min-height\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &min_height_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &min_height_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"maxHeight\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &maxHeight_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &maxHeight_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"max-height\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &max_height_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &max_height_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"width\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &width_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &width_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"minWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &minWidth_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &minWidth_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"min-width\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &min_width_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &min_width_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"maxWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &maxWidth_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &maxWidth_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"max-width\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &max_width_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &max_width_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"block-size\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &block_size_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &block_size_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"blockSize\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &blockSize_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &blockSize_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"inline-size\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &inline_size_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &inline_size_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"inlineSize\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &inlineSize_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &inlineSize_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"max-block-size\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &max_block_size_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &max_block_size_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"maxBlockSize\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &maxBlockSize_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &maxBlockSize_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"max-inline-size\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &max_inline_size_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &max_inline_size_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"maxInlineSize\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &maxInlineSize_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &maxInlineSize_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"min-block-size\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &min_block_size_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &min_block_size_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"minBlockSize\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &minBlockSize_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &minBlockSize_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"min-inline-size\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &min_inline_size_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &min_inline_size_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"minInlineSize\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &minInlineSize_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &minInlineSize_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"zIndex\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &zIndex_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &zIndex_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"z-index\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &z_index_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &z_index_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"imageRendering\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &imageRendering_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &imageRendering_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"image-rendering\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &image_rendering_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &image_rendering_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]
,
&[
    JSPropertySpec {
        name: b"columnCount\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &columnCount_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &columnCount_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"column-count\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &column_count_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &column_count_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"columnWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &columnWidth_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &columnWidth_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"column-width\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &column_width_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &column_width_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"columns\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &columns_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &columns_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"columnGap\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &columnGap_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &columnGap_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"column-gap\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &column_gap_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &column_gap_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]
,
&[
    JSPropertySpec {
        name: b"transition\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &transition_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &transition_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"transitionDuration\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &transitionDuration_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &transitionDuration_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"transition-duration\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &transition_duration_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &transition_duration_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"transitionTimingFunction\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &transitionTimingFunction_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &transitionTimingFunction_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"transition-timing-function\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &transition_timing_function_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &transition_timing_function_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"transitionProperty\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &transitionProperty_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &transitionProperty_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"transition-property\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &transition_property_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &transition_property_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"transitionDelay\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &transitionDelay_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &transitionDelay_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"transition-delay\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &transition_delay_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &transition_delay_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"flex\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &flex_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &flex_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"flexFlow\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &flexFlow_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &flexFlow_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"flex-flow\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &flex_flow_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &flex_flow_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"flexDirection\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &flexDirection_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &flexDirection_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"flex-direction\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &flex_direction_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &flex_direction_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"flexWrap\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &flexWrap_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &flexWrap_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"flex-wrap\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &flex_wrap_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &flex_wrap_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"justifyContent\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &justifyContent_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &justifyContent_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"justify-content\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &justify_content_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &justify_content_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"alignItems\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &alignItems_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &alignItems_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"align-items\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &align_items_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &align_items_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"alignContent\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &alignContent_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &alignContent_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"align-content\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &align_content_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &align_content_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"order\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &order_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &order_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"flexBasis\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &flexBasis_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &flexBasis_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"flex-basis\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &flex_basis_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &flex_basis_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"flexGrow\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &flexGrow_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &flexGrow_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"flex-grow\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &flex_grow_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &flex_grow_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"flexShrink\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &flexShrink_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &flexShrink_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"flex-shrink\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &flex_shrink_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &flex_shrink_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"alignSelf\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &alignSelf_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &alignSelf_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"align-self\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &align_self_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &align_self_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"animation\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animation_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animation_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"animation-name\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animation_name_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animation_name_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"animationName\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animationName_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animationName_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"animation-duration\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animation_duration_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animation_duration_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"animationDuration\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animationDuration_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animationDuration_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"animation-timing-function\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animation_timing_function_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animation_timing_function_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"animationTimingFunction\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animationTimingFunction_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animationTimingFunction_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"animation-iteration-count\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animation_iteration_count_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animation_iteration_count_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"animationIterationCount\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animationIterationCount_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animationIterationCount_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"animation-direction\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animation_direction_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animation_direction_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"animationDirection\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animationDirection_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animationDirection_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"animation-play-state\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animation_play_state_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animation_play_state_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"animationPlayState\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animationPlayState_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animationPlayState_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"animation-fill-mode\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animation_fill_mode_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animation_fill_mode_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"animationFillMode\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animationFillMode_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animationFillMode_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"animation-delay\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animation_delay_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animation_delay_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"animationDelay\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &animationDelay_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &animationDelay_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]

]}
fn sAttributes<TH: TypeHolderTrait>() -> &'static [Guard<&'static [JSPropertySpec]>] { &[
    Guard::new(Condition::Satisfied, sAttributes_specs::<TH>()[0]),
    Guard::new(Condition::Pref("layout.writing-mode.enabled"), sAttributes_specs::<TH>()[1]),
    Guard::new(Condition::Satisfied, sAttributes_specs::<TH>()[2]),
    Guard::new(Condition::Pref("layout.columns.enabled"), sAttributes_specs::<TH>()[3]),
    Guard::new(Condition::Satisfied, sAttributes_specs::<TH>()[4])
]}

pub unsafe fn GetProtoObject<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject, mut rval: MutableHandleObject) {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    assert!(((*get_object_class(global.get())).flags & JSCLASS_DOM_GLOBAL) != 0);

    /* Check to see whether the interface objects are already installed */
    let proto_or_iface_array = get_proto_or_iface_array(global.get());
    rval.set((*proto_or_iface_array)[PrototypeList::ID::CSSStyleDeclaration as usize]);
    if !rval.get().is_null() {
        return;
    }

    CreateInterfaceObjects(cx, global, proto_or_iface_array);
    rval.set((*proto_or_iface_array)[PrototypeList::ID::CSSStyleDeclaration as usize]);
    assert!(!rval.get().is_null());

}

static PrototypeClass: JSClass = JSClass {
    name: b"CSSStyleDeclarationPrototype\0" as *const u8 as *const libc::c_char,
    flags:
        // JSCLASS_HAS_RESERVED_SLOTS(0)
        (0 & JSCLASS_RESERVED_SLOTS_MASK) << JSCLASS_RESERVED_SLOTS_SHIFT,
    cOps: 0 as *const _,
    reserved: [0 as *mut os::raw::c_void; 3]
};

static INTERFACE_OBJECT_CLASS: NonCallbackInterfaceObjectClass =
    NonCallbackInterfaceObjectClass::new(
        &InterfaceConstructorBehavior::throw(),
        b"function CSSStyleDeclaration() {\n    [native code]\n}",
        PrototypeList::ID::CSSStyleDeclaration,
        0);

pub unsafe fn DefineDOMInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject) {
    assert!(!global.get().is_null());

    if !ConstructorEnabled(cx, global) {
        return;
    }

    rooted!(in(cx) let mut proto = ptr::null_mut::<JSObject>());
    GetProtoObject(cx, global, proto.handle_mut());
    assert!(!proto.is_null());
}

unsafe fn ConstructorEnabled<TH: TypeHolderTrait>
(aCx: *mut JSContext, aObj: HandleObject) -> bool {
    is_exposed_in(aObj, InterfaceObjectMap::Globals::WINDOW)
}

unsafe fn CreateInterfaceObjects<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject, cache: *mut ProtoOrIfaceArray) {
    rooted!(in(cx) let mut prototype_proto = ptr::null_mut::<JSObject>());
    prototype_proto.set(JS_GetObjectPrototype(cx, global));
    assert!(!prototype_proto.is_null());

    rooted!(in(cx) let mut prototype = ptr::null_mut::<JSObject>());
    create_interface_prototype_object(cx,
                                      prototype_proto.handle().into(),
                                      &PrototypeClass,
                                      sMethods::<TH>(),
                                      sAttributes::<TH>(),
                                      &[],
                                      &[],
                                      prototype.handle_mut().into());
    assert!(!prototype.is_null());
    assert!((*cache)[PrototypeList::ID::CSSStyleDeclaration as usize].is_null());
    (*cache)[PrototypeList::ID::CSSStyleDeclaration as usize] = prototype.get();
    <*mut JSObject>::post_barrier((*cache).as_mut_ptr().offset(PrototypeList::ID::CSSStyleDeclaration as isize),
                                  ptr::null_mut(),
                                  prototype.get());


    rooted!(in(cx) let interface_proto = JS_GetFunctionPrototype(cx, global));
    assert!(!interface_proto.is_null());

    rooted!(in(cx) let mut interface = ptr::null_mut::<JSObject>());
    create_noncallback_interface_object(cx,
                                        global.into(),
                                        interface_proto.handle(),
                                        &INTERFACE_OBJECT_CLASS,
                                        &[],
                                        &[],
                                        &[],
                                        prototype.handle(),
                                        b"CSSStyleDeclaration\0",
                                        0,
                                        interface.handle_mut());
    assert!(!interface.is_null());
}
} // mod CSSStyleDeclarationBinding


