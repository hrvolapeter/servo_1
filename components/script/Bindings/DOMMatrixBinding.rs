/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */

#![allow(non_camel_case_types,non_upper_case_globals,unused_imports,unused_variables,unused_assignments,unused_mut)]
use dom;
use dom::bindings;
use dom::bindings::callback::CallSetup;
use dom::bindings::callback::CallbackContainer;
use dom::bindings::callback::CallbackFunction;
use dom::bindings::callback::CallbackInterface;
use dom::bindings::callback::CallbackObject;
use dom::bindings::callback::ExceptionHandling;
use dom::bindings::callback::wrap_call_this_object;
use dom::bindings::codegen::InterfaceObjectMap;
use dom::bindings::codegen::PrototypeList;
use dom::bindings::codegen::RegisterBindings;
use dom::bindings::codegen::UnionTypes;
use dom::bindings::constant::ConstantSpec;
use dom::bindings::constant::ConstantVal;
use dom::bindings::conversions::ConversionBehavior;
use dom::bindings::conversions::ConversionResult;
use dom::bindings::conversions::DOM_OBJECT_SLOT;
use dom::bindings::conversions::FromJSValConvertible;
use dom::bindings::conversions::IDLInterface;
use dom::bindings::conversions::StringificationBehavior;
use dom::bindings::conversions::ToJSValConvertible;
use dom::bindings::conversions::is_array_like;
use dom::bindings::conversions::jsid_to_string;
use dom::bindings::conversions::native_from_handlevalue;
use dom::bindings::conversions::native_from_object;
use dom::bindings::conversions::private_from_object;
use dom::bindings::conversions::root_from_handleobject;
use dom::bindings::conversions::root_from_handlevalue;
use dom::bindings::conversions::root_from_object;
use dom::bindings::error::Error;
use dom::bindings::error::Error::JSFailed;
use dom::bindings::error::ErrorResult;
use dom::bindings::error::Fallible;
use dom::bindings::error::throw_dom_exception;
use dom::bindings::guard::Condition;
use dom::bindings::guard::Guard;
use dom::bindings::htmlconstructor::html_constructor;
use dom::bindings::htmlconstructor::pop_current_element_queue;
use dom::bindings::htmlconstructor::push_new_element_queue;
use dom::bindings::inheritance::Castable;
use dom::bindings::interface::ConstructorClassHook;
use dom::bindings::interface::InterfaceConstructorBehavior;
use dom::bindings::interface::NonCallbackInterfaceObjectClass;
use dom::bindings::interface::create_callback_interface_object;
use dom::bindings::interface::create_global_object;
use dom::bindings::interface::create_interface_prototype_object;
use dom::bindings::interface::create_named_constructors;
use dom::bindings::interface::create_noncallback_interface_object;
use dom::bindings::interface::define_guarded_constants;
use dom::bindings::interface::define_guarded_methods;
use dom::bindings::interface::define_guarded_properties;
use dom::bindings::interface::is_exposed_in;
use dom::bindings::iterable::Iterable;
use dom::bindings::iterable::IteratorType;
use dom::bindings::mozmap::MozMap;
use dom::bindings::namespace::NamespaceObjectClass;
use dom::bindings::namespace::create_namespace_object;
use dom::bindings::num::Finite;
use dom::bindings::proxyhandler;
use dom::bindings::proxyhandler::ensure_expando_object;
use dom::bindings::proxyhandler::fill_property_descriptor;
use dom::bindings::proxyhandler::get_expando_object;
use dom::bindings::proxyhandler::get_property_descriptor;
use dom::bindings::reflector::DomObject;
use dom::bindings::reflector::MutDomObject;
use dom::bindings::root::Dom;
use dom::bindings::root::DomRoot;
use dom::bindings::root::OptionalHeapSetter;
use dom::bindings::root::RootedReference;
use dom::bindings::str::ByteString;
use dom::bindings::str::DOMString;
use dom::bindings::str::USVString;
use dom::bindings::trace::JSTraceable;
use dom::bindings::trace::RootedTraceable;
use dom::bindings::trace::RootedTraceableBox;
use dom::bindings::utils::AsVoidPtr;
use dom::bindings::utils::DOMClass;
use dom::bindings::utils::DOMJSClass;
use dom::bindings::utils::DOM_PROTO_UNFORGEABLE_HOLDER_SLOT;
use dom::bindings::utils::JSCLASS_DOM_GLOBAL;
use dom::bindings::utils::ProtoOrIfaceArray;
use dom::bindings::utils::enumerate_global;
use dom::bindings::utils::finalize_global;
use dom::bindings::utils::find_enum_value;
use dom::bindings::utils::generic_getter;
use dom::bindings::utils::generic_lenient_getter;
use dom::bindings::utils::generic_lenient_setter;
use dom::bindings::utils::generic_method;
use dom::bindings::utils::generic_setter;
use dom::bindings::utils::get_array_index_from_id;
use dom::bindings::utils::get_dictionary_property;
use dom::bindings::utils::get_property_on_prototype;
use dom::bindings::utils::get_proto_or_iface_array;
use dom::bindings::utils::has_property_on_prototype;
use dom::bindings::utils::is_platform_object;
use dom::bindings::utils::resolve_global;
use dom::bindings::utils::set_dictionary_property;
use dom::bindings::utils::trace_global;
use dom::bindings::weakref::DOM_WEAK_SLOT;
use dom::bindings::weakref::WeakBox;
use dom::bindings::weakref::WeakReferenceable;
use dom::globalscope::GlobalScope;
use dom::windowproxy::WindowProxy;
use js;
use js::JSCLASS_GLOBAL_SLOT_COUNT;
use js::JSCLASS_IS_DOMJSCLASS;
use js::JSCLASS_IS_GLOBAL;
use js::JSCLASS_RESERVED_SLOTS_MASK;
use js::JS_CALLEE;
use js::error::throw_internal_error;
use js::error::throw_type_error;
use js::glue::AppendToAutoIdVector;
use js::glue::CallJitGetterOp;
use js::glue::CallJitMethodOp;
use js::glue::CallJitSetterOp;
use js::glue::CreateProxyHandler;
use js::glue::GetProxyPrivate;
use js::glue::ProxyTraps;
use js::glue::RUST_JSID_IS_INT;
use js::glue::RUST_JSID_IS_STRING;
use js::glue::RUST_SYMBOL_TO_JSID;
use js::glue::UnwrapObject;
use js::glue::int_to_jsid;
use js::jsapi::AutoIdVector;
use js::jsapi::CallArgs;
use js::jsapi::CurrentGlobalOrNull;
use js::jsapi::FreeOp;
use js::jsapi::GetWellKnownSymbol;
use js::jsapi::Handle as RawHandle;
use js::jsapi::HandleId as RawHandleId;
use js::jsapi::HandleObject as RawHandleObject;
use js::jsapi::HandleValue as RawHandleValue;
use js::jsapi::HandleValueArray;
use js::jsapi::Heap;
use js::jsapi::INTERNED_STRING_TO_JSID;
use js::jsapi::IsCallable;
use js::jsapi::JSAutoCompartment;
use js::jsapi::JSCLASS_RESERVED_SLOTS_SHIFT;
use js::jsapi::JSClass;
use js::jsapi::JSContext;
use js::jsapi::JSFreeOp;
use js::jsapi::JSFunctionSpec;
use js::jsapi::JSITER_HIDDEN;
use js::jsapi::JSITER_OWNONLY;
use js::jsapi::JSITER_SYMBOLS;
use js::jsapi::JSJitGetterCallArgs;
use js::jsapi::JSJitInfo;
use js::jsapi::JSJitInfo_AliasSet;
use js::jsapi::JSJitInfo_ArgType;
use js::jsapi::JSJitInfo_OpType;
use js::jsapi::JSJitMethodCallArgs;
use js::jsapi::JSJitSetterCallArgs;
use js::jsapi::JSNative;
use js::jsapi::JSNativeWrapper;
use js::jsapi::JSObject;
use js::jsapi::JSPROP_ENUMERATE;
use js::jsapi::JSPROP_PERMANENT;
use js::jsapi::JSPROP_READONLY;
use js::jsapi::JSPROP_SHARED;
use js::jsapi::JSPropertySpec;
use js::jsapi::JSString;
use js::jsapi::JSTracer;
use js::jsapi::JSType;
use js::jsapi::JSTypedMethodJitInfo;
use js::jsapi::JSValueType;
use js::jsapi::JS_AtomizeAndPinString;
use js::jsapi::JS_ForwardGetPropertyTo;
use js::jsapi::JS_GetErrorPrototype;
use js::jsapi::JS_GetGlobalForObject;
use js::jsapi::JS_GetIteratorPrototype;
use js::jsapi::JS_GetPropertyById;
use js::jsapi::JS_GetPropertyDescriptorById;
use js::jsapi::JS_GetReservedSlot;
use js::jsapi::JS_HasProperty;
use js::jsapi::JS_HasPropertyById;
use js::jsapi::JS_NewObject;
use js::jsapi::JS_SetReservedSlot;
use js::jsapi::MutableHandle as RawMutableHandle;
use js::jsapi::MutableHandleObject as RawMutableHandleObject;
use js::jsapi::MutableHandleValue as RawMutableHandleValue;
use js::jsapi::ObjectOpResult;
use js::jsapi::PropertyDescriptor;
use js::jsapi::Rooted;
use js::jsapi::RootedId;
use js::jsapi::RootedObject;
use js::jsapi::RootedString;
use js::jsapi::SymbolCode;
use js::jsapi::jsid;
use js::jsval::JSVal;
use js::jsval::NullValue;
use js::jsval::ObjectOrNullValue;
use js::jsval::ObjectValue;
use js::jsval::PrivateValue;
use js::jsval::UndefinedValue;
use js::panic::maybe_resume_unwind;
use js::panic::wrap_panic;
use js::rust::CustomAutoRooterGuard;
use js::rust::GCMethods;
use js::rust::Handle;
use js::rust::HandleId;
use js::rust::HandleObject;
use js::rust::HandleValue;
use js::rust::MutableHandle;
use js::rust::MutableHandleObject;
use js::rust::MutableHandleValue;
use js::rust::define_methods;
use js::rust::define_properties;
use js::rust::get_object_class;
use js::rust::wrappers::Call;
use js::rust::wrappers::GetPropertyKeys;
use js::rust::wrappers::JS_CallFunctionValue;
use js::rust::wrappers::JS_CopyPropertiesFrom;
use js::rust::wrappers::JS_DefineProperty;
use js::rust::wrappers::JS_DefinePropertyById2;
use js::rust::wrappers::JS_GetFunctionPrototype;
use js::rust::wrappers::JS_GetObjectPrototype;
use js::rust::wrappers::JS_GetProperty;
use js::rust::wrappers::JS_InitializePropertiesFromCompatibleNativeObject;
use js::rust::wrappers::JS_NewObjectWithGivenProto;
use js::rust::wrappers::JS_NewObjectWithoutMetadata;
use js::rust::wrappers::JS_ObjectIsDate;
use js::rust::wrappers::JS_SetImmutablePrototype;
use js::rust::wrappers::JS_SetProperty;
use js::rust::wrappers::JS_SetPrototype;
use js::rust::wrappers::JS_SplicePrototype;
use js::rust::wrappers::JS_WrapObject;
use js::rust::wrappers::JS_WrapValue;
use js::rust::wrappers::NewProxyObject;
use js::typedarray;
use libc;
use malloc_size_of::MallocSizeOfOps;
use mem::malloc_size_of_including_raw_self;
use servo_config::prefs::PREFS;
use std::borrow::ToOwned;
use std::cmp;
use std::default::Default;
use std::ffi::CString;
use std::mem;
use std::num;
use std::os;
use std::os::raw::c_void;
use std::panic;
use std::ptr;
use std::ptr::NonNull;
use std::rc;
use std::rc::Rc;
use std::str;
use typeholder::TypeHolderTrait;

#[derive(JSTraceable)]
pub struct DOMMatrixInit {
    pub a: Option<f64>,
    pub b: Option<f64>,
    pub c: Option<f64>,
    pub d: Option<f64>,
    pub e: Option<f64>,
    pub f: Option<f64>,
    pub is2D: Option<bool>,
    pub m11: Option<f64>,
    pub m12: Option<f64>,
    pub m13: f64,
    pub m14: f64,
    pub m21: Option<f64>,
    pub m22: Option<f64>,
    pub m23: f64,
    pub m24: f64,
    pub m31: f64,
    pub m32: f64,
    pub m33: f64,
    pub m34: f64,
    pub m41: Option<f64>,
    pub m42: Option<f64>,
    pub m43: f64,
    pub m44: f64,
}
impl DOMMatrixInit {
    pub unsafe fn empty(cx: *mut JSContext) -> DOMMatrixInit {
        match DOMMatrixInit::new(cx, HandleValue::null()) {
            Ok(ConversionResult::Success(v)) => v,
            _ => unreachable!(),
        }
    }
    pub unsafe fn new(cx: *mut JSContext, val: HandleValue)
                      -> Result<ConversionResult<DOMMatrixInit>, ()> {
        let object = if val.get().is_null_or_undefined() {
            ptr::null_mut()
        } else if val.get().is_object() {
            val.get().to_object()
        } else {
            return Ok(ConversionResult::Failure("Value is not an object.".into()));
        };
        rooted!(in(cx) let object = object);
            let dictionary = DOMMatrixInit {
            a: {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "a", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            },
            b: {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "b", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            },
            c: {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "c", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            },
            d: {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "d", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            },
            e: {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "e", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            },
            f: {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "f", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            },
            is2D: {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "is2D", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            },
            m11: {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "m11", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            },
            m12: {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "m12", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            },
            m13: {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "m13", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        0.0
                    },
                }
            },
            m14: {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "m14", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        0.0
                    },
                }
            },
            m21: {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "m21", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            },
            m22: {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "m22", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            },
            m23: {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "m23", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        0.0
                    },
                }
            },
            m24: {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "m24", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        0.0
                    },
                }
            },
            m31: {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "m31", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        0.0
                    },
                }
            },
            m32: {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "m32", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        0.0
                    },
                }
            },
            m33: {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "m33", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        1.0
                    },
                }
            },
            m34: {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "m34", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        0.0
                    },
                }
            },
            m41: {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "m41", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            },
            m42: {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "m42", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            },
            m43: {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "m43", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        0.0
                    },
                }
            },
            m44: {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "m44", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        1.0
                    },
                }
            },
            };
        Ok(ConversionResult::Success(dictionary))
    }
}

impl FromJSValConvertible for DOMMatrixInit {
    type Config = ();
    unsafe fn from_jsval(cx: *mut JSContext, value: HandleValue, _option: ())
                         -> Result<ConversionResult<DOMMatrixInit>, ()> {
        DOMMatrixInit::new(cx, value)
    }
}

impl ToJSValConvertible for DOMMatrixInit {
    unsafe fn to_jsval(&self, cx: *mut JSContext, mut rval: MutableHandleValue) {
        rooted!(in(cx) let obj = JS_NewObject(cx, ptr::null()));
        if let Some(ref a) = self.a {
            rooted!(in(cx) let mut a_js = UndefinedValue());
            a.to_jsval(cx, a_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "a", a_js.handle()).unwrap();
        }
        if let Some(ref b) = self.b {
            rooted!(in(cx) let mut b_js = UndefinedValue());
            b.to_jsval(cx, b_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "b", b_js.handle()).unwrap();
        }
        if let Some(ref c) = self.c {
            rooted!(in(cx) let mut c_js = UndefinedValue());
            c.to_jsval(cx, c_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "c", c_js.handle()).unwrap();
        }
        if let Some(ref d) = self.d {
            rooted!(in(cx) let mut d_js = UndefinedValue());
            d.to_jsval(cx, d_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "d", d_js.handle()).unwrap();
        }
        if let Some(ref e) = self.e {
            rooted!(in(cx) let mut e_js = UndefinedValue());
            e.to_jsval(cx, e_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "e", e_js.handle()).unwrap();
        }
        if let Some(ref f) = self.f {
            rooted!(in(cx) let mut f_js = UndefinedValue());
            f.to_jsval(cx, f_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "f", f_js.handle()).unwrap();
        }
        if let Some(ref is2D) = self.is2D {
            rooted!(in(cx) let mut is2D_js = UndefinedValue());
            is2D.to_jsval(cx, is2D_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "is2D", is2D_js.handle()).unwrap();
        }
        if let Some(ref m11) = self.m11 {
            rooted!(in(cx) let mut m11_js = UndefinedValue());
            m11.to_jsval(cx, m11_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "m11", m11_js.handle()).unwrap();
        }
        if let Some(ref m12) = self.m12 {
            rooted!(in(cx) let mut m12_js = UndefinedValue());
            m12.to_jsval(cx, m12_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "m12", m12_js.handle()).unwrap();
        }
        let m13 = &self.m13;
        rooted!(in(cx) let mut m13_js = UndefinedValue());
        m13.to_jsval(cx, m13_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "m13", m13_js.handle()).unwrap();
        let m14 = &self.m14;
        rooted!(in(cx) let mut m14_js = UndefinedValue());
        m14.to_jsval(cx, m14_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "m14", m14_js.handle()).unwrap();
        if let Some(ref m21) = self.m21 {
            rooted!(in(cx) let mut m21_js = UndefinedValue());
            m21.to_jsval(cx, m21_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "m21", m21_js.handle()).unwrap();
        }
        if let Some(ref m22) = self.m22 {
            rooted!(in(cx) let mut m22_js = UndefinedValue());
            m22.to_jsval(cx, m22_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "m22", m22_js.handle()).unwrap();
        }
        let m23 = &self.m23;
        rooted!(in(cx) let mut m23_js = UndefinedValue());
        m23.to_jsval(cx, m23_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "m23", m23_js.handle()).unwrap();
        let m24 = &self.m24;
        rooted!(in(cx) let mut m24_js = UndefinedValue());
        m24.to_jsval(cx, m24_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "m24", m24_js.handle()).unwrap();
        let m31 = &self.m31;
        rooted!(in(cx) let mut m31_js = UndefinedValue());
        m31.to_jsval(cx, m31_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "m31", m31_js.handle()).unwrap();
        let m32 = &self.m32;
        rooted!(in(cx) let mut m32_js = UndefinedValue());
        m32.to_jsval(cx, m32_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "m32", m32_js.handle()).unwrap();
        let m33 = &self.m33;
        rooted!(in(cx) let mut m33_js = UndefinedValue());
        m33.to_jsval(cx, m33_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "m33", m33_js.handle()).unwrap();
        let m34 = &self.m34;
        rooted!(in(cx) let mut m34_js = UndefinedValue());
        m34.to_jsval(cx, m34_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "m34", m34_js.handle()).unwrap();
        if let Some(ref m41) = self.m41 {
            rooted!(in(cx) let mut m41_js = UndefinedValue());
            m41.to_jsval(cx, m41_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "m41", m41_js.handle()).unwrap();
        }
        if let Some(ref m42) = self.m42 {
            rooted!(in(cx) let mut m42_js = UndefinedValue());
            m42.to_jsval(cx, m42_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "m42", m42_js.handle()).unwrap();
        }
        let m43 = &self.m43;
        rooted!(in(cx) let mut m43_js = UndefinedValue());
        m43.to_jsval(cx, m43_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "m43", m43_js.handle()).unwrap();
        let m44 = &self.m44;
        rooted!(in(cx) let mut m44_js = UndefinedValue());
        m44.to_jsval(cx, m44_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "m44", m44_js.handle()).unwrap();
        rval.set(ObjectOrNullValue(obj.get()))
    }
}


pub use self::DOMMatrixBinding::{Wrap, DOMMatrixMethods, GetProtoObject, DefineDOMInterface};
pub mod DOMMatrixBinding {
#![allow(non_camel_case_types,non_upper_case_globals,unused_imports,unused_variables,unused_assignments,unused_mut)]
use dom;
use dom::bindings;
use dom::bindings::callback::CallSetup;
use dom::bindings::callback::CallbackContainer;
use dom::bindings::callback::CallbackFunction;
use dom::bindings::callback::CallbackInterface;
use dom::bindings::callback::CallbackObject;
use dom::bindings::callback::ExceptionHandling;
use dom::bindings::callback::wrap_call_this_object;
use dom::bindings::codegen::Bindings::DOMMatrixBinding::DOMMatrixInit;
use dom::bindings::codegen::Bindings::DOMMatrixReadOnlyBinding::DOMMatrixReadOnlyBinding;
use dom::bindings::codegen::InterfaceObjectMap;
use dom::bindings::codegen::PrototypeList;
use dom::bindings::codegen::RegisterBindings;
use dom::bindings::codegen::UnionTypes;
use dom::bindings::constant::ConstantSpec;
use dom::bindings::constant::ConstantVal;
use dom::bindings::conversions::ConversionBehavior;
use dom::bindings::conversions::ConversionResult;
use dom::bindings::conversions::DOM_OBJECT_SLOT;
use dom::bindings::conversions::FromJSValConvertible;
use dom::bindings::conversions::IDLInterface;
use dom::bindings::conversions::StringificationBehavior;
use dom::bindings::conversions::ToJSValConvertible;
use dom::bindings::conversions::is_array_like;
use dom::bindings::conversions::jsid_to_string;
use dom::bindings::conversions::native_from_handlevalue;
use dom::bindings::conversions::native_from_object;
use dom::bindings::conversions::private_from_object;
use dom::bindings::conversions::root_from_handleobject;
use dom::bindings::conversions::root_from_handlevalue;
use dom::bindings::conversions::root_from_object;
use dom::bindings::error::Error;
use dom::bindings::error::Error::JSFailed;
use dom::bindings::error::ErrorResult;
use dom::bindings::error::Fallible;
use dom::bindings::error::throw_dom_exception;
use dom::bindings::guard::Condition;
use dom::bindings::guard::Guard;
use dom::bindings::htmlconstructor::html_constructor;
use dom::bindings::htmlconstructor::pop_current_element_queue;
use dom::bindings::htmlconstructor::push_new_element_queue;
use dom::bindings::inheritance::Castable;
use dom::bindings::interface::ConstructorClassHook;
use dom::bindings::interface::InterfaceConstructorBehavior;
use dom::bindings::interface::NonCallbackInterfaceObjectClass;
use dom::bindings::interface::create_callback_interface_object;
use dom::bindings::interface::create_global_object;
use dom::bindings::interface::create_interface_prototype_object;
use dom::bindings::interface::create_named_constructors;
use dom::bindings::interface::create_noncallback_interface_object;
use dom::bindings::interface::define_guarded_constants;
use dom::bindings::interface::define_guarded_methods;
use dom::bindings::interface::define_guarded_properties;
use dom::bindings::interface::is_exposed_in;
use dom::bindings::iterable::Iterable;
use dom::bindings::iterable::IteratorType;
use dom::bindings::mozmap::MozMap;
use dom::bindings::namespace::NamespaceObjectClass;
use dom::bindings::namespace::create_namespace_object;
use dom::bindings::num::Finite;
use dom::bindings::proxyhandler;
use dom::bindings::proxyhandler::ensure_expando_object;
use dom::bindings::proxyhandler::fill_property_descriptor;
use dom::bindings::proxyhandler::get_expando_object;
use dom::bindings::proxyhandler::get_property_descriptor;
use dom::bindings::reflector::DomObject;
use dom::bindings::reflector::MutDomObject;
use dom::bindings::root::Dom;
use dom::bindings::root::DomRoot;
use dom::bindings::root::OptionalHeapSetter;
use dom::bindings::root::RootedReference;
use dom::bindings::str::ByteString;
use dom::bindings::str::DOMString;
use dom::bindings::str::USVString;
use dom::bindings::trace::JSTraceable;
use dom::bindings::trace::RootedTraceable;
use dom::bindings::trace::RootedTraceableBox;
use dom::bindings::utils::AsVoidPtr;
use dom::bindings::utils::DOMClass;
use dom::bindings::utils::DOMJSClass;
use dom::bindings::utils::DOM_PROTO_UNFORGEABLE_HOLDER_SLOT;
use dom::bindings::utils::JSCLASS_DOM_GLOBAL;
use dom::bindings::utils::ProtoOrIfaceArray;
use dom::bindings::utils::enumerate_global;
use dom::bindings::utils::finalize_global;
use dom::bindings::utils::find_enum_value;
use dom::bindings::utils::generic_getter;
use dom::bindings::utils::generic_lenient_getter;
use dom::bindings::utils::generic_lenient_setter;
use dom::bindings::utils::generic_method;
use dom::bindings::utils::generic_setter;
use dom::bindings::utils::get_array_index_from_id;
use dom::bindings::utils::get_dictionary_property;
use dom::bindings::utils::get_property_on_prototype;
use dom::bindings::utils::get_proto_or_iface_array;
use dom::bindings::utils::has_property_on_prototype;
use dom::bindings::utils::is_platform_object;
use dom::bindings::utils::resolve_global;
use dom::bindings::utils::set_dictionary_property;
use dom::bindings::utils::trace_global;
use dom::bindings::weakref::DOM_WEAK_SLOT;
use dom::bindings::weakref::WeakBox;
use dom::bindings::weakref::WeakReferenceable;
use dom::globalscope::GlobalScope;
use dom::types::DOMMatrix;
use dom::types::DOMMatrixReadOnly;
use dom::windowproxy::WindowProxy;
use js;
use js::JSCLASS_GLOBAL_SLOT_COUNT;
use js::JSCLASS_IS_DOMJSCLASS;
use js::JSCLASS_IS_GLOBAL;
use js::JSCLASS_RESERVED_SLOTS_MASK;
use js::JS_CALLEE;
use js::error::throw_internal_error;
use js::error::throw_type_error;
use js::glue::AppendToAutoIdVector;
use js::glue::CallJitGetterOp;
use js::glue::CallJitMethodOp;
use js::glue::CallJitSetterOp;
use js::glue::CreateProxyHandler;
use js::glue::GetProxyPrivate;
use js::glue::ProxyTraps;
use js::glue::RUST_JSID_IS_INT;
use js::glue::RUST_JSID_IS_STRING;
use js::glue::RUST_SYMBOL_TO_JSID;
use js::glue::UnwrapObject;
use js::glue::int_to_jsid;
use js::jsapi::AutoIdVector;
use js::jsapi::CallArgs;
use js::jsapi::CurrentGlobalOrNull;
use js::jsapi::FreeOp;
use js::jsapi::GetWellKnownSymbol;
use js::jsapi::Handle as RawHandle;
use js::jsapi::HandleId as RawHandleId;
use js::jsapi::HandleObject as RawHandleObject;
use js::jsapi::HandleValue as RawHandleValue;
use js::jsapi::HandleValueArray;
use js::jsapi::Heap;
use js::jsapi::INTERNED_STRING_TO_JSID;
use js::jsapi::IsCallable;
use js::jsapi::JSAutoCompartment;
use js::jsapi::JSCLASS_RESERVED_SLOTS_SHIFT;
use js::jsapi::JSClass;
use js::jsapi::JSContext;
use js::jsapi::JSFreeOp;
use js::jsapi::JSFunctionSpec;
use js::jsapi::JSITER_HIDDEN;
use js::jsapi::JSITER_OWNONLY;
use js::jsapi::JSITER_SYMBOLS;
use js::jsapi::JSJitGetterCallArgs;
use js::jsapi::JSJitInfo;
use js::jsapi::JSJitInfo_AliasSet;
use js::jsapi::JSJitInfo_ArgType;
use js::jsapi::JSJitInfo_OpType;
use js::jsapi::JSJitMethodCallArgs;
use js::jsapi::JSJitSetterCallArgs;
use js::jsapi::JSNative;
use js::jsapi::JSNativeWrapper;
use js::jsapi::JSObject;
use js::jsapi::JSPROP_ENUMERATE;
use js::jsapi::JSPROP_PERMANENT;
use js::jsapi::JSPROP_READONLY;
use js::jsapi::JSPROP_SHARED;
use js::jsapi::JSPropertySpec;
use js::jsapi::JSString;
use js::jsapi::JSTracer;
use js::jsapi::JSType;
use js::jsapi::JSTypedMethodJitInfo;
use js::jsapi::JSValueType;
use js::jsapi::JS_AtomizeAndPinString;
use js::jsapi::JS_ForwardGetPropertyTo;
use js::jsapi::JS_GetErrorPrototype;
use js::jsapi::JS_GetGlobalForObject;
use js::jsapi::JS_GetIteratorPrototype;
use js::jsapi::JS_GetPropertyById;
use js::jsapi::JS_GetPropertyDescriptorById;
use js::jsapi::JS_GetReservedSlot;
use js::jsapi::JS_HasProperty;
use js::jsapi::JS_HasPropertyById;
use js::jsapi::JS_NewObject;
use js::jsapi::JS_SetReservedSlot;
use js::jsapi::MutableHandle as RawMutableHandle;
use js::jsapi::MutableHandleObject as RawMutableHandleObject;
use js::jsapi::MutableHandleValue as RawMutableHandleValue;
use js::jsapi::ObjectOpResult;
use js::jsapi::PropertyDescriptor;
use js::jsapi::Rooted;
use js::jsapi::RootedId;
use js::jsapi::RootedObject;
use js::jsapi::RootedString;
use js::jsapi::SymbolCode;
use js::jsapi::jsid;
use js::jsval::JSVal;
use js::jsval::NullValue;
use js::jsval::ObjectOrNullValue;
use js::jsval::ObjectValue;
use js::jsval::PrivateValue;
use js::jsval::UndefinedValue;
use js::panic::maybe_resume_unwind;
use js::panic::wrap_panic;
use js::rust::CustomAutoRooterGuard;
use js::rust::GCMethods;
use js::rust::Handle;
use js::rust::HandleId;
use js::rust::HandleObject;
use js::rust::HandleValue;
use js::rust::MutableHandle;
use js::rust::MutableHandleObject;
use js::rust::MutableHandleValue;
use js::rust::define_methods;
use js::rust::define_properties;
use js::rust::get_object_class;
use js::rust::wrappers::Call;
use js::rust::wrappers::GetPropertyKeys;
use js::rust::wrappers::JS_CallFunctionValue;
use js::rust::wrappers::JS_CopyPropertiesFrom;
use js::rust::wrappers::JS_DefineProperty;
use js::rust::wrappers::JS_DefinePropertyById2;
use js::rust::wrappers::JS_GetFunctionPrototype;
use js::rust::wrappers::JS_GetObjectPrototype;
use js::rust::wrappers::JS_GetProperty;
use js::rust::wrappers::JS_InitializePropertiesFromCompatibleNativeObject;
use js::rust::wrappers::JS_NewObjectWithGivenProto;
use js::rust::wrappers::JS_NewObjectWithoutMetadata;
use js::rust::wrappers::JS_ObjectIsDate;
use js::rust::wrappers::JS_SetImmutablePrototype;
use js::rust::wrappers::JS_SetProperty;
use js::rust::wrappers::JS_SetPrototype;
use js::rust::wrappers::JS_SplicePrototype;
use js::rust::wrappers::JS_WrapObject;
use js::rust::wrappers::JS_WrapValue;
use js::rust::wrappers::NewProxyObject;
use js::typedarray;
use libc;
use malloc_size_of::MallocSizeOfOps;
use mem::malloc_size_of_including_raw_self;
use servo_config::prefs::PREFS;
use std::borrow::ToOwned;
use std::cmp;
use std::default::Default;
use std::ffi::CString;
use std::mem;
use std::num;
use std::os;
use std::os::raw::c_void;
use std::panic;
use std::ptr;
use std::ptr::NonNull;
use std::rc;
use std::rc::Rc;
use std::str;
use typeholder::TypeHolderTrait;

unsafe extern fn fromMatrix<TH: TypeHolderTrait>
(cx: *mut JSContext, argc: libc::c_uint, vp: *mut JSVal) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let global = GlobalScope::<TH>::from_object(JS_CALLEE(cx, vp).to_object());
        let args = CallArgs::from_vp(vp, argc);
        let arg0: dom::bindings::codegen::Bindings::DOMMatrixBinding::DOMMatrixInit = if args.get(0).is_undefined() {
            dom::bindings::codegen::Bindings::DOMMatrixBinding::DOMMatrixInit::empty(cx)
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(dictionary)) => dictionary,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        let result: Result<DomRoot<DOMMatrix<TH>>, Error> = DOMMatrix::FromMatrix(&global, &arg0);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, global.upcast::<GlobalScope<TH>>(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn fromFloat32Array<TH: TypeHolderTrait>
(cx: *mut JSContext, argc: libc::c_uint, vp: *mut JSVal) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let global = GlobalScope::<TH>::from_object(JS_CALLEE(cx, vp).to_object());
        let args = CallArgs::from_vp(vp, argc);

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"DOMMatrix.fromFloat32Array\".");
            return false;
        }
        let arg0: typedarray::Float32Array = if args.get(0).get().is_object() {
            match typedarray::Float32Array::from(args.get(0).get().to_object()) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value is not a typed array.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        auto_root!(in(cx) let arg0 = arg0);
        let result: Result<DomRoot<DOMMatrix<TH>>, Error> = DOMMatrix::FromFloat32Array(&global, arg0);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, global.upcast::<GlobalScope<TH>>(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn fromFloat64Array<TH: TypeHolderTrait>
(cx: *mut JSContext, argc: libc::c_uint, vp: *mut JSVal) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let global = GlobalScope::<TH>::from_object(JS_CALLEE(cx, vp).to_object());
        let args = CallArgs::from_vp(vp, argc);

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"DOMMatrix.fromFloat64Array\".");
            return false;
        }
        let arg0: typedarray::Float64Array = if args.get(0).get().is_object() {
            match typedarray::Float64Array::from(args.get(0).get().to_object()) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value is not a typed array.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        auto_root!(in(cx) let arg0 = arg0);
        let result: Result<DomRoot<DOMMatrix<TH>>, Error> = DOMMatrix::FromFloat64Array(&global, arg0);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, global.upcast::<GlobalScope<TH>>(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn get_a<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.A();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_a<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetA(arg0);

        return true;
    }), false);
}


const a_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const a_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_b<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.B();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_b<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetB(arg0);

        return true;
    }), false);
}


const b_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const b_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_c<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.C();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_c<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetC(arg0);

        return true;
    }), false);
}


const c_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const c_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_d<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.D();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_d<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetD(arg0);

        return true;
    }), false);
}


const d_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const d_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_e<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.E();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_e<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetE(arg0);

        return true;
    }), false);
}


const e_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const e_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_f<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.F();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_f<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetF(arg0);

        return true;
    }), false);
}


const f_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const f_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_m11<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.M11();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_m11<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetM11(arg0);

        return true;
    }), false);
}


const m11_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const m11_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_m12<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.M12();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_m12<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetM12(arg0);

        return true;
    }), false);
}


const m12_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const m12_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_m13<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.M13();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_m13<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetM13(arg0);

        return true;
    }), false);
}


const m13_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const m13_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_m14<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.M14();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_m14<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetM14(arg0);

        return true;
    }), false);
}


const m14_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const m14_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_m21<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.M21();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_m21<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetM21(arg0);

        return true;
    }), false);
}


const m21_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const m21_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_m22<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.M22();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_m22<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetM22(arg0);

        return true;
    }), false);
}


const m22_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const m22_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_m23<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.M23();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_m23<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetM23(arg0);

        return true;
    }), false);
}


const m23_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const m23_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_m24<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.M24();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_m24<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetM24(arg0);

        return true;
    }), false);
}


const m24_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const m24_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_m31<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.M31();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_m31<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetM31(arg0);

        return true;
    }), false);
}


const m31_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const m31_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_m32<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.M32();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_m32<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetM32(arg0);

        return true;
    }), false);
}


const m32_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const m32_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_m33<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.M33();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_m33<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetM33(arg0);

        return true;
    }), false);
}


const m33_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const m33_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_m34<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.M34();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_m34<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetM34(arg0);

        return true;
    }), false);
}


const m34_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const m34_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_m41<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.M41();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_m41<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetM41(arg0);

        return true;
    }), false);
}


const m41_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const m41_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_m42<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.M42();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_m42<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetM42(arg0);

        return true;
    }), false);
}


const m42_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const m42_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_m43<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.M43();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_m43<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetM43(arg0);

        return true;
    }), false);
}


const m43_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const m43_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_m44<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.M44();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_m44<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const DOMMatrix<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetM44(arg0);

        return true;
    }), false);
}


const m44_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const m44_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn multiplySelf<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: dom::bindings::codegen::Bindings::DOMMatrixBinding::DOMMatrixInit = if args.get(0).is_undefined() {
            dom::bindings::codegen::Bindings::DOMMatrixBinding::DOMMatrixInit::empty(cx)
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(dictionary)) => dictionary,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        let result: Result<DomRoot<DOMMatrix<TH>>, Error> = this.MultiplySelf(&arg0);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const multiplySelf_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn preMultiplySelf<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: dom::bindings::codegen::Bindings::DOMMatrixBinding::DOMMatrixInit = if args.get(0).is_undefined() {
            dom::bindings::codegen::Bindings::DOMMatrixBinding::DOMMatrixInit::empty(cx)
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(dictionary)) => dictionary,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        let result: Result<DomRoot<DOMMatrix<TH>>, Error> = this.PreMultiplySelf(&arg0);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const preMultiplySelf_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn translateSelf<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: f64 = if args.get(0).is_undefined() {
            0.0
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let arg1: f64 = if args.get(1).is_undefined() {
            0.0
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let arg2: f64 = if args.get(2).is_undefined() {
            0.0
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: DomRoot<DOMMatrix<TH>> = this.TranslateSelf(arg0, arg1, arg2);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const translateSelf_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn scaleSelf<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: f64 = if args.get(0).is_undefined() {
            1.0
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let arg1: Option<f64> = if args.get(1).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let arg2: f64 = if args.get(2).is_undefined() {
            1.0
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let arg3: f64 = if args.get(3).is_undefined() {
            0.0
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(3), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let arg4: f64 = if args.get(4).is_undefined() {
            0.0
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(4), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let arg5: f64 = if args.get(5).is_undefined() {
            0.0
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(5), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: DomRoot<DOMMatrix<TH>> = this.ScaleSelf(arg0, arg1, arg2, arg3, arg4, arg5);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const scaleSelf_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn scale3dSelf<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: f64 = if args.get(0).is_undefined() {
            1.0
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let arg1: f64 = if args.get(1).is_undefined() {
            0.0
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let arg2: f64 = if args.get(2).is_undefined() {
            0.0
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let arg3: f64 = if args.get(3).is_undefined() {
            0.0
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(3), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: DomRoot<DOMMatrix<TH>> = this.Scale3dSelf(arg0, arg1, arg2, arg3);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const scale3dSelf_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn rotateSelf<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: f64 = if args.get(0).is_undefined() {
            0.0
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let arg1: Option<f64> = if args.get(1).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let arg2: Option<f64> = if args.get(2).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: DomRoot<DOMMatrix<TH>> = this.RotateSelf(arg0, arg1, arg2);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const rotateSelf_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn rotateFromVectorSelf<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: f64 = if args.get(0).is_undefined() {
            0.0
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let arg1: f64 = if args.get(1).is_undefined() {
            0.0
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: DomRoot<DOMMatrix<TH>> = this.RotateFromVectorSelf(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const rotateFromVectorSelf_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn rotateAxisAngleSelf<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: f64 = if args.get(0).is_undefined() {
            0.0
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let arg1: f64 = if args.get(1).is_undefined() {
            0.0
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let arg2: f64 = if args.get(2).is_undefined() {
            0.0
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let arg3: f64 = if args.get(3).is_undefined() {
            0.0
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(3), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: DomRoot<DOMMatrix<TH>> = this.RotateAxisAngleSelf(arg0, arg1, arg2, arg3);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const rotateAxisAngleSelf_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn skewXSelf<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: f64 = if args.get(0).is_undefined() {
            0.0
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: DomRoot<DOMMatrix<TH>> = this.SkewXSelf(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const skewXSelf_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn skewYSelf<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: f64 = if args.get(0).is_undefined() {
            0.0
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: DomRoot<DOMMatrix<TH>> = this.SkewYSelf(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const skewYSelf_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn invertSelf<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const DOMMatrix<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: DomRoot<DOMMatrix<TH>> = this.InvertSelf();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const invertSelf_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::DOMMatrix as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn FOO_finalize(_fop: *mut JSFreeOp, obj: *mut JSObject) {
	unimplemented!();
}

unsafe extern fn _finalize<TH: TypeHolderTrait>
(_fop: *mut JSFreeOp, obj: *mut JSObject) {
    return wrap_panic(panic::AssertUnwindSafe(|| {

        let this = native_from_object::<DOMMatrix<TH>>(obj).unwrap();
            if !this.is_null() {
                // The pointer can be null if the object is the unforgeable holder of that interface.
                let _ = Box::from_raw(this as *mut DOMMatrix<TH>);
            }
            debug!("DOMMatrix<TH> finalize: {:p}", this);
    }), ());
}

unsafe extern fn FOO_trace(trc: *mut JSTracer, obj: *mut JSObject) {
	unimplemented!();
}

unsafe extern fn _trace<TH: TypeHolderTrait>
(trc: *mut JSTracer, obj: *mut JSObject) {
    return wrap_panic(panic::AssertUnwindSafe(|| {

        let this = native_from_object::<DOMMatrix<TH>>(obj).unwrap();
        if this.is_null() { return; } // GC during obj creation
        (*this).trace(trc);
    }), ());
}

static CLASS_OPS: js::jsapi::JSClassOps = js::jsapi::JSClassOps {
    addProperty: None,
    delProperty: None,
    getProperty: None,
    setProperty: None,
    enumerate: None,
    resolve: None,
    mayResolve: None,
    finalize: Some(FOO_finalize),
    call: None,
    hasInstance: None,
    construct: None,
    trace: Some(FOO_trace),
};

pub unsafe fn FOO_malloc_size_of(
    ops: &mut MallocSizeOfOps, obj: *const c_void) -> usize {
	unimplemented!()
}

static Class: DOMJSClass = DOMJSClass {
    base: js::jsapi::JSClass {
        name: b"DOMMatrix\0" as *const u8 as *const libc::c_char,
        flags: JSCLASS_IS_DOMJSCLASS | 0 |
               (((1) & JSCLASS_RESERVED_SLOTS_MASK) << JSCLASS_RESERVED_SLOTS_SHIFT)
               /* JSCLASS_HAS_RESERVED_SLOTS(1) */,
        cOps: &CLASS_OPS,
        reserved: [0 as *mut _; 3],
    },
    dom_class: DOMClass {
    interface_chain: [ PrototypeList::ID::DOMMatrixReadOnly, PrototypeList::ID::DOMMatrix, PrototypeList::ID::Last, PrototypeList::ID::Last, PrototypeList::ID::Last, PrototypeList::ID::Last ],
    type_id: ::dom::bindings::codegen::InheritTypes::TopTypeId { dommatrixreadonly: (::dom::bindings::codegen::InheritTypes::DOMMatrixReadOnlyTypeId::DOMMatrix) },
    global: InterfaceObjectMap::Globals::EMPTY,
    malloc_size_of: FOO_malloc_size_of as unsafe fn(&mut _, _) -> _,
}
};



pub unsafe fn Wrap<TH: TypeHolderTrait>
(cx: *mut JSContext, scope: &GlobalScope<TH>, object: Box<DOMMatrix<TH>>) -> DomRoot<DOMMatrix<TH>> {
    let scope = scope.reflector().get_jsobject();
    assert!(!scope.get().is_null());
    assert!(((*get_object_class(scope.get())).flags & JSCLASS_IS_GLOBAL) != 0);

    rooted!(in(cx) let mut proto = ptr::null_mut::<JSObject>());
    let _ac = JSAutoCompartment::new(cx, scope.get());
    GetProtoObject::<TH>(cx, scope, proto.handle_mut());
    assert!(!proto.is_null());

    let raw = Box::into_raw(object);
    let _rt = RootedTraceable::new(&*raw);
    rooted!(in(cx) let obj = JS_NewObjectWithGivenProto(
        cx, &Class.base as *const JSClass, proto.handle()));
    assert!(!obj.is_null());

    JS_SetReservedSlot(obj.get(), DOM_OBJECT_SLOT,
                       PrivateValue(raw as *const libc::c_void));


    (*raw).init_reflector(obj.get());

    DomRoot::from_ref(&*raw)
}

impl<TH: TypeHolderTrait> IDLInterface for DOMMatrix<TH> {
    #[inline]
    fn derives(class: &'static DOMClass) -> bool {
        class as *const _ == &Class.dom_class as *const _
    }
}

impl<TH: TypeHolderTrait> PartialEq for DOMMatrix<TH> {
    fn eq(&self, other: &DOMMatrix<TH>) -> bool {
        self as *const DOMMatrix<TH> == &*other
    }
}

pub trait DOMMatrixMethods<TH: TypeHolderTrait> {
    fn A(&self) -> f64;
    fn SetA(&self, value: f64) -> ();
    fn B(&self) -> f64;
    fn SetB(&self, value: f64) -> ();
    fn C(&self) -> f64;
    fn SetC(&self, value: f64) -> ();
    fn D(&self) -> f64;
    fn SetD(&self, value: f64) -> ();
    fn E(&self) -> f64;
    fn SetE(&self, value: f64) -> ();
    fn F(&self) -> f64;
    fn SetF(&self, value: f64) -> ();
    fn M11(&self) -> f64;
    fn SetM11(&self, value: f64) -> ();
    fn M12(&self) -> f64;
    fn SetM12(&self, value: f64) -> ();
    fn M13(&self) -> f64;
    fn SetM13(&self, value: f64) -> ();
    fn M14(&self) -> f64;
    fn SetM14(&self, value: f64) -> ();
    fn M21(&self) -> f64;
    fn SetM21(&self, value: f64) -> ();
    fn M22(&self) -> f64;
    fn SetM22(&self, value: f64) -> ();
    fn M23(&self) -> f64;
    fn SetM23(&self, value: f64) -> ();
    fn M24(&self) -> f64;
    fn SetM24(&self, value: f64) -> ();
    fn M31(&self) -> f64;
    fn SetM31(&self, value: f64) -> ();
    fn M32(&self) -> f64;
    fn SetM32(&self, value: f64) -> ();
    fn M33(&self) -> f64;
    fn SetM33(&self, value: f64) -> ();
    fn M34(&self) -> f64;
    fn SetM34(&self, value: f64) -> ();
    fn M41(&self) -> f64;
    fn SetM41(&self, value: f64) -> ();
    fn M42(&self) -> f64;
    fn SetM42(&self, value: f64) -> ();
    fn M43(&self) -> f64;
    fn SetM43(&self, value: f64) -> ();
    fn M44(&self) -> f64;
    fn SetM44(&self, value: f64) -> ();
    fn MultiplySelf(&self, other: &dom::bindings::codegen::Bindings::DOMMatrixBinding::DOMMatrixInit) -> Fallible<DomRoot<DOMMatrix<TH>>>;
    fn PreMultiplySelf(&self, other: &dom::bindings::codegen::Bindings::DOMMatrixBinding::DOMMatrixInit) -> Fallible<DomRoot<DOMMatrix<TH>>>;
    fn TranslateSelf(&self, tx: f64, ty: f64, tz: f64) -> DomRoot<DOMMatrix<TH>>;
    fn ScaleSelf(&self, scaleX: f64, scaleY: Option<f64>, scaleZ: f64, originX: f64, originY: f64, originZ: f64) -> DomRoot<DOMMatrix<TH>>;
    fn Scale3dSelf(&self, scale: f64, originX: f64, originY: f64, originZ: f64) -> DomRoot<DOMMatrix<TH>>;
    fn RotateSelf(&self, rotX: f64, rotY: Option<f64>, rotZ: Option<f64>) -> DomRoot<DOMMatrix<TH>>;
    fn RotateFromVectorSelf(&self, x: f64, y: f64) -> DomRoot<DOMMatrix<TH>>;
    fn RotateAxisAngleSelf(&self, x: f64, y: f64, z: f64, angle: f64) -> DomRoot<DOMMatrix<TH>>;
    fn SkewXSelf(&self, sx: f64) -> DomRoot<DOMMatrix<TH>>;
    fn SkewYSelf(&self, sy: f64) -> DomRoot<DOMMatrix<TH>>;
    fn InvertSelf(&self) -> DomRoot<DOMMatrix<TH>>;
}
const sStaticMethods_specs: &'static [&'static[JSFunctionSpec]] = &[
&[
    JSFunctionSpec {
        name: b"fromMatrix\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"fromFloat32Array\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"fromFloat64Array\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]

];
const sStaticMethods: &'static [Guard<&'static [JSFunctionSpec]>] = &[
    Guard::new(Condition::Satisfied, sStaticMethods_specs[0])
];
const sMethods_specs: &'static [&'static[JSFunctionSpec]] = &[
&[
    JSFunctionSpec {
        name: b"multiplySelf\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &multiplySelf_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"preMultiplySelf\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &preMultiplySelf_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"translateSelf\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &translateSelf_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"scaleSelf\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &scaleSelf_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"scale3dSelf\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &scale3dSelf_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"rotateSelf\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &rotateSelf_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"rotateFromVectorSelf\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &rotateFromVectorSelf_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"rotateAxisAngleSelf\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &rotateAxisAngleSelf_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"skewXSelf\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &skewXSelf_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"skewYSelf\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &skewYSelf_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"invertSelf\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &invertSelf_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]

];
const sMethods: &'static [Guard<&'static [JSFunctionSpec]>] = &[
    Guard::new(Condition::Satisfied, sMethods_specs[0])
];
const sAttributes_specs: &'static [&'static[JSPropertySpec]] = &[
&[
    JSPropertySpec {
        name: b"a\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &a_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &a_setterinfo }
    },
    JSPropertySpec {
        name: b"b\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &b_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &b_setterinfo }
    },
    JSPropertySpec {
        name: b"c\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &c_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &c_setterinfo }
    },
    JSPropertySpec {
        name: b"d\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &d_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &d_setterinfo }
    },
    JSPropertySpec {
        name: b"e\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &e_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &e_setterinfo }
    },
    JSPropertySpec {
        name: b"f\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &f_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &f_setterinfo }
    },
    JSPropertySpec {
        name: b"m11\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &m11_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &m11_setterinfo }
    },
    JSPropertySpec {
        name: b"m12\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &m12_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &m12_setterinfo }
    },
    JSPropertySpec {
        name: b"m13\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &m13_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &m13_setterinfo }
    },
    JSPropertySpec {
        name: b"m14\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &m14_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &m14_setterinfo }
    },
    JSPropertySpec {
        name: b"m21\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &m21_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &m21_setterinfo }
    },
    JSPropertySpec {
        name: b"m22\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &m22_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &m22_setterinfo }
    },
    JSPropertySpec {
        name: b"m23\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &m23_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &m23_setterinfo }
    },
    JSPropertySpec {
        name: b"m24\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &m24_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &m24_setterinfo }
    },
    JSPropertySpec {
        name: b"m31\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &m31_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &m31_setterinfo }
    },
    JSPropertySpec {
        name: b"m32\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &m32_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &m32_setterinfo }
    },
    JSPropertySpec {
        name: b"m33\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &m33_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &m33_setterinfo }
    },
    JSPropertySpec {
        name: b"m34\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &m34_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &m34_setterinfo }
    },
    JSPropertySpec {
        name: b"m41\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &m41_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &m41_setterinfo }
    },
    JSPropertySpec {
        name: b"m42\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &m42_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &m42_setterinfo }
    },
    JSPropertySpec {
        name: b"m43\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &m43_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &m43_setterinfo }
    },
    JSPropertySpec {
        name: b"m44\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &m44_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &m44_setterinfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]

];
const sAttributes: &'static [Guard<&'static [JSPropertySpec]>] = &[
    Guard::new(Condition::Satisfied, sAttributes_specs[0])
];

pub unsafe fn GetProtoObject<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject, mut rval: MutableHandleObject) {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    assert!(((*get_object_class(global.get())).flags & JSCLASS_DOM_GLOBAL) != 0);

    /* Check to see whether the interface objects are already installed */
    let proto_or_iface_array = get_proto_or_iface_array(global.get());
    rval.set((*proto_or_iface_array)[PrototypeList::ID::DOMMatrix as usize]);
    if !rval.get().is_null() {
        return;
    }

    CreateInterfaceObjects::<TH>(cx, global, proto_or_iface_array);
    rval.set((*proto_or_iface_array)[PrototypeList::ID::DOMMatrix as usize]);
    assert!(!rval.get().is_null());

}

static PrototypeClass: JSClass = JSClass {
    name: b"DOMMatrixPrototype\0" as *const u8 as *const libc::c_char,
    flags:
        // JSCLASS_HAS_RESERVED_SLOTS(0)
        (0 & JSCLASS_RESERVED_SLOTS_MASK) << JSCLASS_RESERVED_SLOTS_SHIFT,
    cOps: 0 as *const _,
    reserved: [0 as *mut os::raw::c_void; 3]
};

unsafe extern fn _constructor<TH: TypeHolderTrait>
(cx: *mut JSContext, argc: u32, vp: *mut JSVal) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let global = GlobalScope::<TH>::from_object(JS_CALLEE(cx, vp).to_object());
        let args = CallArgs::from_vp(vp, argc);

        let argcount = cmp::min(argc, 1);
        match argcount {
            0 => {
                let result: Result<DomRoot<DOMMatrix<TH>>, Error> = DOMMatrix::Constructor(&global);
                let result = match result {
                    Ok(result) => result,
                    Err(e) => {
                        throw_dom_exception(cx, global.upcast::<GlobalScope<TH>>(), e);
                        return false;
                    },
                };

                (result).to_jsval(cx, args.rval());
                return true;
            }
            1 => {
                let arg0: Vec<f64> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                    Ok(ConversionResult::Success(value)) => value,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                let result: Result<DomRoot<DOMMatrix<TH>>, Error> = DOMMatrix::Constructor_(&global, arg0);
                let result = match result {
                    Ok(result) => result,
                    Err(e) => {
                        throw_dom_exception(cx, global.upcast::<GlobalScope<TH>>(), e);
                        return false;
                    },
                };

                (result).to_jsval(cx, args.rval());
                return true;
            }
            _ => {
                throw_type_error(cx, "Not enough arguments to \"DOMMatrix.constructor\".");
                return false;
            }
        }
    }), false);
}

unsafe extern fn FOO_constructor(cx: *mut JSContext, argc: u32, vp: *mut JSVal) -> bool {
    unimplemented!();
}

static INTERFACE_OBJECT_CLASS: NonCallbackInterfaceObjectClass =
 
    NonCallbackInterfaceObjectClass::new(
        &InterfaceConstructorBehavior::call(FOO_constructor),
        b"function DOMMatrix() {\n    [native code]\n}",
        PrototypeList::ID::DOMMatrix,
        1);

pub unsafe fn DefineDOMInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject) {
    assert!(!global.get().is_null());

    if !ConstructorEnabled::<TH>(cx, global) {
        return;
    }

    rooted!(in(cx) let mut proto = ptr::null_mut::<JSObject>());
    GetProtoObject::<TH>(cx, global, proto.handle_mut());
    assert!(!proto.is_null());
}

unsafe fn ConstructorEnabled<TH: TypeHolderTrait>
(aCx: *mut JSContext, aObj: HandleObject) -> bool {
    is_exposed_in(aObj, InterfaceObjectMap::Globals::DEDICATED_WORKER_GLOBAL_SCOPE | InterfaceObjectMap::Globals::SERVICE_WORKER_GLOBAL_SCOPE | InterfaceObjectMap::Globals::WINDOW)
}

unsafe fn CreateInterfaceObjects<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject, cache: *mut ProtoOrIfaceArray) {
    rooted!(in(cx) let mut prototype_proto = ptr::null_mut::<JSObject>());
    DOMMatrixReadOnlyBinding::GetProtoObject::<TH>(cx, global, prototype_proto.handle_mut());
    assert!(!prototype_proto.is_null());

    rooted!(in(cx) let mut prototype = ptr::null_mut::<JSObject>());
    create_interface_prototype_object(cx,
                                      prototype_proto.handle().into(),
                                      &PrototypeClass,
                                      sMethods,
                                      sAttributes,
                                      &[],
                                      &[],
                                      prototype.handle_mut().into());
    assert!(!prototype.is_null());
    assert!((*cache)[PrototypeList::ID::DOMMatrix as usize].is_null());
    (*cache)[PrototypeList::ID::DOMMatrix as usize] = prototype.get();
    <*mut JSObject>::post_barrier((*cache).as_mut_ptr().offset(PrototypeList::ID::DOMMatrix as isize),
                                  ptr::null_mut(),
                                  prototype.get());


    rooted!(in(cx) let mut interface_proto = ptr::null_mut::<JSObject>());
    DOMMatrixReadOnlyBinding::GetConstructorObject::<TH>(cx, global, interface_proto.handle_mut());
    assert!(!interface_proto.is_null());

    rooted!(in(cx) let mut interface = ptr::null_mut::<JSObject>());
    create_noncallback_interface_object(cx,
                                        global.into(),
                                        interface_proto.handle(),
                                        &INTERFACE_OBJECT_CLASS,
                                        sStaticMethods,
                                        &[],
                                        &[],
                                        prototype.handle(),
                                        b"DOMMatrix\0",
                                        0,
                                        interface.handle_mut());
    assert!(!interface.is_null());
}
} // mod DOMMatrixBinding


