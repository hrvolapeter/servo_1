/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */

#![allow(non_camel_case_types,non_upper_case_globals,unused_imports,unused_variables,unused_assignments,unused_mut)]
use dom;
use dom::bindings;
use dom::bindings::callback::CallSetup;
use dom::bindings::callback::CallbackContainer;
use dom::bindings::callback::CallbackFunction;
use dom::bindings::callback::CallbackInterface;
use dom::bindings::callback::CallbackObject;
use dom::bindings::callback::ExceptionHandling;
use dom::bindings::callback::wrap_call_this_object;
use dom::bindings::codegen::InterfaceObjectMap;
use dom::bindings::codegen::PrototypeList;
use dom::bindings::codegen::RegisterBindings;
use dom::bindings::codegen::UnionTypes;
use dom::bindings::constant::ConstantSpec;
use dom::bindings::constant::ConstantVal;
use dom::bindings::conversions::ConversionBehavior;
use dom::bindings::conversions::ConversionResult;
use dom::bindings::conversions::DOM_OBJECT_SLOT;
use dom::bindings::conversions::FromJSValConvertible;
use dom::bindings::conversions::IDLInterface;
use dom::bindings::conversions::StringificationBehavior;
use dom::bindings::conversions::ToJSValConvertible;
use dom::bindings::conversions::is_array_like;
use dom::bindings::conversions::jsid_to_string;
use dom::bindings::conversions::native_from_handlevalue;
use dom::bindings::conversions::native_from_object;
use dom::bindings::conversions::private_from_object;
use dom::bindings::conversions::root_from_handleobject;
use dom::bindings::conversions::root_from_handlevalue;
use dom::bindings::conversions::root_from_object;
use dom::bindings::error::Error;
use dom::bindings::error::Error::JSFailed;
use dom::bindings::error::ErrorResult;
use dom::bindings::error::Fallible;
use dom::bindings::error::throw_dom_exception;
use dom::bindings::guard::Condition;
use dom::bindings::guard::Guard;
use dom::bindings::htmlconstructor::html_constructor;
use dom::bindings::htmlconstructor::pop_current_element_queue;
use dom::bindings::htmlconstructor::push_new_element_queue;
use dom::bindings::inheritance::Castable;
use dom::bindings::interface::ConstructorClassHook;
use dom::bindings::interface::InterfaceConstructorBehavior;
use dom::bindings::interface::NonCallbackInterfaceObjectClass;
use dom::bindings::interface::create_callback_interface_object;
use dom::bindings::interface::create_global_object;
use dom::bindings::interface::create_interface_prototype_object;
use dom::bindings::interface::create_named_constructors;
use dom::bindings::interface::create_noncallback_interface_object;
use dom::bindings::interface::define_guarded_constants;
use dom::bindings::interface::define_guarded_methods;
use dom::bindings::interface::define_guarded_properties;
use dom::bindings::interface::is_exposed_in;
use dom::bindings::iterable::Iterable;
use dom::bindings::iterable::IteratorType;
use dom::bindings::mozmap::MozMap;
use dom::bindings::namespace::NamespaceObjectClass;
use dom::bindings::namespace::create_namespace_object;
use dom::bindings::num::Finite;
use dom::bindings::proxyhandler;
use dom::bindings::proxyhandler::ensure_expando_object;
use dom::bindings::proxyhandler::fill_property_descriptor;
use dom::bindings::proxyhandler::get_expando_object;
use dom::bindings::proxyhandler::get_property_descriptor;
use dom::bindings::reflector::DomObject;
use dom::bindings::reflector::MutDomObject;
use dom::bindings::root::Dom;
use dom::bindings::root::DomRoot;
use dom::bindings::root::OptionalHeapSetter;
use dom::bindings::root::RootedReference;
use dom::bindings::str::ByteString;
use dom::bindings::str::DOMString;
use dom::bindings::str::USVString;
use dom::bindings::trace::JSTraceable;
use dom::bindings::trace::RootedTraceable;
use dom::bindings::trace::RootedTraceableBox;
use dom::bindings::utils::AsVoidPtr;
use dom::bindings::utils::DOMClass;
use dom::bindings::utils::DOMJSClass;
use dom::bindings::utils::DOM_PROTO_UNFORGEABLE_HOLDER_SLOT;
use dom::bindings::utils::JSCLASS_DOM_GLOBAL;
use dom::bindings::utils::ProtoOrIfaceArray;
use dom::bindings::utils::enumerate_global;
use dom::bindings::utils::finalize_global;
use dom::bindings::utils::find_enum_value;
use dom::bindings::utils::generic_getter;
use dom::bindings::utils::generic_lenient_getter;
use dom::bindings::utils::generic_lenient_setter;
use dom::bindings::utils::generic_method;
use dom::bindings::utils::generic_setter;
use dom::bindings::utils::get_array_index_from_id;
use dom::bindings::utils::get_dictionary_property;
use dom::bindings::utils::get_property_on_prototype;
use dom::bindings::utils::get_proto_or_iface_array;
use dom::bindings::utils::has_property_on_prototype;
use dom::bindings::utils::is_platform_object;
use dom::bindings::utils::resolve_global;
use dom::bindings::utils::set_dictionary_property;
use dom::bindings::utils::trace_global;
use dom::bindings::weakref::DOM_WEAK_SLOT;
use dom::bindings::weakref::WeakBox;
use dom::bindings::weakref::WeakReferenceable;
use dom::globalscope::GlobalScope;
use dom::windowproxy::WindowProxy;
use js;
use js::JSCLASS_GLOBAL_SLOT_COUNT;
use js::JSCLASS_IS_DOMJSCLASS;
use js::JSCLASS_IS_GLOBAL;
use js::JSCLASS_RESERVED_SLOTS_MASK;
use js::JS_CALLEE;
use js::error::throw_internal_error;
use js::error::throw_type_error;
use js::glue::AppendToAutoIdVector;
use js::glue::CallJitGetterOp;
use js::glue::CallJitMethodOp;
use js::glue::CallJitSetterOp;
use js::glue::CreateProxyHandler;
use js::glue::GetProxyPrivate;
use js::glue::ProxyTraps;
use js::glue::RUST_JSID_IS_INT;
use js::glue::RUST_JSID_IS_STRING;
use js::glue::RUST_SYMBOL_TO_JSID;
use js::glue::UnwrapObject;
use js::glue::int_to_jsid;
use js::jsapi::AutoIdVector;
use js::jsapi::CallArgs;
use js::jsapi::CurrentGlobalOrNull;
use js::jsapi::FreeOp;
use js::jsapi::GetWellKnownSymbol;
use js::jsapi::Handle as RawHandle;
use js::jsapi::HandleId as RawHandleId;
use js::jsapi::HandleObject as RawHandleObject;
use js::jsapi::HandleValue as RawHandleValue;
use js::jsapi::HandleValueArray;
use js::jsapi::Heap;
use js::jsapi::INTERNED_STRING_TO_JSID;
use js::jsapi::IsCallable;
use js::jsapi::JSAutoCompartment;
use js::jsapi::JSCLASS_RESERVED_SLOTS_SHIFT;
use js::jsapi::JSClass;
use js::jsapi::JSContext;
use js::jsapi::JSFreeOp;
use js::jsapi::JSFunctionSpec;
use js::jsapi::JSITER_HIDDEN;
use js::jsapi::JSITER_OWNONLY;
use js::jsapi::JSITER_SYMBOLS;
use js::jsapi::JSJitGetterCallArgs;
use js::jsapi::JSJitInfo;
use js::jsapi::JSJitInfo_AliasSet;
use js::jsapi::JSJitInfo_ArgType;
use js::jsapi::JSJitInfo_OpType;
use js::jsapi::JSJitMethodCallArgs;
use js::jsapi::JSJitSetterCallArgs;
use js::jsapi::JSNative;
use js::jsapi::JSNativeWrapper;
use js::jsapi::JSObject;
use js::jsapi::JSPROP_ENUMERATE;
use js::jsapi::JSPROP_PERMANENT;
use js::jsapi::JSPROP_READONLY;
use js::jsapi::JSPROP_SHARED;
use js::jsapi::JSPropertySpec;
use js::jsapi::JSString;
use js::jsapi::JSTracer;
use js::jsapi::JSType;
use js::jsapi::JSTypedMethodJitInfo;
use js::jsapi::JSValueType;
use js::jsapi::JS_AtomizeAndPinString;
use js::jsapi::JS_ForwardGetPropertyTo;
use js::jsapi::JS_GetErrorPrototype;
use js::jsapi::JS_GetGlobalForObject;
use js::jsapi::JS_GetIteratorPrototype;
use js::jsapi::JS_GetPropertyById;
use js::jsapi::JS_GetPropertyDescriptorById;
use js::jsapi::JS_GetReservedSlot;
use js::jsapi::JS_HasProperty;
use js::jsapi::JS_HasPropertyById;
use js::jsapi::JS_NewObject;
use js::jsapi::JS_SetReservedSlot;
use js::jsapi::MutableHandle as RawMutableHandle;
use js::jsapi::MutableHandleObject as RawMutableHandleObject;
use js::jsapi::MutableHandleValue as RawMutableHandleValue;
use js::jsapi::ObjectOpResult;
use js::jsapi::PropertyDescriptor;
use js::jsapi::Rooted;
use js::jsapi::RootedId;
use js::jsapi::RootedObject;
use js::jsapi::RootedString;
use js::jsapi::SymbolCode;
use js::jsapi::jsid;
use js::jsval::JSVal;
use js::jsval::NullValue;
use js::jsval::ObjectOrNullValue;
use js::jsval::ObjectValue;
use js::jsval::PrivateValue;
use js::jsval::UndefinedValue;
use js::panic::maybe_resume_unwind;
use js::panic::wrap_panic;
use js::rust::CustomAutoRooterGuard;
use js::rust::GCMethods;
use js::rust::Handle;
use js::rust::HandleId;
use js::rust::HandleObject;
use js::rust::HandleValue;
use js::rust::MutableHandle;
use js::rust::MutableHandleObject;
use js::rust::MutableHandleValue;
use js::rust::define_methods;
use js::rust::define_properties;
use js::rust::get_object_class;
use js::rust::wrappers::Call;
use js::rust::wrappers::GetPropertyKeys;
use js::rust::wrappers::JS_CallFunctionValue;
use js::rust::wrappers::JS_CopyPropertiesFrom;
use js::rust::wrappers::JS_DefineProperty;
use js::rust::wrappers::JS_DefinePropertyById2;
use js::rust::wrappers::JS_GetFunctionPrototype;
use js::rust::wrappers::JS_GetObjectPrototype;
use js::rust::wrappers::JS_GetProperty;
use js::rust::wrappers::JS_InitializePropertiesFromCompatibleNativeObject;
use js::rust::wrappers::JS_NewObjectWithGivenProto;
use js::rust::wrappers::JS_NewObjectWithoutMetadata;
use js::rust::wrappers::JS_ObjectIsDate;
use js::rust::wrappers::JS_SetImmutablePrototype;
use js::rust::wrappers::JS_SetProperty;
use js::rust::wrappers::JS_SetPrototype;
use js::rust::wrappers::JS_SplicePrototype;
use js::rust::wrappers::JS_WrapObject;
use js::rust::wrappers::JS_WrapValue;
use js::rust::wrappers::NewProxyObject;
use js::typedarray;
use libc;
use malloc_size_of::MallocSizeOfOps;
use mem::malloc_size_of_including_raw_self;
use servo_config::prefs::PREFS;
use std::borrow::ToOwned;
use std::cmp;
use std::default::Default;
use std::ffi::CString;
use std::mem;
use std::num;
use std::os;
use std::os::raw::c_void;
use std::panic;
use std::ptr;
use std::ptr::NonNull;
use std::rc;
use std::rc::Rc;
use std::str;
use typeholder::TypeHolderTrait;

#[repr(usize)]
#[derive(Copy, Clone, Debug, JSTraceable, MallocSizeOf, PartialEq)]
pub enum DocumentReadyState {
    Loading,
    Interactive,
    Complete
}
pub mod DocumentReadyStateValues {
    use dom::bindings::conversions::ToJSValConvertible;
    use js::jsapi::JSContext;
    use js::rust::MutableHandleValue;
    use js::jsval::JSVal;

    pub const pairs: &'static [(&'static str, super::DocumentReadyState)] = &[
        ("loading", super::DocumentReadyState::Loading),
        ("interactive", super::DocumentReadyState::Interactive),
        ("complete", super::DocumentReadyState::Complete),
    ];

    impl super::DocumentReadyState {
        pub fn as_str(&self) -> &'static str {
            pairs[*self as usize].0
        }
    }

    impl Default for super::DocumentReadyState {
        fn default() -> super::DocumentReadyState {
            pairs[0].1
        }
    }

    impl ToJSValConvertible for super::DocumentReadyState {
        unsafe fn to_jsval(&self, cx: *mut JSContext, rval: MutableHandleValue) {
            pairs[*self as usize].0.to_jsval(cx, rval);
        }
    }
        } // mod DocumentReadyStateValues

#[derive(JSTraceable)]
pub struct ElementCreationOptions {
    pub is: Option<DOMString>,
}
impl ElementCreationOptions {
    pub unsafe fn empty(cx: *mut JSContext) -> ElementCreationOptions {
        match ElementCreationOptions::new(cx, HandleValue::null()) {
            Ok(ConversionResult::Success(v)) => v,
            _ => unreachable!(),
        }
    }
    pub unsafe fn new(cx: *mut JSContext, val: HandleValue)
                      -> Result<ConversionResult<ElementCreationOptions>, ()> {
        let object = if val.get().is_null_or_undefined() {
            ptr::null_mut()
        } else if val.get().is_object() {
            val.get().to_object()
        } else {
            return Ok(ConversionResult::Failure("Value is not an object.".into()));
        };
        rooted!(in(cx) let object = object);
            let dictionary = ElementCreationOptions {
            is: {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "is", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), StringificationBehavior::Default) {
                            Ok(ConversionResult::Success(strval)) => strval,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); },
                        })
                    },
                    false => {
                        None
                    },
                }
            },
            };
        Ok(ConversionResult::Success(dictionary))
    }
}

impl FromJSValConvertible for ElementCreationOptions {
    type Config = ();
    unsafe fn from_jsval(cx: *mut JSContext, value: HandleValue, _option: ())
                         -> Result<ConversionResult<ElementCreationOptions>, ()> {
        ElementCreationOptions::new(cx, value)
    }
}

impl ToJSValConvertible for ElementCreationOptions {
    unsafe fn to_jsval(&self, cx: *mut JSContext, mut rval: MutableHandleValue) {
        rooted!(in(cx) let obj = JS_NewObject(cx, ptr::null()));
        if let Some(ref is) = self.is {
            rooted!(in(cx) let mut is_js = UndefinedValue());
            is.to_jsval(cx, is_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "is", is_js.handle()).unwrap();
        }
        rval.set(ObjectOrNullValue(obj.get()))
    }
}


pub use self::DocumentBinding::{Wrap, DocumentMethods, GetProtoObject, GetConstructorObject, DefineDOMInterface};
pub mod DocumentBinding {
#![allow(non_camel_case_types,non_upper_case_globals,unused_imports,unused_variables,unused_assignments,unused_mut)]
use dom;
use dom::bindings;
use dom::bindings::callback::CallSetup;
use dom::bindings::callback::CallbackContainer;
use dom::bindings::callback::CallbackFunction;
use dom::bindings::callback::CallbackInterface;
use dom::bindings::callback::CallbackObject;
use dom::bindings::callback::ExceptionHandling;
use dom::bindings::callback::wrap_call_this_object;
use dom::bindings::codegen::Bindings::CharacterDataBinding::CharacterDataBinding;
use dom::bindings::codegen::Bindings::DocumentBinding::DocumentReadyState;
use dom::bindings::codegen::Bindings::DocumentBinding::DocumentReadyStateValues;
use dom::bindings::codegen::Bindings::DocumentBinding::ElementCreationOptions;
use dom::bindings::codegen::Bindings::ElementBinding::ElementBinding;
use dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull;
use dom::bindings::codegen::Bindings::EventHandlerBinding::OnErrorEventHandlerNonNull;
use dom::bindings::codegen::Bindings::EventTargetBinding::EventTargetBinding;
use dom::bindings::codegen::Bindings::HTMLElementBinding::HTMLElementBinding;
use dom::bindings::codegen::Bindings::NodeBinding::NodeBinding;
use dom::bindings::codegen::Bindings::NodeFilterBinding::NodeFilter;
use dom::bindings::codegen::InterfaceObjectMap;
use dom::bindings::codegen::PrototypeList;
use dom::bindings::codegen::RegisterBindings;
use dom::bindings::codegen::UnionTypes;
use dom::bindings::constant::ConstantSpec;
use dom::bindings::constant::ConstantVal;
use dom::bindings::conversions::ConversionBehavior;
use dom::bindings::conversions::ConversionResult;
use dom::bindings::conversions::DOM_OBJECT_SLOT;
use dom::bindings::conversions::FromJSValConvertible;
use dom::bindings::conversions::IDLInterface;
use dom::bindings::conversions::StringificationBehavior;
use dom::bindings::conversions::ToJSValConvertible;
use dom::bindings::conversions::is_array_like;
use dom::bindings::conversions::jsid_to_string;
use dom::bindings::conversions::native_from_handlevalue;
use dom::bindings::conversions::native_from_object;
use dom::bindings::conversions::private_from_object;
use dom::bindings::conversions::root_from_handleobject;
use dom::bindings::conversions::root_from_handlevalue;
use dom::bindings::conversions::root_from_object;
use dom::bindings::error::Error;
use dom::bindings::error::Error::JSFailed;
use dom::bindings::error::ErrorResult;
use dom::bindings::error::Fallible;
use dom::bindings::error::throw_dom_exception;
use dom::bindings::guard::Condition;
use dom::bindings::guard::Guard;
use dom::bindings::htmlconstructor::html_constructor;
use dom::bindings::htmlconstructor::pop_current_element_queue;
use dom::bindings::htmlconstructor::push_new_element_queue;
use dom::bindings::inheritance::Castable;
use dom::bindings::interface::ConstructorClassHook;
use dom::bindings::interface::InterfaceConstructorBehavior;
use dom::bindings::interface::NonCallbackInterfaceObjectClass;
use dom::bindings::interface::create_callback_interface_object;
use dom::bindings::interface::create_global_object;
use dom::bindings::interface::create_interface_prototype_object;
use dom::bindings::interface::create_named_constructors;
use dom::bindings::interface::create_noncallback_interface_object;
use dom::bindings::interface::define_guarded_constants;
use dom::bindings::interface::define_guarded_methods;
use dom::bindings::interface::define_guarded_properties;
use dom::bindings::interface::is_exposed_in;
use dom::bindings::iterable::Iterable;
use dom::bindings::iterable::IteratorType;
use dom::bindings::mozmap::MozMap;
use dom::bindings::namespace::NamespaceObjectClass;
use dom::bindings::namespace::create_namespace_object;
use dom::bindings::num::Finite;
use dom::bindings::proxyhandler;
use dom::bindings::proxyhandler::ensure_expando_object;
use dom::bindings::proxyhandler::fill_property_descriptor;
use dom::bindings::proxyhandler::get_expando_object;
use dom::bindings::proxyhandler::get_property_descriptor;
use dom::bindings::reflector::DomObject;
use dom::bindings::reflector::MutDomObject;
use dom::bindings::root::Dom;
use dom::bindings::root::DomRoot;
use dom::bindings::root::OptionalHeapSetter;
use dom::bindings::root::RootedReference;
use dom::bindings::str::ByteString;
use dom::bindings::str::DOMString;
use dom::bindings::str::USVString;
use dom::bindings::trace::JSTraceable;
use dom::bindings::trace::RootedTraceable;
use dom::bindings::trace::RootedTraceableBox;
use dom::bindings::utils::AsVoidPtr;
use dom::bindings::utils::DOMClass;
use dom::bindings::utils::DOMJSClass;
use dom::bindings::utils::DOM_PROTO_UNFORGEABLE_HOLDER_SLOT;
use dom::bindings::utils::JSCLASS_DOM_GLOBAL;
use dom::bindings::utils::ProtoOrIfaceArray;
use dom::bindings::utils::enumerate_global;
use dom::bindings::utils::finalize_global;
use dom::bindings::utils::find_enum_value;
use dom::bindings::utils::generic_getter;
use dom::bindings::utils::generic_lenient_getter;
use dom::bindings::utils::generic_lenient_setter;
use dom::bindings::utils::generic_method;
use dom::bindings::utils::generic_setter;
use dom::bindings::utils::get_array_index_from_id;
use dom::bindings::utils::get_dictionary_property;
use dom::bindings::utils::get_property_on_prototype;
use dom::bindings::utils::get_proto_or_iface_array;
use dom::bindings::utils::has_property_on_prototype;
use dom::bindings::utils::is_platform_object;
use dom::bindings::utils::resolve_global;
use dom::bindings::utils::set_dictionary_property;
use dom::bindings::utils::trace_global;
use dom::bindings::weakref::DOM_WEAK_SLOT;
use dom::bindings::weakref::WeakBox;
use dom::bindings::weakref::WeakReferenceable;
use dom::globalscope::GlobalScope;
use dom::promise::Promise;
use dom::types::Attr;
use dom::types::CharacterData;
use dom::types::Comment;
use dom::types::DOMImplementation;
use dom::types::Document;
use dom::types::DocumentFragment;
use dom::types::DocumentType;
use dom::types::Element;
use dom::types::Event;
use dom::types::EventTarget;
use dom::types::HTMLCollection;
use dom::types::HTMLElement;
use dom::types::HTMLHeadElement;
use dom::types::HTMLScriptElement;
use dom::types::Location;
use dom::types::Node;
use dom::types::NodeIterator;
use dom::types::NodeList;
use dom::types::ProcessingInstruction;
use dom::types::Range;
use dom::types::StyleSheetList;
use dom::types::Text;
use dom::types::Touch;
use dom::types::TouchList;
use dom::types::TreeWalker;
use dom::types::Window;
use dom::windowproxy::WindowProxy;
use js;
use js::JSCLASS_GLOBAL_SLOT_COUNT;
use js::JSCLASS_IS_DOMJSCLASS;
use js::JSCLASS_IS_GLOBAL;
use js::JSCLASS_RESERVED_SLOTS_MASK;
use js::JS_CALLEE;
use js::error::throw_internal_error;
use js::error::throw_type_error;
use js::glue::AppendToAutoIdVector;
use js::glue::CallJitGetterOp;
use js::glue::CallJitMethodOp;
use js::glue::CallJitSetterOp;
use js::glue::CreateProxyHandler;
use js::glue::GetProxyPrivate;
use js::glue::ProxyTraps;
use js::glue::RUST_JSID_IS_INT;
use js::glue::RUST_JSID_IS_STRING;
use js::glue::RUST_SYMBOL_TO_JSID;
use js::glue::UnwrapObject;
use js::glue::int_to_jsid;
use js::jsapi::AutoIdVector;
use js::jsapi::CallArgs;
use js::jsapi::CurrentGlobalOrNull;
use js::jsapi::FreeOp;
use js::jsapi::GetWellKnownSymbol;
use js::jsapi::Handle as RawHandle;
use js::jsapi::HandleId as RawHandleId;
use js::jsapi::HandleObject as RawHandleObject;
use js::jsapi::HandleValue as RawHandleValue;
use js::jsapi::HandleValueArray;
use js::jsapi::Heap;
use js::jsapi::INTERNED_STRING_TO_JSID;
use js::jsapi::IsCallable;
use js::jsapi::JSAutoCompartment;
use js::jsapi::JSCLASS_RESERVED_SLOTS_SHIFT;
use js::jsapi::JSClass;
use js::jsapi::JSContext;
use js::jsapi::JSFreeOp;
use js::jsapi::JSFunctionSpec;
use js::jsapi::JSITER_HIDDEN;
use js::jsapi::JSITER_OWNONLY;
use js::jsapi::JSITER_SYMBOLS;
use js::jsapi::JSJitGetterCallArgs;
use js::jsapi::JSJitInfo;
use js::jsapi::JSJitInfo_AliasSet;
use js::jsapi::JSJitInfo_ArgType;
use js::jsapi::JSJitInfo_OpType;
use js::jsapi::JSJitMethodCallArgs;
use js::jsapi::JSJitSetterCallArgs;
use js::jsapi::JSNative;
use js::jsapi::JSNativeWrapper;
use js::jsapi::JSObject;
use js::jsapi::JSPROP_ENUMERATE;
use js::jsapi::JSPROP_PERMANENT;
use js::jsapi::JSPROP_READONLY;
use js::jsapi::JSPROP_SHARED;
use js::jsapi::JSPropertySpec;
use js::jsapi::JSString;
use js::jsapi::JSTracer;
use js::jsapi::JSType;
use js::jsapi::JSTypedMethodJitInfo;
use js::jsapi::JSValueType;
use js::jsapi::JS_AtomizeAndPinString;
use js::jsapi::JS_ForwardGetPropertyTo;
use js::jsapi::JS_GetErrorPrototype;
use js::jsapi::JS_GetGlobalForObject;
use js::jsapi::JS_GetIteratorPrototype;
use js::jsapi::JS_GetPropertyById;
use js::jsapi::JS_GetPropertyDescriptorById;
use js::jsapi::JS_GetReservedSlot;
use js::jsapi::JS_HasProperty;
use js::jsapi::JS_HasPropertyById;
use js::jsapi::JS_NewObject;
use js::jsapi::JS_SetReservedSlot;
use js::jsapi::MutableHandle as RawMutableHandle;
use js::jsapi::MutableHandleObject as RawMutableHandleObject;
use js::jsapi::MutableHandleValue as RawMutableHandleValue;
use js::jsapi::ObjectOpResult;
use js::jsapi::PropertyDescriptor;
use js::jsapi::Rooted;
use js::jsapi::RootedId;
use js::jsapi::RootedObject;
use js::jsapi::RootedString;
use js::jsapi::SymbolCode;
use js::jsapi::jsid;
use js::jsval::JSVal;
use js::jsval::NullValue;
use js::jsval::ObjectOrNullValue;
use js::jsval::ObjectValue;
use js::jsval::PrivateValue;
use js::jsval::UndefinedValue;
use js::panic::maybe_resume_unwind;
use js::panic::wrap_panic;
use js::rust::CustomAutoRooterGuard;
use js::rust::GCMethods;
use js::rust::Handle;
use js::rust::HandleId;
use js::rust::HandleObject;
use js::rust::HandleValue;
use js::rust::MutableHandle;
use js::rust::MutableHandleObject;
use js::rust::MutableHandleValue;
use js::rust::define_methods;
use js::rust::define_properties;
use js::rust::get_object_class;
use js::rust::wrappers::Call;
use js::rust::wrappers::GetPropertyKeys;
use js::rust::wrappers::JS_CallFunctionValue;
use js::rust::wrappers::JS_CopyPropertiesFrom;
use js::rust::wrappers::JS_DefineProperty;
use js::rust::wrappers::JS_DefinePropertyById2;
use js::rust::wrappers::JS_GetFunctionPrototype;
use js::rust::wrappers::JS_GetObjectPrototype;
use js::rust::wrappers::JS_GetProperty;
use js::rust::wrappers::JS_InitializePropertiesFromCompatibleNativeObject;
use js::rust::wrappers::JS_NewObjectWithGivenProto;
use js::rust::wrappers::JS_NewObjectWithoutMetadata;
use js::rust::wrappers::JS_ObjectIsDate;
use js::rust::wrappers::JS_SetImmutablePrototype;
use js::rust::wrappers::JS_SetProperty;
use js::rust::wrappers::JS_SetPrototype;
use js::rust::wrappers::JS_SplicePrototype;
use js::rust::wrappers::JS_WrapObject;
use js::rust::wrappers::JS_WrapValue;
use js::rust::wrappers::NewProxyObject;
use js::typedarray;
use libc;
use malloc_size_of::MallocSizeOfOps;
use mem::malloc_size_of_including_raw_self;
use servo_config::prefs::PREFS;
use std::borrow::ToOwned;
use std::cmp;
use std::default::Default;
use std::ffi::CString;
use std::mem;
use std::num;
use std::os;
use std::os::raw::c_void;
use std::panic;
use std::ptr;
use std::ptr::NonNull;
use std::rc;
use std::rc::Rc;
use std::str;
use typeholder::TypeHolderTrait;

unsafe extern fn get_implementation<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<DOMImplementation<TH>> = this.Implementation();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const implementation_getterinfo: JSJitInfo = JSJitInfo {
    call: get_implementation as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasNone as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_URL<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: USVString = this.URL();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const URL_getterinfo: JSJitInfo = JSJitInfo {
    call: get_URL as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasNone as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_documentURI<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: USVString = this.DocumentURI();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const documentURI_getterinfo: JSJitInfo = JSJitInfo {
    call: get_documentURI as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasNone as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_compatMode<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DOMString = this.CompatMode();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const compatMode_getterinfo: JSJitInfo = JSJitInfo {
    call: get_compatMode as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_characterSet<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DOMString = this.CharacterSet();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const characterSet_getterinfo: JSJitInfo = JSJitInfo {
    call: get_characterSet as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_charset<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DOMString = this.Charset();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const charset_getterinfo: JSJitInfo = JSJitInfo {
    call: get_charset as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_inputEncoding<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DOMString = this.InputEncoding();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const inputEncoding_getterinfo: JSJitInfo = JSJitInfo {
    call: get_inputEncoding as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_contentType<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DOMString = this.ContentType();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const contentType_getterinfo: JSJitInfo = JSJitInfo {
    call: get_contentType as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasNone as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_doctype<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DomRoot<DocumentType<TH>>> = this.GetDoctype();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const doctype_getterinfo: JSJitInfo = JSJitInfo {
    call: get_doctype as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasDOMSets as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_documentElement<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DomRoot<Element<TH>>> = this.GetDocumentElement();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const documentElement_getterinfo: JSJitInfo = JSJitInfo {
    call: get_documentElement as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasDOMSets as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn getElementsByTagName<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Document.getElementsByTagName\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: DomRoot<HTMLCollection<TH>> = this.GetElementsByTagName(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const getElementsByTagName_methodinfo: JSJitInfo = JSJitInfo {
    call: getElementsByTagName as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn getElementsByTagNameNS<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"Document.getElementsByTagNameNS\".");
            return false;
        }
        let arg0: Option<DOMString> = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let arg1: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(1), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: DomRoot<HTMLCollection<TH>> = this.GetElementsByTagNameNS(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const getElementsByTagNameNS_methodinfo: JSJitInfo = JSJitInfo {
    call: getElementsByTagNameNS as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn getElementsByClassName<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Document.getElementsByClassName\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: DomRoot<HTMLCollection<TH>> = this.GetElementsByClassName(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const getElementsByClassName_methodinfo: JSJitInfo = JSJitInfo {
    call: getElementsByClassName as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn createElement<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Document.createElement\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let arg1: dom::bindings::codegen::Bindings::DocumentBinding::ElementCreationOptions = if args.get(1).is_undefined() {
            dom::bindings::codegen::Bindings::DocumentBinding::ElementCreationOptions::empty(cx)
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
                Ok(ConversionResult::Success(dictionary)) => dictionary,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        push_new_element_queue();

        let result: Result<DomRoot<Element<TH>>, Error> = this.CreateElement(arg0, &arg1);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const createElement_methodinfo: JSJitInfo = JSJitInfo {
    call: createElement as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn createElementNS<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"Document.createElementNS\".");
            return false;
        }
        let arg0: Option<DOMString> = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let arg1: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(1), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let arg2: dom::bindings::codegen::Bindings::DocumentBinding::ElementCreationOptions = if args.get(2).is_undefined() {
            dom::bindings::codegen::Bindings::DocumentBinding::ElementCreationOptions::empty(cx)
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
                Ok(ConversionResult::Success(dictionary)) => dictionary,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        push_new_element_queue();

        let result: Result<DomRoot<Element<TH>>, Error> = this.CreateElementNS(arg0, arg1, &arg2);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const createElementNS_methodinfo: JSJitInfo = JSJitInfo {
    call: createElementNS as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn createDocumentFragment<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: DomRoot<DocumentFragment<TH>> = this.CreateDocumentFragment();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const createDocumentFragment_methodinfo: JSJitInfo = JSJitInfo {
    call: createDocumentFragment as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn createTextNode<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Document.createTextNode\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: DomRoot<Text<TH>> = this.CreateTextNode(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const createTextNode_methodinfo: JSJitInfo = JSJitInfo {
    call: createTextNode as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn createComment<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Document.createComment\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: DomRoot<Comment<TH>> = this.CreateComment(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const createComment_methodinfo: JSJitInfo = JSJitInfo {
    call: createComment as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn createProcessingInstruction<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"Document.createProcessingInstruction\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let arg1: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(1), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: Result<DomRoot<ProcessingInstruction<TH>>, Error> = this.CreateProcessingInstruction(arg0, arg1);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const createProcessingInstruction_methodinfo: JSJitInfo = JSJitInfo {
    call: createProcessingInstruction as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn importNode<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Document.importNode\".");
            return false;
        }
        let arg0: DomRoot<Node<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface Node.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: bool = if args.get(1).is_undefined() {
            false
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        push_new_element_queue();

        let result: Result<DomRoot<Node<TH>>, Error> = this.ImportNode(&arg0, arg1);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const importNode_methodinfo: JSJitInfo = JSJitInfo {
    call: importNode as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn adoptNode<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Document.adoptNode\".");
            return false;
        }
        let arg0: DomRoot<Node<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface Node.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        push_new_element_queue();

        let result: Result<DomRoot<Node<TH>>, Error> = this.AdoptNode(&arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const adoptNode_methodinfo: JSJitInfo = JSJitInfo {
    call: adoptNode as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn createAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Document.createAttribute\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: Result<DomRoot<Attr<TH>>, Error> = this.CreateAttribute(arg0);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const createAttribute_methodinfo: JSJitInfo = JSJitInfo {
    call: createAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn createAttributeNS<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"Document.createAttributeNS\".");
            return false;
        }
        let arg0: Option<DOMString> = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let arg1: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(1), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: Result<DomRoot<Attr<TH>>, Error> = this.CreateAttributeNS(arg0, arg1);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const createAttributeNS_methodinfo: JSJitInfo = JSJitInfo {
    call: createAttributeNS as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn createEvent<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Document.createEvent\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: Result<DomRoot<Event<TH>>, Error> = this.CreateEvent(arg0);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const createEvent_methodinfo: JSJitInfo = JSJitInfo {
    call: createEvent as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn createRange<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: DomRoot<Range<TH>> = this.CreateRange();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const createRange_methodinfo: JSJitInfo = JSJitInfo {
    call: createRange as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn createNodeIterator<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Document.createNodeIterator\".");
            return false;
        }
        let arg0: DomRoot<Node<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface Node.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: u32 = if args.get(1).is_undefined() {
            4294967295
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let arg2: Option<Rc<dom::bindings::codegen::Bindings::NodeFilterBinding::NodeFilter<TH>>> = if args.get(2).is_undefined() {
            None
        } else {
            if args.get(2).get().is_object() {
                Some(dom::bindings::codegen::Bindings::NodeFilterBinding::NodeFilter::new(cx, args.get(2).get().to_object()))
            } else if args.get(2).get().is_null_or_undefined() {
                None
            } else {
                throw_type_error(cx, "Value is not an object.");
                return false;

            }
        };
        let result: DomRoot<NodeIterator<TH>> = this.CreateNodeIterator(&arg0, arg1, arg2);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const createNodeIterator_methodinfo: JSJitInfo = JSJitInfo {
    call: createNodeIterator as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn createTreeWalker<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Document.createTreeWalker\".");
            return false;
        }
        let arg0: DomRoot<Node<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface Node.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: u32 = if args.get(1).is_undefined() {
            4294967295
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let arg2: Option<Rc<dom::bindings::codegen::Bindings::NodeFilterBinding::NodeFilter<TH>>> = if args.get(2).is_undefined() {
            None
        } else {
            if args.get(2).get().is_object() {
                Some(dom::bindings::codegen::Bindings::NodeFilterBinding::NodeFilter::new(cx, args.get(2).get().to_object()))
            } else if args.get(2).get().is_null_or_undefined() {
                None
            } else {
                throw_type_error(cx, "Value is not an object.");
                return false;

            }
        };
        let result: DomRoot<TreeWalker<TH>> = this.CreateTreeWalker(&arg0, arg1, arg2);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const createTreeWalker_methodinfo: JSJitInfo = JSJitInfo {
    call: createTreeWalker as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_location<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DomRoot<Location<TH>>> = this.GetLocation();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const location_getterinfo: JSJitInfo = JSJitInfo {
    call: get_location as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_domain<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DOMString = this.Domain();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_domain<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: Result<(), Error> = this.SetDomain(arg0);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const domain_getterinfo: JSJitInfo = JSJitInfo {
    call: get_domain as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const domain_setterinfo: JSJitInfo = JSJitInfo {
    call: set_domain as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_referrer<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DOMString = this.Referrer();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const referrer_getterinfo: JSJitInfo = JSJitInfo {
    call: get_referrer as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_cookie<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Result<DOMString, Error> = this.GetCookie();
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_cookie<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: Result<(), Error> = this.SetCookie(arg0);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const cookie_getterinfo: JSJitInfo = JSJitInfo {
    call: get_cookie as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const cookie_setterinfo: JSJitInfo = JSJitInfo {
    call: set_cookie as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_lastModified<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DOMString = this.LastModified();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const lastModified_getterinfo: JSJitInfo = JSJitInfo {
    call: get_lastModified as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_readyState<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DocumentReadyState = this.ReadyState();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const readyState_getterinfo: JSJitInfo = JSJitInfo {
    call: get_readyState as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_title<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Title();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_title<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: () = this.SetTitle(arg0);
        pop_current_element_queue();


        return true;
    }), false);
}


const title_getterinfo: JSJitInfo = JSJitInfo {
    call: get_title as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const title_setterinfo: JSJitInfo = JSJitInfo {
    call: set_title as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_body<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: Option<DomRoot<HTMLElement<TH>>> = this.GetBody();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_body<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<DomRoot<HTMLElement<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface HTMLElement.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        push_new_element_queue();

        let result: Result<(), Error> = this.SetBody(arg0.r());
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


const body_getterinfo: JSJitInfo = JSJitInfo {
    call: get_body as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const body_setterinfo: JSJitInfo = JSJitInfo {
    call: set_body as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_head<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DomRoot<HTMLHeadElement<TH>>> = this.GetHead();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const head_getterinfo: JSJitInfo = JSJitInfo {
    call: get_head as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_images<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<HTMLCollection<TH>> = this.Images();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const images_getterinfo: JSJitInfo = JSJitInfo {
    call: get_images as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasNone as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_embeds<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<HTMLCollection<TH>> = this.Embeds();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const embeds_getterinfo: JSJitInfo = JSJitInfo {
    call: get_embeds as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasNone as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_plugins<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<HTMLCollection<TH>> = this.Plugins();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const plugins_getterinfo: JSJitInfo = JSJitInfo {
    call: get_plugins as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasNone as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_links<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<HTMLCollection<TH>> = this.Links();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const links_getterinfo: JSJitInfo = JSJitInfo {
    call: get_links as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasNone as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_forms<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<HTMLCollection<TH>> = this.Forms();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const forms_getterinfo: JSJitInfo = JSJitInfo {
    call: get_forms as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasNone as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_scripts<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<HTMLCollection<TH>> = this.Scripts();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const scripts_getterinfo: JSJitInfo = JSJitInfo {
    call: get_scripts as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasNone as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn getElementsByName<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Document.getElementsByName\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: DomRoot<NodeList<TH>> = this.GetElementsByName(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const getElementsByName_methodinfo: JSJitInfo = JSJitInfo {
    call: getElementsByName as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_currentScript<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DomRoot<HTMLScriptElement<TH>>> = this.GetCurrentScript();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const currentScript_getterinfo: JSJitInfo = JSJitInfo {
    call: get_currentScript as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn open<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<DOMString> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let arg1: DOMString = if args.get(1).is_undefined() {
            DOMString::from("")
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(1), StringificationBehavior::Default) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        push_new_element_queue();

        let result: Result<DomRoot<Document<TH>>, Error> = this.Open(arg0, arg1);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const open_methodinfo: JSJitInfo = JSJitInfo {
    call: open as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn close<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        push_new_element_queue();

        let result: Result<(), Error> = this.Close();
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const close_methodinfo: JSJitInfo = JSJitInfo {
    call: close as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn write<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), StringificationBehavior::Default) {
                    Ok(ConversionResult::Success(strval)) => strval,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                arg0.push(slot);
            }
        }
        push_new_element_queue();

        let result: Result<(), Error> = this.Write(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const write_methodinfo: JSJitInfo = JSJitInfo {
    call: write as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn writeln<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), StringificationBehavior::Default) {
                    Ok(ConversionResult::Success(strval)) => strval,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                arg0.push(slot);
            }
        }
        push_new_element_queue();

        let result: Result<(), Error> = this.Writeln(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const writeln_methodinfo: JSJitInfo = JSJitInfo {
    call: writeln as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_defaultView<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DomRoot<Window<TH>>> = this.GetDefaultView();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const defaultView_getterinfo: JSJitInfo = JSJitInfo {
    call: get_defaultView as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_activeElement<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DomRoot<Element<TH>>> = this.GetActiveElement();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const activeElement_getterinfo: JSJitInfo = JSJitInfo {
    call: get_activeElement as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn hasFocus<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: bool = this.HasFocus();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const hasFocus_methodinfo: JSJitInfo = JSJitInfo {
    call: hasFocus as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_BOOLEAN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onreadystatechange<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnreadystatechange();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onreadystatechange<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnreadystatechange(arg0);

        return true;
    }), false);
}


const onreadystatechange_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onreadystatechange as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onreadystatechange_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onreadystatechange as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_fgColor<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.FgColor();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_fgColor<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: () = this.SetFgColor(arg0);
        pop_current_element_queue();


        return true;
    }), false);
}


const fgColor_getterinfo: JSJitInfo = JSJitInfo {
    call: get_fgColor as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const fgColor_setterinfo: JSJitInfo = JSJitInfo {
    call: set_fgColor as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_bgColor<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.BgColor();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_bgColor<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: () = this.SetBgColor(arg0);
        pop_current_element_queue();


        return true;
    }), false);
}


const bgColor_getterinfo: JSJitInfo = JSJitInfo {
    call: get_bgColor as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const bgColor_setterinfo: JSJitInfo = JSJitInfo {
    call: set_bgColor as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_anchors<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<HTMLCollection<TH>> = this.Anchors();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const anchors_getterinfo: JSJitInfo = JSJitInfo {
    call: get_anchors as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasNone as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_applets<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<HTMLCollection<TH>> = this.Applets();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const applets_getterinfo: JSJitInfo = JSJitInfo {
    call: get_applets as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasNone as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn clear<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.Clear();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const clear_methodinfo: JSJitInfo = JSJitInfo {
    call: clear as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn captureEvents<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.CaptureEvents();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const captureEvents_methodinfo: JSJitInfo = JSJitInfo {
    call: captureEvents as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn releaseEvents<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.ReleaseEvents();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const releaseEvents_methodinfo: JSJitInfo = JSJitInfo {
    call: releaseEvents as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn createTouch<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 7 {
            throw_type_error(cx, "Not enough arguments to \"Document.createTouch\".");
            return false;
        }
        let arg0: DomRoot<Window<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface Window.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: DomRoot<EventTarget<TH>> = if args.get(1).get().is_object() {
            match root_from_handlevalue(args.get(1)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface EventTarget.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg2: i32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: Finite<f64> = match FromJSValConvertible::from_jsval(cx, args.get(3), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg4: Finite<f64> = match FromJSValConvertible::from_jsval(cx, args.get(4), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg5: Finite<f64> = match FromJSValConvertible::from_jsval(cx, args.get(5), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg6: Finite<f64> = match FromJSValConvertible::from_jsval(cx, args.get(6), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: DomRoot<Touch<TH>> = this.CreateTouch(&arg0, &arg1, arg2, arg3, arg4, arg5, arg6);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const createTouch_methodinfo: JSJitInfo = JSJitInfo {
    call: createTouch as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn createTouchList<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        rooted_vec!(let mut arg0);
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: *const Touch<TH> = if args.get(variadicArg).get().is_object() {
                    match native_from_handlevalue(args.get(variadicArg)) {
                        Ok(val) => val,
                        Err(()) => {
                            throw_type_error(cx, "value does not implement interface Touch.");
                            return false;

                        }
                    }

                } else {
                    throw_type_error(cx, "Value is not an object.");
                    return false;

                };
                arg0.push(Dom::from_ref(&*slot));
            }
        }
        let result: DomRoot<TouchList<TH>> = this.CreateTouchList(arg0.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const createTouchList_methodinfo: JSJitInfo = JSJitInfo {
    call: createTouchList as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn elementFromPoint<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"Document.elementFromPoint\".");
            return false;
        }
        let arg0: Finite<f64> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: Finite<f64> = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: Option<DomRoot<Element<TH>>> = this.ElementFromPoint(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const elementFromPoint_methodinfo: JSJitInfo = JSJitInfo {
    call: elementFromPoint as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn elementsFromPoint<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"Document.elementsFromPoint\".");
            return false;
        }
        let arg0: Finite<f64> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: Finite<f64> = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: Vec<DomRoot<Element<TH>>> = this.ElementsFromPoint(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const elementsFromPoint_methodinfo: JSJitInfo = JSJitInfo {
    call: elementsFromPoint as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_styleSheets<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<StyleSheetList<TH>> = this.StyleSheets();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const styleSheets_getterinfo: JSJitInfo = JSJitInfo {
    call: get_styleSheets as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasNone as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_fullscreenEnabled<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: bool = this.FullscreenEnabled();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const fullscreenEnabled_getterinfo: JSJitInfo = JSJitInfo {
    call: get_fullscreenEnabled as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_BOOLEAN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_fullscreenElement<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DomRoot<Element<TH>>> = this.GetFullscreenElement();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const fullscreenElement_getterinfo: JSJitInfo = JSJitInfo {
    call: get_fullscreenElement as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_fullscreen<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: bool = this.Fullscreen();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const fullscreen_getterinfo: JSJitInfo = JSJitInfo {
    call: get_fullscreen as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_BOOLEAN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn exitFullscreen<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Rc<Promise<TH>> = this.ExitFullscreen();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const exitFullscreen_methodinfo: JSJitInfo = JSJitInfo {
    call: exitFullscreen as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onfullscreenchange<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnfullscreenchange();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onfullscreenchange<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnfullscreenchange(arg0);

        return true;
    }), false);
}


const onfullscreenchange_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onfullscreenchange as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onfullscreenchange_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onfullscreenchange as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onfullscreenerror<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnfullscreenerror();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onfullscreenerror<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnfullscreenerror(arg0);

        return true;
    }), false);
}


const onfullscreenerror_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onfullscreenerror as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onfullscreenerror_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onfullscreenerror as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_oncopy<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOncopy();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_oncopy<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOncopy(arg0);

        return true;
    }), false);
}


const oncopy_getterinfo: JSJitInfo = JSJitInfo {
    call: get_oncopy as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const oncopy_setterinfo: JSJitInfo = JSJitInfo {
    call: set_oncopy as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_oncut<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOncut();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_oncut<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOncut(arg0);

        return true;
    }), false);
}


const oncut_getterinfo: JSJitInfo = JSJitInfo {
    call: get_oncut as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const oncut_setterinfo: JSJitInfo = JSJitInfo {
    call: set_oncut as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onpaste<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnpaste();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onpaste<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnpaste(arg0);

        return true;
    }), false);
}


const onpaste_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onpaste as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onpaste_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onpaste as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onabort<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnabort();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onabort<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnabort(arg0);

        return true;
    }), false);
}


const onabort_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onabort as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onabort_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onabort as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onblur<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnblur();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onblur<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnblur(arg0);

        return true;
    }), false);
}


const onblur_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onblur as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onblur_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onblur as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_oncancel<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOncancel();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_oncancel<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOncancel(arg0);

        return true;
    }), false);
}


const oncancel_getterinfo: JSJitInfo = JSJitInfo {
    call: get_oncancel as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const oncancel_setterinfo: JSJitInfo = JSJitInfo {
    call: set_oncancel as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_oncanplay<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOncanplay();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_oncanplay<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOncanplay(arg0);

        return true;
    }), false);
}


const oncanplay_getterinfo: JSJitInfo = JSJitInfo {
    call: get_oncanplay as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const oncanplay_setterinfo: JSJitInfo = JSJitInfo {
    call: set_oncanplay as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_oncanplaythrough<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOncanplaythrough();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_oncanplaythrough<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOncanplaythrough(arg0);

        return true;
    }), false);
}


const oncanplaythrough_getterinfo: JSJitInfo = JSJitInfo {
    call: get_oncanplaythrough as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const oncanplaythrough_setterinfo: JSJitInfo = JSJitInfo {
    call: set_oncanplaythrough as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onchange<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnchange();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onchange<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnchange(arg0);

        return true;
    }), false);
}


const onchange_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onchange as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onchange_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onchange as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onclick<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnclick();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onclick<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnclick(arg0);

        return true;
    }), false);
}


const onclick_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onclick as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onclick_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onclick as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onclose<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnclose();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onclose<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnclose(arg0);

        return true;
    }), false);
}


const onclose_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onclose as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onclose_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onclose as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_oncontextmenu<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOncontextmenu();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_oncontextmenu<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOncontextmenu(arg0);

        return true;
    }), false);
}


const oncontextmenu_getterinfo: JSJitInfo = JSJitInfo {
    call: get_oncontextmenu as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const oncontextmenu_setterinfo: JSJitInfo = JSJitInfo {
    call: set_oncontextmenu as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_oncuechange<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOncuechange();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_oncuechange<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOncuechange(arg0);

        return true;
    }), false);
}


const oncuechange_getterinfo: JSJitInfo = JSJitInfo {
    call: get_oncuechange as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const oncuechange_setterinfo: JSJitInfo = JSJitInfo {
    call: set_oncuechange as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_ondblclick<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOndblclick();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_ondblclick<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOndblclick(arg0);

        return true;
    }), false);
}


const ondblclick_getterinfo: JSJitInfo = JSJitInfo {
    call: get_ondblclick as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const ondblclick_setterinfo: JSJitInfo = JSJitInfo {
    call: set_ondblclick as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_ondrag<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOndrag();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_ondrag<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOndrag(arg0);

        return true;
    }), false);
}


const ondrag_getterinfo: JSJitInfo = JSJitInfo {
    call: get_ondrag as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const ondrag_setterinfo: JSJitInfo = JSJitInfo {
    call: set_ondrag as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_ondragend<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOndragend();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_ondragend<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOndragend(arg0);

        return true;
    }), false);
}


const ondragend_getterinfo: JSJitInfo = JSJitInfo {
    call: get_ondragend as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const ondragend_setterinfo: JSJitInfo = JSJitInfo {
    call: set_ondragend as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_ondragenter<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOndragenter();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_ondragenter<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOndragenter(arg0);

        return true;
    }), false);
}


const ondragenter_getterinfo: JSJitInfo = JSJitInfo {
    call: get_ondragenter as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const ondragenter_setterinfo: JSJitInfo = JSJitInfo {
    call: set_ondragenter as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_ondragexit<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOndragexit();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_ondragexit<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOndragexit(arg0);

        return true;
    }), false);
}


const ondragexit_getterinfo: JSJitInfo = JSJitInfo {
    call: get_ondragexit as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const ondragexit_setterinfo: JSJitInfo = JSJitInfo {
    call: set_ondragexit as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_ondragleave<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOndragleave();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_ondragleave<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOndragleave(arg0);

        return true;
    }), false);
}


const ondragleave_getterinfo: JSJitInfo = JSJitInfo {
    call: get_ondragleave as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const ondragleave_setterinfo: JSJitInfo = JSJitInfo {
    call: set_ondragleave as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_ondragover<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOndragover();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_ondragover<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOndragover(arg0);

        return true;
    }), false);
}


const ondragover_getterinfo: JSJitInfo = JSJitInfo {
    call: get_ondragover as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const ondragover_setterinfo: JSJitInfo = JSJitInfo {
    call: set_ondragover as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_ondragstart<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOndragstart();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_ondragstart<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOndragstart(arg0);

        return true;
    }), false);
}


const ondragstart_getterinfo: JSJitInfo = JSJitInfo {
    call: get_ondragstart as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const ondragstart_setterinfo: JSJitInfo = JSJitInfo {
    call: set_ondragstart as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_ondrop<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOndrop();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_ondrop<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOndrop(arg0);

        return true;
    }), false);
}


const ondrop_getterinfo: JSJitInfo = JSJitInfo {
    call: get_ondrop as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const ondrop_setterinfo: JSJitInfo = JSJitInfo {
    call: set_ondrop as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_ondurationchange<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOndurationchange();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_ondurationchange<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOndurationchange(arg0);

        return true;
    }), false);
}


const ondurationchange_getterinfo: JSJitInfo = JSJitInfo {
    call: get_ondurationchange as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const ondurationchange_setterinfo: JSJitInfo = JSJitInfo {
    call: set_ondurationchange as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onemptied<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnemptied();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onemptied<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnemptied(arg0);

        return true;
    }), false);
}


const onemptied_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onemptied as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onemptied_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onemptied as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onended<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnended();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onended<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnended(arg0);

        return true;
    }), false);
}


const onended_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onended as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onended_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onended as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onerror<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::OnErrorEventHandlerNonNull>> = this.GetOnerror();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onerror<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<OnErrorEventHandlerNonNull>> = if args.get(0).get().is_object() {
            Some(OnErrorEventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnerror(arg0);

        return true;
    }), false);
}


const onerror_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onerror as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onerror_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onerror as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onfocus<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnfocus();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onfocus<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnfocus(arg0);

        return true;
    }), false);
}


const onfocus_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onfocus as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onfocus_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onfocus as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_oninput<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOninput();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_oninput<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOninput(arg0);

        return true;
    }), false);
}


const oninput_getterinfo: JSJitInfo = JSJitInfo {
    call: get_oninput as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const oninput_setterinfo: JSJitInfo = JSJitInfo {
    call: set_oninput as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_oninvalid<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOninvalid();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_oninvalid<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOninvalid(arg0);

        return true;
    }), false);
}


const oninvalid_getterinfo: JSJitInfo = JSJitInfo {
    call: get_oninvalid as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const oninvalid_setterinfo: JSJitInfo = JSJitInfo {
    call: set_oninvalid as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onkeydown<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnkeydown();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onkeydown<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnkeydown(arg0);

        return true;
    }), false);
}


const onkeydown_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onkeydown as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onkeydown_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onkeydown as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onkeypress<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnkeypress();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onkeypress<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnkeypress(arg0);

        return true;
    }), false);
}


const onkeypress_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onkeypress as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onkeypress_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onkeypress as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onkeyup<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnkeyup();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onkeyup<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnkeyup(arg0);

        return true;
    }), false);
}


const onkeyup_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onkeyup as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onkeyup_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onkeyup as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onload<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnload();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onload<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnload(arg0);

        return true;
    }), false);
}


const onload_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onload as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onload_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onload as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onloadeddata<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnloadeddata();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onloadeddata<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnloadeddata(arg0);

        return true;
    }), false);
}


const onloadeddata_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onloadeddata as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onloadeddata_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onloadeddata as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onloadedmetadata<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnloadedmetadata();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onloadedmetadata<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnloadedmetadata(arg0);

        return true;
    }), false);
}


const onloadedmetadata_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onloadedmetadata as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onloadedmetadata_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onloadedmetadata as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onloadstart<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnloadstart();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onloadstart<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnloadstart(arg0);

        return true;
    }), false);
}


const onloadstart_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onloadstart as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onloadstart_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onloadstart as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onmousedown<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnmousedown();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onmousedown<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnmousedown(arg0);

        return true;
    }), false);
}


const onmousedown_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onmousedown as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onmousedown_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onmousedown as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onmouseenter<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnmouseenter();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onmouseenter<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnmouseenter(arg0);

        return true;
    }), false);
}


const onmouseenter_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onmouseenter as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onmouseenter_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onmouseenter as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onmouseleave<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnmouseleave();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onmouseleave<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnmouseleave(arg0);

        return true;
    }), false);
}


const onmouseleave_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onmouseleave as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onmouseleave_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onmouseleave as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onmousemove<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnmousemove();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onmousemove<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnmousemove(arg0);

        return true;
    }), false);
}


const onmousemove_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onmousemove as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onmousemove_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onmousemove as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onmouseout<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnmouseout();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onmouseout<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnmouseout(arg0);

        return true;
    }), false);
}


const onmouseout_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onmouseout as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onmouseout_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onmouseout as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onmouseover<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnmouseover();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onmouseover<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnmouseover(arg0);

        return true;
    }), false);
}


const onmouseover_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onmouseover as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onmouseover_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onmouseover as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onmouseup<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnmouseup();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onmouseup<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnmouseup(arg0);

        return true;
    }), false);
}


const onmouseup_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onmouseup as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onmouseup_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onmouseup as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onwheel<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnwheel();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onwheel<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnwheel(arg0);

        return true;
    }), false);
}


const onwheel_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onwheel as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onwheel_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onwheel as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onpause<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnpause();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onpause<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnpause(arg0);

        return true;
    }), false);
}


const onpause_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onpause as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onpause_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onpause as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onplay<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnplay();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onplay<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnplay(arg0);

        return true;
    }), false);
}


const onplay_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onplay as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onplay_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onplay as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onplaying<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnplaying();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onplaying<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnplaying(arg0);

        return true;
    }), false);
}


const onplaying_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onplaying as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onplaying_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onplaying as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onprogress<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnprogress();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onprogress<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnprogress(arg0);

        return true;
    }), false);
}


const onprogress_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onprogress as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onprogress_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onprogress as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onratechange<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnratechange();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onratechange<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnratechange(arg0);

        return true;
    }), false);
}


const onratechange_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onratechange as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onratechange_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onratechange as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onreset<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnreset();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onreset<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnreset(arg0);

        return true;
    }), false);
}


const onreset_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onreset as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onreset_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onreset as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onresize<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnresize();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onresize<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnresize(arg0);

        return true;
    }), false);
}


const onresize_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onresize as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onresize_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onresize as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onscroll<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnscroll();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onscroll<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnscroll(arg0);

        return true;
    }), false);
}


const onscroll_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onscroll as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onscroll_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onscroll as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onseeked<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnseeked();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onseeked<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnseeked(arg0);

        return true;
    }), false);
}


const onseeked_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onseeked as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onseeked_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onseeked as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onseeking<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnseeking();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onseeking<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnseeking(arg0);

        return true;
    }), false);
}


const onseeking_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onseeking as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onseeking_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onseeking as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onselect<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnselect();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onselect<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnselect(arg0);

        return true;
    }), false);
}


const onselect_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onselect as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onselect_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onselect as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onshow<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnshow();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onshow<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnshow(arg0);

        return true;
    }), false);
}


const onshow_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onshow as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onshow_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onshow as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onstalled<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnstalled();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onstalled<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnstalled(arg0);

        return true;
    }), false);
}


const onstalled_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onstalled as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onstalled_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onstalled as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onsubmit<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnsubmit();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onsubmit<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnsubmit(arg0);

        return true;
    }), false);
}


const onsubmit_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onsubmit as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onsubmit_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onsubmit as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onsuspend<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnsuspend();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onsuspend<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnsuspend(arg0);

        return true;
    }), false);
}


const onsuspend_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onsuspend as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onsuspend_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onsuspend as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_ontimeupdate<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOntimeupdate();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_ontimeupdate<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOntimeupdate(arg0);

        return true;
    }), false);
}


const ontimeupdate_getterinfo: JSJitInfo = JSJitInfo {
    call: get_ontimeupdate as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const ontimeupdate_setterinfo: JSJitInfo = JSJitInfo {
    call: set_ontimeupdate as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_ontoggle<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOntoggle();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_ontoggle<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOntoggle(arg0);

        return true;
    }), false);
}


const ontoggle_getterinfo: JSJitInfo = JSJitInfo {
    call: get_ontoggle as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const ontoggle_setterinfo: JSJitInfo = JSJitInfo {
    call: set_ontoggle as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onvolumechange<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnvolumechange();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onvolumechange<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnvolumechange(arg0);

        return true;
    }), false);
}


const onvolumechange_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onvolumechange as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onvolumechange_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onvolumechange as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onwaiting<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnwaiting();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onwaiting<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnwaiting(arg0);

        return true;
    }), false);
}


const onwaiting_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onwaiting as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onwaiting_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onwaiting as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_ontransitionend<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOntransitionend();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_ontransitionend<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Document<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOntransitionend(arg0);

        return true;
    }), false);
}


const ontransitionend_getterinfo: JSJitInfo = JSJitInfo {
    call: get_ontransitionend as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const ontransitionend_setterinfo: JSJitInfo = JSJitInfo {
    call: set_ontransitionend as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn getElementById<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Document.getElementById\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: Option<DomRoot<Element<TH>>> = this.GetElementById(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

const getElementById_methodinfo_argTypes: [i32; 2] = [ JSJitInfo_ArgType::String as i32, JSJitInfo_ArgType::ArgTypeListEnd as i32 ];
const getElementById_methodinfo: JSTypedMethodJitInfo = JSTypedMethodJitInfo {
    base:   JSJitInfo {
      call: getElementById as *const os::raw::c_void,
      protoID: PrototypeList::ID::Document as u16,
      depth: 2,
      _bitfield_1: new_jsjitinfo_bitfield_1!(
          JSJitInfo_OpType::Method as u8,
          JSJitInfo_AliasSet::AliasDOMSets as u8,
          JSValueType::JSVAL_TYPE_UNKNOWN as u8,
          false,
          true,
          false,
          false,
          false,
          true,
          0,
      ),
  },
    argTypes: &getElementById_methodinfo_argTypes as *const _ as *const JSJitInfo_ArgType,
};

unsafe extern fn get_children<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<HTMLCollection<TH>> = this.Children();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const children_getterinfo: JSJitInfo = JSJitInfo {
    call: get_children as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasNone as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_firstElementChild<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DomRoot<Element<TH>>> = this.GetFirstElementChild();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const firstElementChild_getterinfo: JSJitInfo = JSJitInfo {
    call: get_firstElementChild as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasDOMSets as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_lastElementChild<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DomRoot<Element<TH>>> = this.GetLastElementChild();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const lastElementChild_getterinfo: JSJitInfo = JSJitInfo {
    call: get_lastElementChild as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasDOMSets as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_childElementCount<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: u32 = this.ChildElementCount();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const childElementCount_getterinfo: JSJitInfo = JSJitInfo {
    call: get_childElementCount as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasDOMSets as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn prepend<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: UnionTypes::NodeOrString<TH> = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(value)) => value,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                arg0.push(slot);
            }
        }
        push_new_element_queue();

        let result: Result<(), Error> = this.Prepend(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const prepend_methodinfo: JSJitInfo = JSJitInfo {
    call: prepend as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn append<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: UnionTypes::NodeOrString<TH> = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(value)) => value,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                arg0.push(slot);
            }
        }
        push_new_element_queue();

        let result: Result<(), Error> = this.Append(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const append_methodinfo: JSJitInfo = JSJitInfo {
    call: append as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn querySelector<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Document.querySelector\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: Result<Option<DomRoot<Element<TH>>>, Error> = this.QuerySelector(arg0);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

const querySelector_methodinfo_argTypes: [i32; 2] = [ JSJitInfo_ArgType::String as i32, JSJitInfo_ArgType::ArgTypeListEnd as i32 ];
const querySelector_methodinfo: JSTypedMethodJitInfo = JSTypedMethodJitInfo {
    base:   JSJitInfo {
      call: querySelector as *const os::raw::c_void,
      protoID: PrototypeList::ID::Document as u16,
      depth: 2,
      _bitfield_1: new_jsjitinfo_bitfield_1!(
          JSJitInfo_OpType::Method as u8,
          JSJitInfo_AliasSet::AliasDOMSets as u8,
          JSValueType::JSVAL_TYPE_UNKNOWN as u8,
          false,
          false,
          false,
          false,
          false,
          true,
          0,
      ),
  },
    argTypes: &querySelector_methodinfo_argTypes as *const _ as *const JSJitInfo_ArgType,
};

unsafe extern fn querySelectorAll<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Document<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Document.querySelectorAll\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: Result<DomRoot<NodeList<TH>>, Error> = this.QuerySelectorAll(arg0);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const querySelectorAll_methodinfo: JSJitInfo = JSJitInfo {
    call: querySelectorAll as *const os::raw::c_void,
    protoID: PrototypeList::ID::Document as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn _finalize<TH: TypeHolderTrait>
(_fop: *mut JSFreeOp, obj: *mut JSObject) {
    return wrap_panic(panic::AssertUnwindSafe(|| {

        let this = native_from_object::<Document<TH>, TH>(obj).unwrap();
            if !this.is_null() {
                // The pointer can be null if the object is the unforgeable holder of that interface.
                let _ = Box::from_raw(this as *mut Document<TH>);
            }
            debug!("Document<TH> finalize: {:p}", this);
    }), ());
}

unsafe extern fn _trace<TH: TypeHolderTrait>
(trc: *mut JSTracer, obj: *mut JSObject) {
    return wrap_panic(panic::AssertUnwindSafe(|| {

        let this = native_from_object::<Document<TH>, TH>(obj).unwrap();
        if this.is_null() { return; } // GC during obj creation
        (*this).trace(trc);
    }), ());
}

pub unsafe fn DefineProxyHandler<TH: TypeHolderTrait>
() -> *const libc::c_void {
    let traps = ProxyTraps {
        enter: None,
        getOwnPropertyDescriptor: Some(getOwnPropertyDescriptor),
        defineProperty: Some(proxyhandler::define_property),
        ownPropertyKeys: Some(own_property_keys),
        delete_: Some(proxyhandler::delete),
        enumerate: None,
        getPrototypeIfOrdinary: Some(proxyhandler::get_prototype_if_ordinary),
        preventExtensions: Some(proxyhandler::prevent_extensions),
        isExtensible: Some(proxyhandler::is_extensible),
        has: None,
        get: Some(get),
        set: None,
        call: None,
        construct: None,
        getPropertyDescriptor: Some(get_property_descriptor),
        hasOwn: Some(hasOwn),
        getOwnEnumerablePropertyKeys: Some(own_property_keys),
        nativeCall: None,
        hasInstance: None,
        objectClassIs: None,
        className: Some(className),
        fun_toString: None,
        boxedValue_unbox: None,
        defaultValue: None,
        trace: Some(_trace),
        finalize: Some(_finalize),
        objectMoved: None,
        isCallable: None,
        isConstructor: None,
    };

    CreateProxyHandler(&traps, Class.as_void_ptr())
}

#[inline] unsafe fn UnwrapProxy<TH: TypeHolderTrait>
(obj: RawHandleObject) -> *const Document<TH> {
    /*if (xpc::WrapperFactory::IsXrayWrapper(obj)) {
        obj = js::UnwrapObject(obj);
    }*/
    //MOZ_ASSERT(IsProxy(obj));
    let box_ = GetProxyPrivate(obj.get()).to_private() as *const Document<TH>;
    return box_;
}

static Class: DOMClass = DOMClass {
    interface_chain: [ PrototypeList::ID::EventTarget, PrototypeList::ID::Node, PrototypeList::ID::Document, PrototypeList::ID::Last, PrototypeList::ID::Last, PrototypeList::ID::Last ],
    type_id: ::dom::bindings::codegen::InheritTypes::TopTypeId { eventtarget: (::dom::bindings::codegen::InheritTypes::EventTargetTypeId::Node(::dom::bindings::codegen::InheritTypes::NodeTypeId::Document(::dom::bindings::codegen::InheritTypes::DocumentTypeId::Document))) },
    global: InterfaceObjectMap::Globals::EMPTY,
};

unsafe extern fn own_property_keys<TH: TypeHolderTrait>
(cx: *mut JSContext, proxy: RawHandleObject, props: *mut AutoIdVector) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let unwrapped_proxy = UnwrapProxy(proxy);
        for name in (*unwrapped_proxy).SupportedPropertyNames() {
            let cstring = CString::new(name).unwrap();
            let jsstring = JS_AtomizeAndPinString(cx, cstring.as_ptr());
            rooted!(in(cx) let rooted = jsstring);
            let jsid = INTERNED_STRING_TO_JSID(cx, rooted.handle().get());
            rooted!(in(cx) let rooted_jsid = jsid);
            AppendToAutoIdVector(props, rooted_jsid.handle().get());
        }
        rooted!(in(cx) let mut expando = ptr::null_mut::<JSObject>());
        get_expando_object(proxy, expando.handle_mut());
        if !expando.is_null() {
            GetPropertyKeys(cx, expando.handle(), JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, props);
        }

        return true;

    }), false);
}

unsafe extern fn getOwnPropertyDescriptor<TH: TypeHolderTrait>
(cx: *mut JSContext, proxy: RawHandleObject, id: RawHandleId, desc: RawMutableHandle<PropertyDescriptor>) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        rooted!(in(cx) let mut expando = ptr::null_mut::<JSObject>());
        get_expando_object(proxy, expando.handle_mut());
        //if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = GetExpandoObject(proxy))) {
        let proxy_lt = Handle::from_raw(proxy);
        let id_lt = Handle::from_raw(id);
        if !expando.is_null() {
            if !JS_GetPropertyDescriptorById(cx, expando.handle().into(), id, desc) {
                return false;
            }
            if !desc.obj.is_null() {
                // Pretend the property lives on the wrapper.
                desc.get().obj = proxy.get();
                return true;
            }
        }

        if RUST_JSID_IS_STRING(id) || RUST_JSID_IS_INT(id) {
            let mut has_on_proto = false;
            if !has_property_on_prototype(cx, proxy_lt, id_lt, &mut has_on_proto) {
                return false;
            }
            if !has_on_proto {
                        let name = jsid_to_string(cx, Handle::from_raw(id)).expect("Not a string-convertible JSID?");
                let this = UnwrapProxy(proxy);
                let this = &*this;
                let result: Option<NonNull<JSObject>> = this.NamedGetter(cx, name);

                if let Some(result) = result {
                    rooted!(in(cx) let mut result_root = UndefinedValue());
                    (result).to_jsval(cx, result_root.handle_mut());
                    desc.get().value = result_root.get();
                    fill_property_descriptor(MutableHandle::from_raw(desc), proxy.get(), JSPROP_ENUMERATE | JSPROP_READONLY);
                    return true;
                }
            }
        }
        desc.get().obj = ptr::null_mut();
        return true;
    }), false);
}

unsafe extern fn className<TH: TypeHolderTrait>
(cx: *mut JSContext, _proxy: RawHandleObject) -> *const i8 {
    b"Document\0" as *const u8 as *const i8
}

unsafe extern fn get<TH: TypeHolderTrait>
(cx: *mut JSContext, proxy: RawHandleObject, receiver: RawHandleValue, id: RawHandleId, vp: RawMutableHandleValue) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        //MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
        //"Should not have a XrayWrapper here");
        let proxy_lt = Handle::from_raw(proxy);
        let vp_lt = MutableHandle::from_raw(vp);
        let id_lt = Handle::from_raw(id);
        let receiver_lt = Handle::from_raw(receiver);

        rooted!(in(cx) let mut expando = ptr::null_mut::<JSObject>());
        get_expando_object(proxy, expando.handle_mut());
        if !expando.is_null() {
            let mut hasProp = false;
            if !JS_HasPropertyById(cx, expando.handle().into(), id, &mut hasProp) {
                return false;
            }

            if hasProp {
                return JS_ForwardGetPropertyTo(cx, expando.handle().into(), id, receiver, vp);
            }
        }

        let mut found = false;
        if !get_property_on_prototype(cx, proxy_lt, receiver_lt, id_lt, &mut found, vp_lt) {
            return false;
        }

        if found {
            return true;
        }
        if RUST_JSID_IS_STRING(id) || RUST_JSID_IS_INT(id) {
            let name = jsid_to_string(cx, Handle::from_raw(id)).expect("Not a string-convertible JSID?");
            let this = UnwrapProxy(proxy);
            let this = &*this;
            let result: Option<NonNull<JSObject>> = this.NamedGetter(cx, name);

            if let Some(result) = result {

                (result).to_jsval(cx, vp_lt);
                return true;
            }}

        vp.set(UndefinedValue());
        return true;
    }), false);
}

unsafe extern fn hasOwn<TH: TypeHolderTrait>
(cx: *mut JSContext, proxy: RawHandleObject, id: RawHandleId, bp: *mut bool) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        rooted!(in(cx) let mut expando = ptr::null_mut::<JSObject>());
        let proxy_lt = Handle::from_raw(proxy);
        let id_lt = Handle::from_raw(id);
        get_expando_object(proxy, expando.handle_mut());
        if !expando.is_null() {
            let ok = JS_HasPropertyById(cx, expando.handle().into(), id, bp);
            if !ok || *bp {
                return ok;
            }
        }
        if RUST_JSID_IS_STRING(id) || RUST_JSID_IS_INT(id) {
            let mut has_on_proto = false;
            if !has_property_on_prototype(cx, proxy_lt, id_lt, &mut has_on_proto) {
                return false;
            }
            if !has_on_proto {
                        let name = jsid_to_string(cx, Handle::from_raw(id)).expect("Not a string-convertible JSID?");
                let this = UnwrapProxy(proxy);
                let this = &*this;
                let result: Option<NonNull<JSObject>> = this.NamedGetter(cx, name);

                *bp = result.is_some();
                return true;
            }
        }

        *bp = false;
        return true;
    }), false);
}

pub unsafe fn Wrap<TH: TypeHolderTrait>
(cx: *mut JSContext, scope: &GlobalScope<TH>, object: Box<Document<TH>>) -> DomRoot<Document<TH>> {
    let scope = scope.reflector().get_jsobject();
    assert!(!scope.get().is_null());
    assert!(((*get_object_class(scope.get())).flags & JSCLASS_IS_GLOBAL) != 0);

    rooted!(in(cx) let mut proto = ptr::null_mut::<JSObject>());
    let _ac = JSAutoCompartment::new(cx, scope.get());
    GetProtoObject(cx, scope, proto.handle_mut());
    assert!(!proto.is_null());

    let raw = Box::into_raw(object);
    let _rt = RootedTraceable::new(&*raw);

    let handler = RegisterBindings::PROXY_HANDLERS[PrototypeList::Proxies::Document as usize];
    rooted!(in(cx) let private = PrivateValue(raw as *const libc::c_void));
    let obj = NewProxyObject(cx, handler,
                             private.handle(),
                             proto.get(), scope.get(),
                             ptr::null_mut(), ptr::null_mut());
    assert!(!obj.is_null());
    rooted!(in(cx) let obj = obj);

    rooted!(in(cx) let mut expando = ptr::null_mut::<JSObject>());
    ensure_expando_object(cx, obj.handle().into(), expando.handle_mut());
    rooted!(in(cx) let mut unforgeable_holder = ptr::null_mut::<JSObject>());
    unforgeable_holder.handle_mut().set(
        JS_GetReservedSlot(proto.get(), DOM_PROTO_UNFORGEABLE_HOLDER_SLOT).to_object());
    assert!(JS_InitializePropertiesFromCompatibleNativeObject(cx, expando.handle(), unforgeable_holder.handle()));

    (*raw).init_reflector(obj.get());

    DomRoot::from_ref(&*raw)
}

const unscopable_names: &'static [&'static [u8]] = &[
    b"prepend\0",
    b"append\0"
];

impl<TH: TypeHolderTrait> IDLInterface for Document<TH> {
    #[inline]
    fn derives(class: &'static DOMClass) -> bool {
        class.interface_chain[2] == PrototypeList::ID::Document
    }
}

impl<TH: TypeHolderTrait> PartialEq for Document<TH> {
    fn eq(&self, other: &Document<TH>) -> bool {
        self as *const Document<TH> == &*other
    }
}

pub trait DocumentMethods<TH: TypeHolderTrait> {
    fn Implementation(&self) -> DomRoot<DOMImplementation<TH>>;
    fn URL(&self) -> USVString;
    fn DocumentURI(&self) -> USVString;
    fn CompatMode(&self) -> DOMString;
    fn CharacterSet(&self) -> DOMString;
    fn Charset(&self) -> DOMString;
    fn InputEncoding(&self) -> DOMString;
    fn ContentType(&self) -> DOMString;
    fn GetDoctype(&self) -> Option<DomRoot<DocumentType<TH>>>;
    fn GetDocumentElement(&self) -> Option<DomRoot<Element<TH>>>;
    fn GetElementsByTagName(&self, qualifiedName: DOMString) -> DomRoot<HTMLCollection<TH>>;
    fn GetElementsByTagNameNS(&self, namespace: Option<DOMString>, qualifiedName: DOMString) -> DomRoot<HTMLCollection<TH>>;
    fn GetElementsByClassName(&self, classNames: DOMString) -> DomRoot<HTMLCollection<TH>>;
    fn CreateElement(&self, localName: DOMString, options: &dom::bindings::codegen::Bindings::DocumentBinding::ElementCreationOptions) -> Fallible<DomRoot<Element<TH>>, TH>;
    fn CreateElementNS(&self, namespace: Option<DOMString>, qualifiedName: DOMString, options: &dom::bindings::codegen::Bindings::DocumentBinding::ElementCreationOptions) -> Fallible<DomRoot<Element<TH>>, TH>;
    fn CreateDocumentFragment(&self) -> DomRoot<DocumentFragment<TH>>;
    fn CreateTextNode(&self, data: DOMString) -> DomRoot<Text<TH>>;
    fn CreateComment(&self, data: DOMString) -> DomRoot<Comment<TH>>;
    fn CreateProcessingInstruction(&self, target: DOMString, data: DOMString) -> Fallible<DomRoot<ProcessingInstruction<TH>>, TH>;
    fn ImportNode(&self, node: &Node<TH>, deep: bool) -> Fallible<DomRoot<Node<TH>>, TH>;
    fn AdoptNode(&self, node: &Node<TH>) -> Fallible<DomRoot<Node<TH>>, TH>;
    fn CreateAttribute(&self, localName: DOMString) -> Fallible<DomRoot<Attr<TH>>, TH>;
    fn CreateAttributeNS(&self, namespace: Option<DOMString>, qualifiedName: DOMString) -> Fallible<DomRoot<Attr<TH>>, TH>;
    fn CreateEvent(&self, interface_: DOMString) -> Fallible<DomRoot<Event<TH>>, TH>;
    fn CreateRange(&self) -> DomRoot<Range<TH>>;
    fn CreateNodeIterator(&self, root: &Node<TH>, whatToShow: u32, filter: Option<Rc<dom::bindings::codegen::Bindings::NodeFilterBinding::NodeFilter<TH>>>) -> DomRoot<NodeIterator<TH>>;
    fn CreateTreeWalker(&self, root: &Node<TH>, whatToShow: u32, filter: Option<Rc<dom::bindings::codegen::Bindings::NodeFilterBinding::NodeFilter<TH>>>) -> DomRoot<TreeWalker<TH>>;
    fn GetLocation(&self) -> Option<DomRoot<Location<TH>>>;
    fn Domain(&self) -> DOMString;
    fn SetDomain(&self, value: DOMString) -> ErrorResult<TH>;
    fn Referrer(&self) -> DOMString;
    fn GetCookie(&self) -> Fallible<DOMString, TH>;
    fn SetCookie(&self, value: DOMString) -> ErrorResult<TH>;
    fn LastModified(&self) -> DOMString;
    fn ReadyState(&self) -> DocumentReadyState;
    fn Title(&self) -> DOMString;
    fn SetTitle(&self, value: DOMString) -> ();
    fn GetBody(&self) -> Option<DomRoot<HTMLElement<TH>>>;
    fn SetBody(&self, value: Option<&HTMLElement<TH>>) -> ErrorResult<TH>;
    fn GetHead(&self) -> Option<DomRoot<HTMLHeadElement<TH>>>;
    fn Images(&self) -> DomRoot<HTMLCollection<TH>>;
    fn Embeds(&self) -> DomRoot<HTMLCollection<TH>>;
    fn Plugins(&self) -> DomRoot<HTMLCollection<TH>>;
    fn Links(&self) -> DomRoot<HTMLCollection<TH>>;
    fn Forms(&self) -> DomRoot<HTMLCollection<TH>>;
    fn Scripts(&self) -> DomRoot<HTMLCollection<TH>>;
    fn GetElementsByName(&self, elementName: DOMString) -> DomRoot<NodeList<TH>>;
    fn GetCurrentScript(&self) -> Option<DomRoot<HTMLScriptElement<TH>>>;
    fn Open(&self, type_: Option<DOMString>, replace: DOMString) -> Fallible<DomRoot<Document<TH>>, TH>;
    fn Close(&self) -> Fallible<(), TH>;
    fn Write(&self, text: Vec<DOMString>) -> Fallible<(), TH>;
    fn Writeln(&self, text: Vec<DOMString>) -> Fallible<(), TH>;
    fn GetDefaultView(&self) -> Option<DomRoot<Window<TH>>>;
    fn GetActiveElement(&self) -> Option<DomRoot<Element<TH>>>;
    fn HasFocus(&self) -> bool;
    fn GetOnreadystatechange(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnreadystatechange(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn FgColor(&self) -> DOMString;
    fn SetFgColor(&self, value: DOMString) -> ();
    fn BgColor(&self) -> DOMString;
    fn SetBgColor(&self, value: DOMString) -> ();
    fn Anchors(&self) -> DomRoot<HTMLCollection<TH>>;
    fn Applets(&self) -> DomRoot<HTMLCollection<TH>>;
    fn Clear(&self) -> ();
    fn CaptureEvents(&self) -> ();
    fn ReleaseEvents(&self) -> ();
    fn CreateTouch(&self, view: &Window<TH>, target: &EventTarget<TH>, identifier: i32, pageX: Finite<f64>, pageY: Finite<f64>, screenX: Finite<f64>, screenY: Finite<f64>) -> DomRoot<Touch<TH>>;
    fn CreateTouchList(&self, touches: &[&Touch<TH>]) -> DomRoot<TouchList<TH>>;
    fn ElementFromPoint(&self, x: Finite<f64>, y: Finite<f64>) -> Option<DomRoot<Element<TH>>>;
    fn ElementsFromPoint(&self, x: Finite<f64>, y: Finite<f64>) -> Vec<DomRoot<Element<TH>>>;
    fn StyleSheets(&self) -> DomRoot<StyleSheetList<TH>>;
    fn FullscreenEnabled(&self) -> bool;
    fn GetFullscreenElement(&self) -> Option<DomRoot<Element<TH>>>;
    fn Fullscreen(&self) -> bool;
    fn ExitFullscreen(&self) -> Rc<Promise<TH>>;
    fn GetOnfullscreenchange(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnfullscreenchange(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnfullscreenerror(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnfullscreenerror(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOncopy(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOncopy(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOncut(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOncut(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnpaste(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnpaste(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnabort(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnabort(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnblur(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnblur(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOncancel(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOncancel(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOncanplay(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOncanplay(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOncanplaythrough(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOncanplaythrough(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnchange(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnchange(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnclick(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnclick(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnclose(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnclose(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOncontextmenu(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOncontextmenu(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOncuechange(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOncuechange(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOndblclick(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOndblclick(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOndrag(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOndrag(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOndragend(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOndragend(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOndragenter(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOndragenter(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOndragexit(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOndragexit(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOndragleave(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOndragleave(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOndragover(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOndragover(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOndragstart(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOndragstart(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOndrop(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOndrop(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOndurationchange(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOndurationchange(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnemptied(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnemptied(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnended(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnended(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnerror(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::OnErrorEventHandlerNonNull<TH>>>;
    fn SetOnerror(&self, value: Option<Rc<OnErrorEventHandlerNonNull<TH>>>) -> ();
    fn GetOnfocus(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnfocus(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOninput(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOninput(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOninvalid(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOninvalid(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnkeydown(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnkeydown(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnkeypress(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnkeypress(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnkeyup(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnkeyup(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnload(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnload(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnloadeddata(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnloadeddata(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnloadedmetadata(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnloadedmetadata(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnloadstart(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnloadstart(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnmousedown(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnmousedown(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnmouseenter(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnmouseenter(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnmouseleave(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnmouseleave(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnmousemove(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnmousemove(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnmouseout(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnmouseout(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnmouseover(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnmouseover(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnmouseup(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnmouseup(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnwheel(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnwheel(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnpause(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnpause(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnplay(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnplay(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnplaying(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnplaying(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnprogress(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnprogress(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnratechange(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnratechange(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnreset(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnreset(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnresize(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnresize(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnscroll(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnscroll(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnseeked(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnseeked(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnseeking(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnseeking(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnselect(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnselect(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnshow(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnshow(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnstalled(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnstalled(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnsubmit(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnsubmit(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnsuspend(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnsuspend(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOntimeupdate(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOntimeupdate(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOntoggle(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOntoggle(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnvolumechange(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnvolumechange(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnwaiting(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnwaiting(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOntransitionend(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOntransitionend(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetElementById(&self, elementId: DOMString) -> Option<DomRoot<Element<TH>>>;
    fn Children(&self) -> DomRoot<HTMLCollection<TH>>;
    fn GetFirstElementChild(&self) -> Option<DomRoot<Element<TH>>>;
    fn GetLastElementChild(&self) -> Option<DomRoot<Element<TH>>>;
    fn ChildElementCount(&self) -> u32;
    fn Prepend(&self, nodes: Vec<UnionTypes::NodeOrString<TH>>) -> Fallible<(), TH>;
    fn Append(&self, nodes: Vec<UnionTypes::NodeOrString<TH>>) -> Fallible<(), TH>;
    fn QuerySelector(&self, selectors: DOMString) -> Fallible<Option<DomRoot<Element<TH>>>, TH>;
    fn QuerySelectorAll(&self, selectors: DOMString) -> Fallible<DomRoot<NodeList<TH>>, TH>;
    fn SupportedPropertyNames(&self) -> Vec<DOMString>;
    unsafe fn NamedGetter(&self, cx: *mut JSContext, name: DOMString) -> Option<NonNull<JSObject>>;
}
const sMethods_specs: &'static [&'static[JSFunctionSpec]] = &[
&[
    JSFunctionSpec {
        name: b"getElementsByTagName\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getElementsByTagName_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getElementsByTagNameNS\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getElementsByTagNameNS_methodinfo as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getElementsByClassName\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getElementsByClassName_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"createElement\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &createElement_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"createElementNS\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &createElementNS_methodinfo as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"createDocumentFragment\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &createDocumentFragment_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"createTextNode\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &createTextNode_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"createComment\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &createComment_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"createProcessingInstruction\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &createProcessingInstruction_methodinfo as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"importNode\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &importNode_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"adoptNode\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &adoptNode_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"createAttribute\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &createAttribute_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"createAttributeNS\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &createAttributeNS_methodinfo as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"createEvent\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &createEvent_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"createRange\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &createRange_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"createNodeIterator\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &createNodeIterator_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"createTreeWalker\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &createTreeWalker_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getElementsByName\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getElementsByName_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"open\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &open_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"close\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &close_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"write\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &write_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"writeln\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &writeln_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"hasFocus\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &hasFocus_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"clear\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &clear_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"captureEvents\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &captureEvents_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"releaseEvents\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &releaseEvents_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"createTouch\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &createTouch_methodinfo as *const _ as *const JSJitInfo },
        nargs: 7,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"createTouchList\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &createTouchList_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"elementFromPoint\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &elementFromPoint_methodinfo as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"elementsFromPoint\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &elementsFromPoint_methodinfo as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"exitFullscreen\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &exitFullscreen_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getElementById\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getElementById_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"prepend\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &prepend_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"append\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &append_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"querySelector\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &querySelector_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"querySelectorAll\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &querySelectorAll_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]

];
const sMethods: &'static [Guard<&'static [JSFunctionSpec]>] = &[
    Guard::new(Condition::Satisfied, sMethods_specs[0])
];
const sAttributes_specs: &'static [&'static[JSPropertySpec]] = &[
&[
    JSPropertySpec {
        name: b"implementation\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &implementation_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"URL\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &URL_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"documentURI\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &documentURI_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"compatMode\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &compatMode_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"characterSet\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &characterSet_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"charset\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &charset_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"inputEncoding\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &inputEncoding_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"contentType\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &contentType_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"doctype\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &doctype_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"documentElement\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &documentElement_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"domain\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &domain_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &domain_setterinfo }
    },
    JSPropertySpec {
        name: b"referrer\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &referrer_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"cookie\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &cookie_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &cookie_setterinfo }
    },
    JSPropertySpec {
        name: b"lastModified\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &lastModified_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"readyState\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &readyState_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"title\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &title_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &title_setterinfo }
    },
    JSPropertySpec {
        name: b"body\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &body_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &body_setterinfo }
    },
    JSPropertySpec {
        name: b"head\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &head_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"images\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &images_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"embeds\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &embeds_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"plugins\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &plugins_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"links\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &links_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"forms\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &forms_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"scripts\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &scripts_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"currentScript\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &currentScript_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"defaultView\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &defaultView_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"activeElement\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &activeElement_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"onreadystatechange\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_lenient_getter), info: &onreadystatechange_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_lenient_setter), info: &onreadystatechange_setterinfo }
    },
    JSPropertySpec {
        name: b"fgColor\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &fgColor_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &fgColor_setterinfo }
    },
    JSPropertySpec {
        name: b"bgColor\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &bgColor_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &bgColor_setterinfo }
    },
    JSPropertySpec {
        name: b"anchors\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &anchors_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"applets\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &applets_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"styleSheets\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &styleSheets_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"fullscreenEnabled\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &fullscreenEnabled_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"fullscreenElement\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &fullscreenElement_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"fullscreen\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &fullscreen_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"onfullscreenchange\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onfullscreenchange_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onfullscreenchange_setterinfo }
    },
    JSPropertySpec {
        name: b"onfullscreenerror\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onfullscreenerror_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onfullscreenerror_setterinfo }
    },
    JSPropertySpec {
        name: b"oncopy\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &oncopy_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &oncopy_setterinfo }
    },
    JSPropertySpec {
        name: b"oncut\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &oncut_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &oncut_setterinfo }
    },
    JSPropertySpec {
        name: b"onpaste\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onpaste_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onpaste_setterinfo }
    },
    JSPropertySpec {
        name: b"onabort\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onabort_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onabort_setterinfo }
    },
    JSPropertySpec {
        name: b"onblur\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onblur_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onblur_setterinfo }
    },
    JSPropertySpec {
        name: b"oncancel\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &oncancel_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &oncancel_setterinfo }
    },
    JSPropertySpec {
        name: b"oncanplay\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &oncanplay_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &oncanplay_setterinfo }
    },
    JSPropertySpec {
        name: b"oncanplaythrough\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &oncanplaythrough_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &oncanplaythrough_setterinfo }
    },
    JSPropertySpec {
        name: b"onchange\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onchange_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onchange_setterinfo }
    },
    JSPropertySpec {
        name: b"onclick\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onclick_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onclick_setterinfo }
    },
    JSPropertySpec {
        name: b"onclose\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onclose_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onclose_setterinfo }
    },
    JSPropertySpec {
        name: b"oncontextmenu\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &oncontextmenu_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &oncontextmenu_setterinfo }
    },
    JSPropertySpec {
        name: b"oncuechange\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &oncuechange_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &oncuechange_setterinfo }
    },
    JSPropertySpec {
        name: b"ondblclick\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &ondblclick_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &ondblclick_setterinfo }
    },
    JSPropertySpec {
        name: b"ondrag\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &ondrag_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &ondrag_setterinfo }
    },
    JSPropertySpec {
        name: b"ondragend\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &ondragend_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &ondragend_setterinfo }
    },
    JSPropertySpec {
        name: b"ondragenter\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &ondragenter_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &ondragenter_setterinfo }
    },
    JSPropertySpec {
        name: b"ondragexit\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &ondragexit_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &ondragexit_setterinfo }
    },
    JSPropertySpec {
        name: b"ondragleave\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &ondragleave_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &ondragleave_setterinfo }
    },
    JSPropertySpec {
        name: b"ondragover\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &ondragover_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &ondragover_setterinfo }
    },
    JSPropertySpec {
        name: b"ondragstart\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &ondragstart_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &ondragstart_setterinfo }
    },
    JSPropertySpec {
        name: b"ondrop\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &ondrop_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &ondrop_setterinfo }
    },
    JSPropertySpec {
        name: b"ondurationchange\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &ondurationchange_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &ondurationchange_setterinfo }
    },
    JSPropertySpec {
        name: b"onemptied\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onemptied_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onemptied_setterinfo }
    },
    JSPropertySpec {
        name: b"onended\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onended_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onended_setterinfo }
    },
    JSPropertySpec {
        name: b"onerror\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onerror_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onerror_setterinfo }
    },
    JSPropertySpec {
        name: b"onfocus\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onfocus_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onfocus_setterinfo }
    },
    JSPropertySpec {
        name: b"oninput\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &oninput_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &oninput_setterinfo }
    },
    JSPropertySpec {
        name: b"oninvalid\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &oninvalid_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &oninvalid_setterinfo }
    },
    JSPropertySpec {
        name: b"onkeydown\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onkeydown_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onkeydown_setterinfo }
    },
    JSPropertySpec {
        name: b"onkeypress\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onkeypress_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onkeypress_setterinfo }
    },
    JSPropertySpec {
        name: b"onkeyup\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onkeyup_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onkeyup_setterinfo }
    },
    JSPropertySpec {
        name: b"onload\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onload_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onload_setterinfo }
    },
    JSPropertySpec {
        name: b"onloadeddata\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onloadeddata_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onloadeddata_setterinfo }
    },
    JSPropertySpec {
        name: b"onloadedmetadata\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onloadedmetadata_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onloadedmetadata_setterinfo }
    },
    JSPropertySpec {
        name: b"onloadstart\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onloadstart_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onloadstart_setterinfo }
    },
    JSPropertySpec {
        name: b"onmousedown\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onmousedown_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onmousedown_setterinfo }
    },
    JSPropertySpec {
        name: b"onmouseenter\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_lenient_getter), info: &onmouseenter_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_lenient_setter), info: &onmouseenter_setterinfo }
    },
    JSPropertySpec {
        name: b"onmouseleave\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_lenient_getter), info: &onmouseleave_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_lenient_setter), info: &onmouseleave_setterinfo }
    },
    JSPropertySpec {
        name: b"onmousemove\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onmousemove_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onmousemove_setterinfo }
    },
    JSPropertySpec {
        name: b"onmouseout\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onmouseout_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onmouseout_setterinfo }
    },
    JSPropertySpec {
        name: b"onmouseover\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onmouseover_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onmouseover_setterinfo }
    },
    JSPropertySpec {
        name: b"onmouseup\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onmouseup_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onmouseup_setterinfo }
    },
    JSPropertySpec {
        name: b"onwheel\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onwheel_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onwheel_setterinfo }
    },
    JSPropertySpec {
        name: b"onpause\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onpause_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onpause_setterinfo }
    },
    JSPropertySpec {
        name: b"onplay\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onplay_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onplay_setterinfo }
    },
    JSPropertySpec {
        name: b"onplaying\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onplaying_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onplaying_setterinfo }
    },
    JSPropertySpec {
        name: b"onprogress\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onprogress_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onprogress_setterinfo }
    },
    JSPropertySpec {
        name: b"onratechange\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onratechange_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onratechange_setterinfo }
    },
    JSPropertySpec {
        name: b"onreset\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onreset_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onreset_setterinfo }
    },
    JSPropertySpec {
        name: b"onresize\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onresize_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onresize_setterinfo }
    },
    JSPropertySpec {
        name: b"onscroll\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onscroll_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onscroll_setterinfo }
    },
    JSPropertySpec {
        name: b"onseeked\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onseeked_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onseeked_setterinfo }
    },
    JSPropertySpec {
        name: b"onseeking\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onseeking_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onseeking_setterinfo }
    },
    JSPropertySpec {
        name: b"onselect\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onselect_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onselect_setterinfo }
    },
    JSPropertySpec {
        name: b"onshow\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onshow_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onshow_setterinfo }
    },
    JSPropertySpec {
        name: b"onstalled\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onstalled_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onstalled_setterinfo }
    },
    JSPropertySpec {
        name: b"onsubmit\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onsubmit_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onsubmit_setterinfo }
    },
    JSPropertySpec {
        name: b"onsuspend\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onsuspend_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onsuspend_setterinfo }
    },
    JSPropertySpec {
        name: b"ontimeupdate\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &ontimeupdate_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &ontimeupdate_setterinfo }
    },
    JSPropertySpec {
        name: b"ontoggle\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &ontoggle_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &ontoggle_setterinfo }
    },
    JSPropertySpec {
        name: b"onvolumechange\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onvolumechange_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onvolumechange_setterinfo }
    },
    JSPropertySpec {
        name: b"onwaiting\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onwaiting_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onwaiting_setterinfo }
    },
    JSPropertySpec {
        name: b"ontransitionend\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &ontransitionend_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &ontransitionend_setterinfo }
    },
    JSPropertySpec {
        name: b"children\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &children_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"firstElementChild\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &firstElementChild_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"lastElementChild\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &lastElementChild_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"childElementCount\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &childElementCount_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]

];
const sAttributes: &'static [Guard<&'static [JSPropertySpec]>] = &[
    Guard::new(Condition::Satisfied, sAttributes_specs[0])
];
const sUnforgeableAttributes_specs: &'static [&'static[JSPropertySpec]] = &[
&[
    JSPropertySpec {
        name: b"location\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED | JSPROP_PERMANENT) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &location_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]

];
const sUnforgeableAttributes: &'static [Guard<&'static [JSPropertySpec]>] = &[
    Guard::new(Condition::Satisfied, sUnforgeableAttributes_specs[0])
];

pub unsafe fn GetProtoObject<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject, mut rval: MutableHandleObject) {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    assert!(((*get_object_class(global.get())).flags & JSCLASS_DOM_GLOBAL) != 0);

    /* Check to see whether the interface objects are already installed */
    let proto_or_iface_array = get_proto_or_iface_array(global.get());
    rval.set((*proto_or_iface_array)[PrototypeList::ID::Document as usize]);
    if !rval.get().is_null() {
        return;
    }

    CreateInterfaceObjects(cx, global, proto_or_iface_array);
    rval.set((*proto_or_iface_array)[PrototypeList::ID::Document as usize]);
    assert!(!rval.get().is_null());

}

static PrototypeClass: JSClass = JSClass {
    name: b"DocumentPrototype\0" as *const u8 as *const libc::c_char,
    flags:
        // JSCLASS_HAS_RESERVED_SLOTS(1)
        (1 & JSCLASS_RESERVED_SLOTS_MASK) << JSCLASS_RESERVED_SLOTS_SHIFT,
    cOps: 0 as *const _,
    reserved: [0 as *mut os::raw::c_void; 3]
};

unsafe extern fn _constructor<TH: TypeHolderTrait>
(cx: *mut JSContext, argc: u32, vp: *mut JSVal) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let global = GlobalScope::from_object(JS_CALLEE(cx, vp).to_object());
        let global = DomRoot::downcast::<dom::types::Window>(global).unwrap();
        let args = CallArgs::from_vp(vp, argc);
        let result: Result<DomRoot<Document<TH>>, Error> = Document::Constructor(&global);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, global.upcast::<GlobalScope<TH>>(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

static INTERFACE_OBJECT_CLASS: NonCallbackInterfaceObjectClass =
    NonCallbackInterfaceObjectClass::new(
        &InterfaceConstructorBehavior::call(_constructor),
        b"function Document() {\n    [native code]\n}",
        PrototypeList::ID::Document,
        2);

pub unsafe fn GetConstructorObject<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject, mut rval: MutableHandleObject) {
    /* Get the interface object for this class.  This will create the object as
       needed. */
    assert!(((*get_object_class(global.get())).flags & JSCLASS_DOM_GLOBAL) != 0);

    /* Check to see whether the interface objects are already installed */
    let proto_or_iface_array = get_proto_or_iface_array(global.get());
    rval.set((*proto_or_iface_array)[PrototypeList::Constructor::Document as usize]);
    if !rval.get().is_null() {
        return;
    }

    CreateInterfaceObjects(cx, global, proto_or_iface_array);
    rval.set((*proto_or_iface_array)[PrototypeList::Constructor::Document as usize]);
    assert!(!rval.get().is_null());

}

pub unsafe fn DefineDOMInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject) {
    assert!(!global.get().is_null());

    if !ConstructorEnabled(cx, global) {
        return;
    }

    rooted!(in(cx) let mut proto = ptr::null_mut::<JSObject>());
    GetProtoObject(cx, global, proto.handle_mut());
    assert!(!proto.is_null());
}

unsafe fn ConstructorEnabled<TH: TypeHolderTrait>
(aCx: *mut JSContext, aObj: HandleObject) -> bool {
    is_exposed_in(aObj, InterfaceObjectMap::Globals::WINDOW)
}

unsafe fn CreateInterfaceObjects<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject, cache: *mut ProtoOrIfaceArray) {
    rooted!(in(cx) let mut prototype_proto = ptr::null_mut::<JSObject>());
    NodeBinding::GetProtoObject(cx, global, prototype_proto.handle_mut());
    assert!(!prototype_proto.is_null());

    rooted!(in(cx) let mut prototype = ptr::null_mut::<JSObject>());
    create_interface_prototype_object(cx,
                                      prototype_proto.handle().into(),
                                      &PrototypeClass,
                                      sMethods,
                                      sAttributes,
                                      &[],
                                      unscopable_names,
                                      prototype.handle_mut().into());
    assert!(!prototype.is_null());
    assert!((*cache)[PrototypeList::ID::Document as usize].is_null());
    (*cache)[PrototypeList::ID::Document as usize] = prototype.get();
    <*mut JSObject>::post_barrier((*cache).as_mut_ptr().offset(PrototypeList::ID::Document as isize),
                                  ptr::null_mut(),
                                  prototype.get());


    rooted!(in(cx) let mut interface_proto = ptr::null_mut::<JSObject>());
    NodeBinding::GetConstructorObject(cx, global, interface_proto.handle_mut());
    assert!(!interface_proto.is_null());

    rooted!(in(cx) let mut interface = ptr::null_mut::<JSObject>());
    create_noncallback_interface_object(cx,
                                        global.into(),
                                        interface_proto.handle(),
                                        &INTERFACE_OBJECT_CLASS,
                                        &[],
                                        &[],
                                        &[],
                                        prototype.handle(),
                                        b"Document\0",
                                        0,
                                        interface.handle_mut());
    assert!(!interface.is_null());
    assert!((*cache)[PrototypeList::Constructor::Document as usize].is_null());
    (*cache)[PrototypeList::Constructor::Document as usize] = interface.get();
    <*mut JSObject>::post_barrier((*cache).as_mut_ptr().offset(PrototypeList::Constructor::Document as isize),
                                  ptr::null_mut(),
                                  interface.get());


    rooted!(in(cx) let mut unforgeable_holder = ptr::null_mut::<JSObject>());
    unforgeable_holder.handle_mut().set(
        JS_NewObjectWithoutMetadata(cx, ptr::null(), HandleObject::null()));
    assert!(!unforgeable_holder.is_null());

    define_guarded_properties(cx, unforgeable_holder.handle(), sUnforgeableAttributes);
    JS_SetReservedSlot(prototype.get(), DOM_PROTO_UNFORGEABLE_HOLDER_SLOT,
                       ObjectValue(unforgeable_holder.get()))
}
} // mod DocumentBinding


