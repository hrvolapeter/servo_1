/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */

#![allow(non_camel_case_types,non_upper_case_globals,unused_imports,unused_variables,unused_assignments,unused_mut)]
use dom;
use dom::bindings;
use dom::bindings::callback::CallSetup;
use dom::bindings::callback::CallbackContainer;
use dom::bindings::callback::CallbackFunction;
use dom::bindings::callback::CallbackInterface;
use dom::bindings::callback::CallbackObject;
use dom::bindings::callback::ExceptionHandling;
use dom::bindings::callback::wrap_call_this_object;
use dom::bindings::codegen::InterfaceObjectMap;
use dom::bindings::codegen::PrototypeList;
use dom::bindings::codegen::RegisterBindings;
use dom::bindings::codegen::UnionTypes;
use dom::bindings::constant::ConstantSpec;
use dom::bindings::constant::ConstantVal;
use dom::bindings::conversions::ConversionBehavior;
use dom::bindings::conversions::ConversionResult;
use dom::bindings::conversions::DOM_OBJECT_SLOT;
use dom::bindings::conversions::FromJSValConvertible;
use dom::bindings::conversions::IDLInterface;
use dom::bindings::conversions::StringificationBehavior;
use dom::bindings::conversions::ToJSValConvertible;
use dom::bindings::conversions::is_array_like;
use dom::bindings::conversions::jsid_to_string;
use dom::bindings::conversions::native_from_handlevalue;
use dom::bindings::conversions::native_from_object;
use dom::bindings::conversions::private_from_object;
use dom::bindings::conversions::root_from_handleobject;
use dom::bindings::conversions::root_from_handlevalue;
use dom::bindings::conversions::root_from_object;
use dom::bindings::error::Error;
use dom::bindings::error::Error::JSFailed;
use dom::bindings::error::ErrorResult;
use dom::bindings::error::Fallible;
use dom::bindings::error::throw_dom_exception;
use dom::bindings::guard::Condition;
use dom::bindings::guard::Guard;
use dom::bindings::htmlconstructor::html_constructor;
use dom::bindings::htmlconstructor::pop_current_element_queue;
use dom::bindings::htmlconstructor::push_new_element_queue;
use dom::bindings::inheritance::Castable;
use dom::bindings::interface::ConstructorClassHook;
use dom::bindings::interface::InterfaceConstructorBehavior;
use dom::bindings::interface::NonCallbackInterfaceObjectClass;
use dom::bindings::interface::create_callback_interface_object;
use dom::bindings::interface::create_global_object;
use dom::bindings::interface::create_interface_prototype_object;
use dom::bindings::interface::create_named_constructors;
use dom::bindings::interface::create_noncallback_interface_object;
use dom::bindings::interface::define_guarded_constants;
use dom::bindings::interface::define_guarded_methods;
use dom::bindings::interface::define_guarded_properties;
use dom::bindings::interface::is_exposed_in;
use dom::bindings::iterable::Iterable;
use dom::bindings::iterable::IteratorType;
use dom::bindings::mozmap::MozMap;
use dom::bindings::namespace::NamespaceObjectClass;
use dom::bindings::namespace::create_namespace_object;
use dom::bindings::num::Finite;
use dom::bindings::proxyhandler;
use dom::bindings::proxyhandler::ensure_expando_object;
use dom::bindings::proxyhandler::fill_property_descriptor;
use dom::bindings::proxyhandler::get_expando_object;
use dom::bindings::proxyhandler::get_property_descriptor;
use dom::bindings::reflector::DomObject;
use dom::bindings::reflector::MutDomObject;
use dom::bindings::root::Dom;
use dom::bindings::root::DomRoot;
use dom::bindings::root::OptionalHeapSetter;
use dom::bindings::root::RootedReference;
use dom::bindings::str::ByteString;
use dom::bindings::str::DOMString;
use dom::bindings::str::USVString;
use dom::bindings::trace::JSTraceable;
use dom::bindings::trace::RootedTraceable;
use dom::bindings::trace::RootedTraceableBox;
use dom::bindings::utils::AsVoidPtr;
use dom::bindings::utils::DOMClass;
use dom::bindings::utils::DOMJSClass;
use dom::bindings::utils::DOM_PROTO_UNFORGEABLE_HOLDER_SLOT;
use dom::bindings::utils::JSCLASS_DOM_GLOBAL;
use dom::bindings::utils::ProtoOrIfaceArray;
use dom::bindings::utils::enumerate_global;
use dom::bindings::utils::finalize_global;
use dom::bindings::utils::find_enum_value;
use dom::bindings::utils::generic_getter;
use dom::bindings::utils::generic_lenient_getter;
use dom::bindings::utils::generic_lenient_setter;
use dom::bindings::utils::generic_method;
use dom::bindings::utils::generic_setter;
use dom::bindings::utils::get_array_index_from_id;
use dom::bindings::utils::get_dictionary_property;
use dom::bindings::utils::get_property_on_prototype;
use dom::bindings::utils::get_proto_or_iface_array;
use dom::bindings::utils::has_property_on_prototype;
use dom::bindings::utils::is_platform_object;
use dom::bindings::utils::resolve_global;
use dom::bindings::utils::set_dictionary_property;
use dom::bindings::utils::trace_global;
use dom::bindings::weakref::DOM_WEAK_SLOT;
use dom::bindings::weakref::WeakBox;
use dom::bindings::weakref::WeakReferenceable;
use dom::globalscope::GlobalScope;
use dom::windowproxy::WindowProxy;
use js;
use js::JSCLASS_GLOBAL_SLOT_COUNT;
use js::JSCLASS_IS_DOMJSCLASS;
use js::JSCLASS_IS_GLOBAL;
use js::JSCLASS_RESERVED_SLOTS_MASK;
use js::JS_CALLEE;
use js::error::throw_internal_error;
use js::error::throw_type_error;
use js::glue::AppendToAutoIdVector;
use js::glue::CallJitGetterOp;
use js::glue::CallJitMethodOp;
use js::glue::CallJitSetterOp;
use js::glue::CreateProxyHandler;
use js::glue::GetProxyPrivate;
use js::glue::ProxyTraps;
use js::glue::RUST_JSID_IS_INT;
use js::glue::RUST_JSID_IS_STRING;
use js::glue::RUST_SYMBOL_TO_JSID;
use js::glue::UnwrapObject;
use js::glue::int_to_jsid;
use js::jsapi::AutoIdVector;
use js::jsapi::CallArgs;
use js::jsapi::CurrentGlobalOrNull;
use js::jsapi::FreeOp;
use js::jsapi::GetWellKnownSymbol;
use js::jsapi::Handle as RawHandle;
use js::jsapi::HandleId as RawHandleId;
use js::jsapi::HandleObject as RawHandleObject;
use js::jsapi::HandleValue as RawHandleValue;
use js::jsapi::HandleValueArray;
use js::jsapi::Heap;
use js::jsapi::INTERNED_STRING_TO_JSID;
use js::jsapi::IsCallable;
use js::jsapi::JSAutoCompartment;
use js::jsapi::JSCLASS_RESERVED_SLOTS_SHIFT;
use js::jsapi::JSClass;
use js::jsapi::JSContext;
use js::jsapi::JSFreeOp;
use js::jsapi::JSFunctionSpec;
use js::jsapi::JSITER_HIDDEN;
use js::jsapi::JSITER_OWNONLY;
use js::jsapi::JSITER_SYMBOLS;
use js::jsapi::JSJitGetterCallArgs;
use js::jsapi::JSJitInfo;
use js::jsapi::JSJitInfo_AliasSet;
use js::jsapi::JSJitInfo_ArgType;
use js::jsapi::JSJitInfo_OpType;
use js::jsapi::JSJitMethodCallArgs;
use js::jsapi::JSJitSetterCallArgs;
use js::jsapi::JSNative;
use js::jsapi::JSNativeWrapper;
use js::jsapi::JSObject;
use js::jsapi::JSPROP_ENUMERATE;
use js::jsapi::JSPROP_PERMANENT;
use js::jsapi::JSPROP_READONLY;
use js::jsapi::JSPROP_SHARED;
use js::jsapi::JSPropertySpec;
use js::jsapi::JSString;
use js::jsapi::JSTracer;
use js::jsapi::JSType;
use js::jsapi::JSTypedMethodJitInfo;
use js::jsapi::JSValueType;
use js::jsapi::JS_AtomizeAndPinString;
use js::jsapi::JS_ForwardGetPropertyTo;
use js::jsapi::JS_GetErrorPrototype;
use js::jsapi::JS_GetGlobalForObject;
use js::jsapi::JS_GetIteratorPrototype;
use js::jsapi::JS_GetPropertyById;
use js::jsapi::JS_GetPropertyDescriptorById;
use js::jsapi::JS_GetReservedSlot;
use js::jsapi::JS_HasProperty;
use js::jsapi::JS_HasPropertyById;
use js::jsapi::JS_NewObject;
use js::jsapi::JS_SetReservedSlot;
use js::jsapi::MutableHandle as RawMutableHandle;
use js::jsapi::MutableHandleObject as RawMutableHandleObject;
use js::jsapi::MutableHandleValue as RawMutableHandleValue;
use js::jsapi::ObjectOpResult;
use js::jsapi::PropertyDescriptor;
use js::jsapi::Rooted;
use js::jsapi::RootedId;
use js::jsapi::RootedObject;
use js::jsapi::RootedString;
use js::jsapi::SymbolCode;
use js::jsapi::jsid;
use js::jsval::JSVal;
use js::jsval::NullValue;
use js::jsval::ObjectOrNullValue;
use js::jsval::ObjectValue;
use js::jsval::PrivateValue;
use js::jsval::UndefinedValue;
use js::panic::maybe_resume_unwind;
use js::panic::wrap_panic;
use js::rust::CustomAutoRooterGuard;
use js::rust::GCMethods;
use js::rust::Handle;
use js::rust::HandleId;
use js::rust::HandleObject;
use js::rust::HandleValue;
use js::rust::MutableHandle;
use js::rust::MutableHandleObject;
use js::rust::MutableHandleValue;
use js::rust::define_methods;
use js::rust::define_properties;
use js::rust::get_object_class;
use js::rust::wrappers::Call;
use js::rust::wrappers::GetPropertyKeys;
use js::rust::wrappers::JS_CallFunctionValue;
use js::rust::wrappers::JS_CopyPropertiesFrom;
use js::rust::wrappers::JS_DefineProperty;
use js::rust::wrappers::JS_DefinePropertyById2;
use js::rust::wrappers::JS_GetFunctionPrototype;
use js::rust::wrappers::JS_GetObjectPrototype;
use js::rust::wrappers::JS_GetProperty;
use js::rust::wrappers::JS_InitializePropertiesFromCompatibleNativeObject;
use js::rust::wrappers::JS_NewObjectWithGivenProto;
use js::rust::wrappers::JS_NewObjectWithoutMetadata;
use js::rust::wrappers::JS_ObjectIsDate;
use js::rust::wrappers::JS_SetImmutablePrototype;
use js::rust::wrappers::JS_SetProperty;
use js::rust::wrappers::JS_SetPrototype;
use js::rust::wrappers::JS_SplicePrototype;
use js::rust::wrappers::JS_WrapObject;
use js::rust::wrappers::JS_WrapValue;
use js::rust::wrappers::NewProxyObject;
use js::typedarray;
use libc;
use malloc_size_of::MallocSizeOfOps;
use mem::malloc_size_of_including_raw_self;
use servo_config::prefs::PREFS;
use std::borrow::ToOwned;
use std::cmp;
use std::default::Default;
use std::ffi::CString;
use std::mem;
use std::num;
use std::os;
use std::os::raw::c_void;
use std::panic;
use std::ptr;
use std::ptr::NonNull;
use std::rc;
use std::rc::Rc;
use std::str;
use typeholder::TypeHolderTrait;

pub use self::ElementBinding::{Wrap, ElementMethods, GetProtoObject, GetConstructorObject, DefineDOMInterface};
pub mod ElementBinding {
#![allow(non_camel_case_types,non_upper_case_globals,unused_imports,unused_variables,unused_assignments,unused_mut)]
use dom;
use dom::bindings;
use dom::bindings::callback::CallSetup;
use dom::bindings::callback::CallbackContainer;
use dom::bindings::callback::CallbackFunction;
use dom::bindings::callback::CallbackInterface;
use dom::bindings::callback::CallbackObject;
use dom::bindings::callback::ExceptionHandling;
use dom::bindings::callback::wrap_call_this_object;
use dom::bindings::codegen::Bindings::DOMRectReadOnlyBinding::DOMRectReadOnlyBinding;
use dom::bindings::codegen::Bindings::EventTargetBinding::EventTargetBinding;
use dom::bindings::codegen::Bindings::NodeBinding::NodeBinding;
use dom::bindings::codegen::Bindings::WindowBinding::ScrollBehavior;
use dom::bindings::codegen::Bindings::WindowBinding::ScrollBehaviorValues;
use dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions;
use dom::bindings::codegen::InterfaceObjectMap;
use dom::bindings::codegen::PrototypeList;
use dom::bindings::codegen::RegisterBindings;
use dom::bindings::codegen::UnionTypes;
use dom::bindings::constant::ConstantSpec;
use dom::bindings::constant::ConstantVal;
use dom::bindings::conversions::ConversionBehavior;
use dom::bindings::conversions::ConversionResult;
use dom::bindings::conversions::DOM_OBJECT_SLOT;
use dom::bindings::conversions::FromJSValConvertible;
use dom::bindings::conversions::IDLInterface;
use dom::bindings::conversions::StringificationBehavior;
use dom::bindings::conversions::ToJSValConvertible;
use dom::bindings::conversions::is_array_like;
use dom::bindings::conversions::jsid_to_string;
use dom::bindings::conversions::native_from_handlevalue;
use dom::bindings::conversions::native_from_object;
use dom::bindings::conversions::private_from_object;
use dom::bindings::conversions::root_from_handleobject;
use dom::bindings::conversions::root_from_handlevalue;
use dom::bindings::conversions::root_from_object;
use dom::bindings::error::Error;
use dom::bindings::error::Error::JSFailed;
use dom::bindings::error::ErrorResult;
use dom::bindings::error::Fallible;
use dom::bindings::error::throw_dom_exception;
use dom::bindings::guard::Condition;
use dom::bindings::guard::Guard;
use dom::bindings::htmlconstructor::html_constructor;
use dom::bindings::htmlconstructor::pop_current_element_queue;
use dom::bindings::htmlconstructor::push_new_element_queue;
use dom::bindings::inheritance::Castable;
use dom::bindings::interface::ConstructorClassHook;
use dom::bindings::interface::InterfaceConstructorBehavior;
use dom::bindings::interface::NonCallbackInterfaceObjectClass;
use dom::bindings::interface::create_callback_interface_object;
use dom::bindings::interface::create_global_object;
use dom::bindings::interface::create_interface_prototype_object;
use dom::bindings::interface::create_named_constructors;
use dom::bindings::interface::create_noncallback_interface_object;
use dom::bindings::interface::define_guarded_constants;
use dom::bindings::interface::define_guarded_methods;
use dom::bindings::interface::define_guarded_properties;
use dom::bindings::interface::is_exposed_in;
use dom::bindings::iterable::Iterable;
use dom::bindings::iterable::IteratorType;
use dom::bindings::mozmap::MozMap;
use dom::bindings::namespace::NamespaceObjectClass;
use dom::bindings::namespace::create_namespace_object;
use dom::bindings::num::Finite;
use dom::bindings::proxyhandler;
use dom::bindings::proxyhandler::ensure_expando_object;
use dom::bindings::proxyhandler::fill_property_descriptor;
use dom::bindings::proxyhandler::get_expando_object;
use dom::bindings::proxyhandler::get_property_descriptor;
use dom::bindings::reflector::DomObject;
use dom::bindings::reflector::MutDomObject;
use dom::bindings::root::Dom;
use dom::bindings::root::DomRoot;
use dom::bindings::root::OptionalHeapSetter;
use dom::bindings::root::RootedReference;
use dom::bindings::str::ByteString;
use dom::bindings::str::DOMString;
use dom::bindings::str::USVString;
use dom::bindings::trace::JSTraceable;
use dom::bindings::trace::RootedTraceable;
use dom::bindings::trace::RootedTraceableBox;
use dom::bindings::utils::AsVoidPtr;
use dom::bindings::utils::DOMClass;
use dom::bindings::utils::DOMJSClass;
use dom::bindings::utils::DOM_PROTO_UNFORGEABLE_HOLDER_SLOT;
use dom::bindings::utils::JSCLASS_DOM_GLOBAL;
use dom::bindings::utils::ProtoOrIfaceArray;
use dom::bindings::utils::enumerate_global;
use dom::bindings::utils::finalize_global;
use dom::bindings::utils::find_enum_value;
use dom::bindings::utils::generic_getter;
use dom::bindings::utils::generic_lenient_getter;
use dom::bindings::utils::generic_lenient_setter;
use dom::bindings::utils::generic_method;
use dom::bindings::utils::generic_setter;
use dom::bindings::utils::get_array_index_from_id;
use dom::bindings::utils::get_dictionary_property;
use dom::bindings::utils::get_property_on_prototype;
use dom::bindings::utils::get_proto_or_iface_array;
use dom::bindings::utils::has_property_on_prototype;
use dom::bindings::utils::is_platform_object;
use dom::bindings::utils::resolve_global;
use dom::bindings::utils::set_dictionary_property;
use dom::bindings::utils::trace_global;
use dom::bindings::weakref::DOM_WEAK_SLOT;
use dom::bindings::weakref::WeakBox;
use dom::bindings::weakref::WeakReferenceable;
use dom::globalscope::GlobalScope;
use dom::promise::Promise;
use dom::types::Attr;
use dom::types::DOMRect;
use dom::types::DOMRectReadOnly;
use dom::types::DOMTokenList;
use dom::types::Element;
use dom::types::EventTarget;
use dom::types::HTMLCollection;
use dom::types::NamedNodeMap;
use dom::types::Node;
use dom::types::NodeList;
use dom::windowproxy::WindowProxy;
use js;
use js::JSCLASS_GLOBAL_SLOT_COUNT;
use js::JSCLASS_IS_DOMJSCLASS;
use js::JSCLASS_IS_GLOBAL;
use js::JSCLASS_RESERVED_SLOTS_MASK;
use js::JS_CALLEE;
use js::error::throw_internal_error;
use js::error::throw_type_error;
use js::glue::AppendToAutoIdVector;
use js::glue::CallJitGetterOp;
use js::glue::CallJitMethodOp;
use js::glue::CallJitSetterOp;
use js::glue::CreateProxyHandler;
use js::glue::GetProxyPrivate;
use js::glue::ProxyTraps;
use js::glue::RUST_JSID_IS_INT;
use js::glue::RUST_JSID_IS_STRING;
use js::glue::RUST_SYMBOL_TO_JSID;
use js::glue::UnwrapObject;
use js::glue::int_to_jsid;
use js::jsapi::AutoIdVector;
use js::jsapi::CallArgs;
use js::jsapi::CurrentGlobalOrNull;
use js::jsapi::FreeOp;
use js::jsapi::GetWellKnownSymbol;
use js::jsapi::Handle as RawHandle;
use js::jsapi::HandleId as RawHandleId;
use js::jsapi::HandleObject as RawHandleObject;
use js::jsapi::HandleValue as RawHandleValue;
use js::jsapi::HandleValueArray;
use js::jsapi::Heap;
use js::jsapi::INTERNED_STRING_TO_JSID;
use js::jsapi::IsCallable;
use js::jsapi::JSAutoCompartment;
use js::jsapi::JSCLASS_RESERVED_SLOTS_SHIFT;
use js::jsapi::JSClass;
use js::jsapi::JSContext;
use js::jsapi::JSFreeOp;
use js::jsapi::JSFunctionSpec;
use js::jsapi::JSITER_HIDDEN;
use js::jsapi::JSITER_OWNONLY;
use js::jsapi::JSITER_SYMBOLS;
use js::jsapi::JSJitGetterCallArgs;
use js::jsapi::JSJitInfo;
use js::jsapi::JSJitInfo_AliasSet;
use js::jsapi::JSJitInfo_ArgType;
use js::jsapi::JSJitInfo_OpType;
use js::jsapi::JSJitMethodCallArgs;
use js::jsapi::JSJitSetterCallArgs;
use js::jsapi::JSNative;
use js::jsapi::JSNativeWrapper;
use js::jsapi::JSObject;
use js::jsapi::JSPROP_ENUMERATE;
use js::jsapi::JSPROP_PERMANENT;
use js::jsapi::JSPROP_READONLY;
use js::jsapi::JSPROP_SHARED;
use js::jsapi::JSPropertySpec;
use js::jsapi::JSString;
use js::jsapi::JSTracer;
use js::jsapi::JSType;
use js::jsapi::JSTypedMethodJitInfo;
use js::jsapi::JSValueType;
use js::jsapi::JS_AtomizeAndPinString;
use js::jsapi::JS_ForwardGetPropertyTo;
use js::jsapi::JS_GetErrorPrototype;
use js::jsapi::JS_GetGlobalForObject;
use js::jsapi::JS_GetIteratorPrototype;
use js::jsapi::JS_GetPropertyById;
use js::jsapi::JS_GetPropertyDescriptorById;
use js::jsapi::JS_GetReservedSlot;
use js::jsapi::JS_HasProperty;
use js::jsapi::JS_HasPropertyById;
use js::jsapi::JS_NewObject;
use js::jsapi::JS_SetReservedSlot;
use js::jsapi::MutableHandle as RawMutableHandle;
use js::jsapi::MutableHandleObject as RawMutableHandleObject;
use js::jsapi::MutableHandleValue as RawMutableHandleValue;
use js::jsapi::ObjectOpResult;
use js::jsapi::PropertyDescriptor;
use js::jsapi::Rooted;
use js::jsapi::RootedId;
use js::jsapi::RootedObject;
use js::jsapi::RootedString;
use js::jsapi::SymbolCode;
use js::jsapi::jsid;
use js::jsval::JSVal;
use js::jsval::NullValue;
use js::jsval::ObjectOrNullValue;
use js::jsval::ObjectValue;
use js::jsval::PrivateValue;
use js::jsval::UndefinedValue;
use js::panic::maybe_resume_unwind;
use js::panic::wrap_panic;
use js::rust::CustomAutoRooterGuard;
use js::rust::GCMethods;
use js::rust::Handle;
use js::rust::HandleId;
use js::rust::HandleObject;
use js::rust::HandleValue;
use js::rust::MutableHandle;
use js::rust::MutableHandleObject;
use js::rust::MutableHandleValue;
use js::rust::define_methods;
use js::rust::define_properties;
use js::rust::get_object_class;
use js::rust::wrappers::Call;
use js::rust::wrappers::GetPropertyKeys;
use js::rust::wrappers::JS_CallFunctionValue;
use js::rust::wrappers::JS_CopyPropertiesFrom;
use js::rust::wrappers::JS_DefineProperty;
use js::rust::wrappers::JS_DefinePropertyById2;
use js::rust::wrappers::JS_GetFunctionPrototype;
use js::rust::wrappers::JS_GetObjectPrototype;
use js::rust::wrappers::JS_GetProperty;
use js::rust::wrappers::JS_InitializePropertiesFromCompatibleNativeObject;
use js::rust::wrappers::JS_NewObjectWithGivenProto;
use js::rust::wrappers::JS_NewObjectWithoutMetadata;
use js::rust::wrappers::JS_ObjectIsDate;
use js::rust::wrappers::JS_SetImmutablePrototype;
use js::rust::wrappers::JS_SetProperty;
use js::rust::wrappers::JS_SetPrototype;
use js::rust::wrappers::JS_SplicePrototype;
use js::rust::wrappers::JS_WrapObject;
use js::rust::wrappers::JS_WrapValue;
use js::rust::wrappers::NewProxyObject;
use js::typedarray;
use libc;
use malloc_size_of::MallocSizeOfOps;
use mem::malloc_size_of_including_raw_self;
use servo_config::prefs::PREFS;
use std::borrow::ToOwned;
use std::cmp;
use std::default::Default;
use std::ffi::CString;
use std::mem;
use std::num;
use std::os;
use std::os::raw::c_void;
use std::panic;
use std::ptr;
use std::ptr::NonNull;
use std::rc;
use std::rc::Rc;
use std::str;
use typeholder::TypeHolderTrait;

unsafe extern fn get_namespaceURI<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DOMString> = this.GetNamespaceURI();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn namespaceURI_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_namespaceURI::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasNone as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_prefix<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DOMString> = this.GetPrefix();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn prefix_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_prefix::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasNone as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_localName<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DOMString = this.LocalName();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn localName_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_localName::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasNone as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_tagName<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DOMString = this.TagName();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn tagName_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_tagName::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasDOMSets as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_id<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.Id();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_id<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Element<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: () = this.SetId(arg0);
        pop_current_element_queue();


        return true;
    }), false);
}


fn id_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_id::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasDOMSets as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn id_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_id::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_className<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: DOMString = this.ClassName();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_className<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Element<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: () = this.SetClassName(arg0);
        pop_current_element_queue();


        return true;
    }), false);
}


fn className_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_className::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasDOMSets as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn className_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_className::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_classList<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<DOMTokenList<TH>> = this.ClassList();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_classList<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Element<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        rooted!(in(cx) let mut v = UndefinedValue());
        if !JS_GetProperty(cx, obj, b"classList\0" as *const u8 as *const libc::c_char, v.handle_mut()) {
            return false;
        }
        if !v.is_object() {
            throw_type_error(cx, "Value.classList is not an object.");
            return false;
        }
        rooted!(in(cx) let target_obj = v.to_object());
        JS_SetProperty(cx, target_obj.handle(), b"value\0" as *const u8 as *const libc::c_char, args.get(0))

    }), false);
}


fn classList_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_classList::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasNone as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn classList_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_classList::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn hasAttributes<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: bool = this.HasAttributes();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

const hasAttributes_methodinfo_argTypes: [i32; 1] = [ JSJitInfo_ArgType::ArgTypeListEnd as i32 ];
fn hasAttributes_methodinfo<TH: TypeHolderTrait>() -> JSTypedMethodJitInfo { JSTypedMethodJitInfo {
    base:   JSJitInfo {
      call: hasAttributes::<TH> as *const os::raw::c_void,
      protoID: PrototypeList::ID::Element as u16,
      depth: 2,
      _bitfield_1: new_jsjitinfo_bitfield_1!(
          JSJitInfo_OpType::Method as u8,
          JSJitInfo_AliasSet::AliasDOMSets as u8,
          JSValueType::JSVAL_TYPE_BOOLEAN as u8,
          true,
          true,
          false,
          false,
          false,
          true,
          0,
      ),
  },
    argTypes: &hasAttributes_methodinfo_argTypes as *const _ as *const JSJitInfo_ArgType,
}}

unsafe extern fn get_attributes<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<NamedNodeMap<TH>> = this.Attributes();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn attributes_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_attributes::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasNone as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getAttributeNames<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Vec<DOMString> = this.GetAttributeNames();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

const getAttributeNames_methodinfo_argTypes: [i32; 1] = [ JSJitInfo_ArgType::ArgTypeListEnd as i32 ];
fn getAttributeNames_methodinfo<TH: TypeHolderTrait>() -> JSTypedMethodJitInfo { JSTypedMethodJitInfo {
    base:   JSJitInfo {
      call: getAttributeNames::<TH> as *const os::raw::c_void,
      protoID: PrototypeList::ID::Element as u16,
      depth: 2,
      _bitfield_1: new_jsjitinfo_bitfield_1!(
          JSJitInfo_OpType::Method as u8,
          JSJitInfo_AliasSet::AliasDOMSets as u8,
          JSValueType::JSVAL_TYPE_OBJECT as u8,
          true,
          true,
          false,
          false,
          false,
          true,
          0,
      ),
  },
    argTypes: &getAttributeNames_methodinfo_argTypes as *const _ as *const JSJitInfo_ArgType,
}}

unsafe extern fn getAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Element.getAttribute\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: Option<DOMString> = this.GetAttribute(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

const getAttribute_methodinfo_argTypes: [i32; 2] = [ JSJitInfo_ArgType::String as i32, JSJitInfo_ArgType::ArgTypeListEnd as i32 ];
fn getAttribute_methodinfo<TH: TypeHolderTrait>() -> JSTypedMethodJitInfo { JSTypedMethodJitInfo {
    base:   JSJitInfo {
      call: getAttribute::<TH> as *const os::raw::c_void,
      protoID: PrototypeList::ID::Element as u16,
      depth: 2,
      _bitfield_1: new_jsjitinfo_bitfield_1!(
          JSJitInfo_OpType::Method as u8,
          JSJitInfo_AliasSet::AliasDOMSets as u8,
          JSValueType::JSVAL_TYPE_UNKNOWN as u8,
          false,
          true,
          false,
          false,
          false,
          true,
          0,
      ),
  },
    argTypes: &getAttribute_methodinfo_argTypes as *const _ as *const JSJitInfo_ArgType,
}}

unsafe extern fn getAttributeNS<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"Element.getAttributeNS\".");
            return false;
        }
        let arg0: Option<DOMString> = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let arg1: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(1), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: Option<DOMString> = this.GetAttributeNS(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

const getAttributeNS_methodinfo_argTypes: [i32; 3] = [ JSJitInfo_ArgType::Null as i32 | JSJitInfo_ArgType::String as i32, JSJitInfo_ArgType::String as i32, JSJitInfo_ArgType::ArgTypeListEnd as i32 ];
fn getAttributeNS_methodinfo<TH: TypeHolderTrait>() -> JSTypedMethodJitInfo { JSTypedMethodJitInfo {
    base:   JSJitInfo {
      call: getAttributeNS::<TH> as *const os::raw::c_void,
      protoID: PrototypeList::ID::Element as u16,
      depth: 2,
      _bitfield_1: new_jsjitinfo_bitfield_1!(
          JSJitInfo_OpType::Method as u8,
          JSJitInfo_AliasSet::AliasDOMSets as u8,
          JSValueType::JSVAL_TYPE_UNKNOWN as u8,
          false,
          true,
          false,
          false,
          false,
          true,
          0,
      ),
  },
    argTypes: &getAttributeNS_methodinfo_argTypes as *const _ as *const JSJitInfo_ArgType,
}}

unsafe extern fn setAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"Element.setAttribute\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let arg1: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(1), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetAttribute(arg0, arg1);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn setAttribute_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: setAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn setAttributeNS<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 3 {
            throw_type_error(cx, "Not enough arguments to \"Element.setAttributeNS\".");
            return false;
        }
        let arg0: Option<DOMString> = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let arg1: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(1), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let arg2: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(2), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetAttributeNS(arg0, arg1, arg2);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn setAttributeNS_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: setAttributeNS::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn removeAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Element.removeAttribute\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: () = this.RemoveAttribute(arg0);
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn removeAttribute_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: removeAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn removeAttributeNS<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"Element.removeAttributeNS\".");
            return false;
        }
        let arg0: Option<DOMString> = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let arg1: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(1), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: () = this.RemoveAttributeNS(arg0, arg1);
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn removeAttributeNS_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: removeAttributeNS::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn hasAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Element.hasAttribute\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: bool = this.HasAttribute(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn hasAttribute_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: hasAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_BOOLEAN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn hasAttributeNS<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"Element.hasAttributeNS\".");
            return false;
        }
        let arg0: Option<DOMString> = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let arg1: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(1), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: bool = this.HasAttributeNS(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn hasAttributeNS_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: hasAttributeNS::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_BOOLEAN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getAttributeNode<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Element.getAttributeNode\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: Option<DomRoot<Attr<TH>>> = this.GetAttributeNode(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

const getAttributeNode_methodinfo_argTypes: [i32; 2] = [ JSJitInfo_ArgType::String as i32, JSJitInfo_ArgType::ArgTypeListEnd as i32 ];
fn getAttributeNode_methodinfo<TH: TypeHolderTrait>() -> JSTypedMethodJitInfo { JSTypedMethodJitInfo {
    base:   JSJitInfo {
      call: getAttributeNode::<TH> as *const os::raw::c_void,
      protoID: PrototypeList::ID::Element as u16,
      depth: 2,
      _bitfield_1: new_jsjitinfo_bitfield_1!(
          JSJitInfo_OpType::Method as u8,
          JSJitInfo_AliasSet::AliasDOMSets as u8,
          JSValueType::JSVAL_TYPE_UNKNOWN as u8,
          false,
          true,
          false,
          false,
          false,
          true,
          0,
      ),
  },
    argTypes: &getAttributeNode_methodinfo_argTypes as *const _ as *const JSJitInfo_ArgType,
}}

unsafe extern fn getAttributeNodeNS<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"Element.getAttributeNodeNS\".");
            return false;
        }
        let arg0: Option<DOMString> = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let arg1: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(1), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: Option<DomRoot<Attr<TH>>> = this.GetAttributeNodeNS(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

const getAttributeNodeNS_methodinfo_argTypes: [i32; 3] = [ JSJitInfo_ArgType::Null as i32 | JSJitInfo_ArgType::String as i32, JSJitInfo_ArgType::String as i32, JSJitInfo_ArgType::ArgTypeListEnd as i32 ];
fn getAttributeNodeNS_methodinfo<TH: TypeHolderTrait>() -> JSTypedMethodJitInfo { JSTypedMethodJitInfo {
    base:   JSJitInfo {
      call: getAttributeNodeNS::<TH> as *const os::raw::c_void,
      protoID: PrototypeList::ID::Element as u16,
      depth: 2,
      _bitfield_1: new_jsjitinfo_bitfield_1!(
          JSJitInfo_OpType::Method as u8,
          JSJitInfo_AliasSet::AliasDOMSets as u8,
          JSValueType::JSVAL_TYPE_UNKNOWN as u8,
          false,
          true,
          false,
          false,
          false,
          true,
          0,
      ),
  },
    argTypes: &getAttributeNodeNS_methodinfo_argTypes as *const _ as *const JSJitInfo_ArgType,
}}

unsafe extern fn setAttributeNode<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Element.setAttributeNode\".");
            return false;
        }
        let arg0: DomRoot<Attr<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface Attr.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        push_new_element_queue();

        let result: Result<Option<DomRoot<Attr<TH>>>, Error<TH>> = this.SetAttributeNode(&arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn setAttributeNode_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: setAttributeNode::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn setAttributeNodeNS<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Element.setAttributeNodeNS\".");
            return false;
        }
        let arg0: DomRoot<Attr<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface Attr.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        push_new_element_queue();

        let result: Result<Option<DomRoot<Attr<TH>>>, Error<TH>> = this.SetAttributeNodeNS(&arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn setAttributeNodeNS_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: setAttributeNodeNS::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn removeAttributeNode<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Element.removeAttributeNode\".");
            return false;
        }
        let arg0: DomRoot<Attr<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface Attr.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        push_new_element_queue();

        let result: Result<DomRoot<Attr<TH>>, Error<TH>> = this.RemoveAttributeNode(&arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn removeAttributeNode_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: removeAttributeNode::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn closest<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Element.closest\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: Result<Option<DomRoot<Element<TH>>>, Error<TH>> = this.Closest(arg0);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

const closest_methodinfo_argTypes: [i32; 2] = [ JSJitInfo_ArgType::String as i32, JSJitInfo_ArgType::ArgTypeListEnd as i32 ];
fn closest_methodinfo<TH: TypeHolderTrait>() -> JSTypedMethodJitInfo { JSTypedMethodJitInfo {
    base:   JSJitInfo {
      call: closest::<TH> as *const os::raw::c_void,
      protoID: PrototypeList::ID::Element as u16,
      depth: 2,
      _bitfield_1: new_jsjitinfo_bitfield_1!(
          JSJitInfo_OpType::Method as u8,
          JSJitInfo_AliasSet::AliasDOMSets as u8,
          JSValueType::JSVAL_TYPE_UNKNOWN as u8,
          false,
          false,
          false,
          false,
          false,
          true,
          0,
      ),
  },
    argTypes: &closest_methodinfo_argTypes as *const _ as *const JSJitInfo_ArgType,
}}

unsafe extern fn matches<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Element.matches\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: Result<bool, Error<TH>> = this.Matches(arg0);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

const matches_methodinfo_argTypes: [i32; 2] = [ JSJitInfo_ArgType::String as i32, JSJitInfo_ArgType::ArgTypeListEnd as i32 ];
fn matches_methodinfo<TH: TypeHolderTrait>() -> JSTypedMethodJitInfo { JSTypedMethodJitInfo {
    base:   JSJitInfo {
      call: matches::<TH> as *const os::raw::c_void,
      protoID: PrototypeList::ID::Element as u16,
      depth: 2,
      _bitfield_1: new_jsjitinfo_bitfield_1!(
          JSJitInfo_OpType::Method as u8,
          JSJitInfo_AliasSet::AliasDOMSets as u8,
          JSValueType::JSVAL_TYPE_BOOLEAN as u8,
          false,
          false,
          false,
          false,
          false,
          true,
          0,
      ),
  },
    argTypes: &matches_methodinfo_argTypes as *const _ as *const JSJitInfo_ArgType,
}}

unsafe extern fn webkitMatchesSelector<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Element.webkitMatchesSelector\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: Result<bool, Error<TH>> = this.WebkitMatchesSelector(arg0);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

const webkitMatchesSelector_methodinfo_argTypes: [i32; 2] = [ JSJitInfo_ArgType::String as i32, JSJitInfo_ArgType::ArgTypeListEnd as i32 ];
fn webkitMatchesSelector_methodinfo<TH: TypeHolderTrait>() -> JSTypedMethodJitInfo { JSTypedMethodJitInfo {
    base:   JSJitInfo {
      call: webkitMatchesSelector::<TH> as *const os::raw::c_void,
      protoID: PrototypeList::ID::Element as u16,
      depth: 2,
      _bitfield_1: new_jsjitinfo_bitfield_1!(
          JSJitInfo_OpType::Method as u8,
          JSJitInfo_AliasSet::AliasDOMSets as u8,
          JSValueType::JSVAL_TYPE_BOOLEAN as u8,
          false,
          false,
          false,
          false,
          false,
          true,
          0,
      ),
  },
    argTypes: &webkitMatchesSelector_methodinfo_argTypes as *const _ as *const JSJitInfo_ArgType,
}}

unsafe extern fn getElementsByTagName<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Element.getElementsByTagName\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: DomRoot<HTMLCollection<TH>> = this.GetElementsByTagName(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn getElementsByTagName_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: getElementsByTagName::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getElementsByTagNameNS<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"Element.getElementsByTagNameNS\".");
            return false;
        }
        let arg0: Option<DOMString> = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let arg1: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(1), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: DomRoot<HTMLCollection<TH>> = this.GetElementsByTagNameNS(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn getElementsByTagNameNS_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: getElementsByTagNameNS::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getElementsByClassName<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Element.getElementsByClassName\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: DomRoot<HTMLCollection<TH>> = this.GetElementsByClassName(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn getElementsByClassName_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: getElementsByClassName::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn insertAdjacentElement<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"Element.insertAdjacentElement\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let arg1: DomRoot<Element<TH>> = if args.get(1).get().is_object() {
            match root_from_handlevalue(args.get(1)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface Element.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        push_new_element_queue();

        let result: Result<Option<DomRoot<Element<TH>>>, Error<TH>> = this.InsertAdjacentElement(arg0, &arg1);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn insertAdjacentElement_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: insertAdjacentElement::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn insertAdjacentText<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"Element.insertAdjacentText\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let arg1: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(1), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: Result<(), Error<TH>> = this.InsertAdjacentText(arg0, arg1);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn insertAdjacentText_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: insertAdjacentText::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn insertAdjacentHTML<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"Element.insertAdjacentHTML\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let arg1: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(1), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.InsertAdjacentHTML(arg0, arg1);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn insertAdjacentHTML_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: insertAdjacentHTML::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getClientRects<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Vec<DomRoot<DOMRect<TH>>> = this.GetClientRects();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn getClientRects_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: getClientRects::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getBoundingClientRect<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: DomRoot<DOMRect<TH>> = this.GetBoundingClientRect();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn getBoundingClientRect_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: getBoundingClientRect::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn scroll<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        let argcount = cmp::min(argc, 2);
        match argcount {
            0 => {
                let arg0: dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions = if args.get(0).is_undefined() {
                    dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions::empty(cx)
                } else {
                    match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                        Ok(ConversionResult::Success(dictionary)) => dictionary,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     },
                    }
                };
                let result: () = this.Scroll(&arg0);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            1 => {
                let arg0: dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions = if args.get(0).is_undefined() {
                    dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions::empty(cx)
                } else {
                    match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                        Ok(ConversionResult::Success(dictionary)) => dictionary,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     },
                    }
                };
                let result: () = this.Scroll(&arg0);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            2 => {
                let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg1: f64 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let result: () = this.Scroll_(arg0, arg1);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            _ => {
                throw_type_error(cx, "Not enough arguments to \"Element.scroll\".");
                return false;
            }
        }
    }), false);
}


fn scroll_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: scroll::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn scrollTo<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        let argcount = cmp::min(argc, 2);
        match argcount {
            0 => {
                let arg0: dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions = if args.get(0).is_undefined() {
                    dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions::empty(cx)
                } else {
                    match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                        Ok(ConversionResult::Success(dictionary)) => dictionary,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     },
                    }
                };
                let result: () = this.ScrollTo(&arg0);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            1 => {
                let arg0: dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions = if args.get(0).is_undefined() {
                    dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions::empty(cx)
                } else {
                    match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                        Ok(ConversionResult::Success(dictionary)) => dictionary,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     },
                    }
                };
                let result: () = this.ScrollTo(&arg0);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            2 => {
                let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg1: f64 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let result: () = this.ScrollTo_(arg0, arg1);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            _ => {
                throw_type_error(cx, "Not enough arguments to \"Element.scrollTo\".");
                return false;
            }
        }
    }), false);
}


fn scrollTo_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: scrollTo::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn scrollBy<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        let argcount = cmp::min(argc, 2);
        match argcount {
            0 => {
                let arg0: dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions = if args.get(0).is_undefined() {
                    dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions::empty(cx)
                } else {
                    match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                        Ok(ConversionResult::Success(dictionary)) => dictionary,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     },
                    }
                };
                let result: () = this.ScrollBy(&arg0);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            1 => {
                let arg0: dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions = if args.get(0).is_undefined() {
                    dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions::empty(cx)
                } else {
                    match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                        Ok(ConversionResult::Success(dictionary)) => dictionary,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     },
                    }
                };
                let result: () = this.ScrollBy(&arg0);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            2 => {
                let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg1: f64 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let result: () = this.ScrollBy_(arg0, arg1);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            _ => {
                throw_type_error(cx, "Not enough arguments to \"Element.scrollBy\".");
                return false;
            }
        }
    }), false);
}


fn scrollBy_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: scrollBy::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_scrollTop<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.ScrollTop();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_scrollTop<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Element<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetScrollTop(arg0);

        return true;
    }), false);
}


fn scrollTop_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_scrollTop::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn scrollTop_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_scrollTop::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_scrollLeft<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.ScrollLeft();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_scrollLeft<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Element<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetScrollLeft(arg0);

        return true;
    }), false);
}


fn scrollLeft_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_scrollLeft::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn scrollLeft_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_scrollLeft::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_scrollWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: i32 = this.ScrollWidth();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn scrollWidth_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_scrollWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_scrollHeight<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: i32 = this.ScrollHeight();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn scrollHeight_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_scrollHeight::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_clientTop<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: i32 = this.ClientTop();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn clientTop_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_clientTop::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_clientLeft<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: i32 = this.ClientLeft();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn clientLeft_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_clientLeft::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_clientWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: i32 = this.ClientWidth();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn clientWidth_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_clientWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_clientHeight<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: i32 = this.ClientHeight();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn clientHeight_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_clientHeight::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_innerHTML<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: Result<DOMString, Error<TH>> = this.GetInnerHTML();
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_innerHTML<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Element<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetInnerHTML(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn innerHTML_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_innerHTML::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn innerHTML_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_innerHTML::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_outerHTML<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: Result<DOMString, Error<TH>> = this.GetOuterHTML();
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_outerHTML<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Element<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.SetOuterHTML(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        return true;
    }), false);
}


fn outerHTML_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_outerHTML::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn outerHTML_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_outerHTML::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn requestFullscreen<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Rc<Promise<TH>> = this.RequestFullscreen();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn requestFullscreen_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: requestFullscreen::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn enterFormalActivationState<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Result<(), Error<TH>> = this.EnterFormalActivationState();
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn enterFormalActivationState_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: enterFormalActivationState::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn exitFormalActivationState<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Result<(), Error<TH>> = this.ExitFormalActivationState();
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn exitFormalActivationState_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: exitFormalActivationState::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn before<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: UnionTypes::NodeOrString<TH> = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(value)) => value,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                arg0.push(slot);
            }
        }
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.Before(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn before_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: before::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn after<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: UnionTypes::NodeOrString<TH> = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(value)) => value,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                arg0.push(slot);
            }
        }
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.After(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn after_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: after::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn replaceWith<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: UnionTypes::NodeOrString<TH> = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(value)) => value,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                arg0.push(slot);
            }
        }
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.ReplaceWith(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn replaceWith_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: replaceWith::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn remove<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        push_new_element_queue();

        let result: () = this.Remove();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn remove_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: remove::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_previousElementSibling<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DomRoot<Element<TH>>> = this.GetPreviousElementSibling();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn previousElementSibling_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_previousElementSibling::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasDOMSets as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_nextElementSibling<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DomRoot<Element<TH>>> = this.GetNextElementSibling();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn nextElementSibling_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_nextElementSibling::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasDOMSets as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_children<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<HTMLCollection<TH>> = this.Children();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn children_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_children::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasNone as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_firstElementChild<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DomRoot<Element<TH>>> = this.GetFirstElementChild();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn firstElementChild_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_firstElementChild::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasDOMSets as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_lastElementChild<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DomRoot<Element<TH>>> = this.GetLastElementChild();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn lastElementChild_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_lastElementChild::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasDOMSets as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_childElementCount<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: u32 = this.ChildElementCount();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn childElementCount_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_childElementCount::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasDOMSets as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn prepend<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: UnionTypes::NodeOrString<TH> = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(value)) => value,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                arg0.push(slot);
            }
        }
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.Prepend(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn prepend_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: prepend::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn append<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: UnionTypes::NodeOrString<TH> = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(value)) => value,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                arg0.push(slot);
            }
        }
        push_new_element_queue();

        let result: Result<(), Error<TH>> = this.Append(arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn append_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: append::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn querySelector<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Element.querySelector\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: Result<Option<DomRoot<Element<TH>>>, Error<TH>> = this.QuerySelector(arg0);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

const querySelector_methodinfo_argTypes: [i32; 2] = [ JSJitInfo_ArgType::String as i32, JSJitInfo_ArgType::ArgTypeListEnd as i32 ];
fn querySelector_methodinfo<TH: TypeHolderTrait>() -> JSTypedMethodJitInfo { JSTypedMethodJitInfo {
    base:   JSJitInfo {
      call: querySelector::<TH> as *const os::raw::c_void,
      protoID: PrototypeList::ID::Element as u16,
      depth: 2,
      _bitfield_1: new_jsjitinfo_bitfield_1!(
          JSJitInfo_OpType::Method as u8,
          JSJitInfo_AliasSet::AliasDOMSets as u8,
          JSValueType::JSVAL_TYPE_UNKNOWN as u8,
          false,
          false,
          false,
          false,
          false,
          true,
          0,
      ),
  },
    argTypes: &querySelector_methodinfo_argTypes as *const _ as *const JSJitInfo_ArgType,
}}

unsafe extern fn querySelectorAll<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Element<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Element.querySelectorAll\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: Result<DomRoot<NodeList<TH>>, Error<TH>> = this.QuerySelectorAll(arg0);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn querySelectorAll_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: querySelectorAll::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Element as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn _finalize<TH: TypeHolderTrait>
(_fop: *mut JSFreeOp, obj: *mut JSObject) {
    return wrap_panic(panic::AssertUnwindSafe(|| {

        let this = native_from_object::<Element<TH>, TH>(obj).unwrap();
            if !this.is_null() {
                // The pointer can be null if the object is the unforgeable holder of that interface.
                let _ = Box::from_raw(this as *mut Element<TH>);
            }
            debug!("Element<TH> finalize: {:p}", this);
    }), ());
}

unsafe extern fn _trace<TH: TypeHolderTrait>
(trc: *mut JSTracer, obj: *mut JSObject) {
    return wrap_panic(panic::AssertUnwindSafe(|| {

        let this = native_from_object::<Element<TH>, TH>(obj).unwrap();
        if this.is_null() { return; } // GC during obj creation
        (*this).trace(trc);
    }), ());
}

fn CLASS_OPS<TH: TypeHolderTrait>() -> js::jsapi::JSClassOps { js::jsapi::JSClassOps {
    addProperty: None,
    delProperty: None,
    getProperty: None,
    setProperty: None,
    enumerate: None,
    resolve: None,
    mayResolve: None,
    finalize: Some(_finalize::<TH>),
    call: None,
    hasInstance: None,
    construct: None,
    trace: Some(_trace::<TH>),
}}

fn Class<TH: TypeHolderTrait>() -> DOMJSClass { DOMJSClass {
    base: js::jsapi::JSClass {
        name: b"Element\0" as *const u8 as *const libc::c_char,
        flags: JSCLASS_IS_DOMJSCLASS | 0 |
               (((1) & JSCLASS_RESERVED_SLOTS_MASK) << JSCLASS_RESERVED_SLOTS_SHIFT)
               /* JSCLASS_HAS_RESERVED_SLOTS(1) */,
        cOps: &CLASS_OPS::<TH>(),
        reserved: [0 as *mut _; 3],
    },
    dom_class: DOMClass {
    interface_chain: [ PrototypeList::ID::EventTarget, PrototypeList::ID::Node, PrototypeList::ID::Element, PrototypeList::ID::Last, PrototypeList::ID::Last, PrototypeList::ID::Last ],
    type_id: ::dom::bindings::codegen::InheritTypes::TopTypeId { eventtarget: (::dom::bindings::codegen::InheritTypes::EventTargetTypeId::Node(::dom::bindings::codegen::InheritTypes::NodeTypeId::Element(::dom::bindings::codegen::InheritTypes::ElementTypeId::Element))) },
    global: InterfaceObjectMap::Globals::EMPTY,
   	malloc_size_of: malloc_size_of_including_raw_self::<Element<TH>> as unsafe fn(&mut _, _) -> _,
}
}}

#[inline]
fn malloc_size<TH: TypeHolderTrait>(ops: &mut MallocSizeOfOps, obj: *const c_void) -> usize {
    malloc_size_of_including_raw_self::<Element<TH>>(ops, obj)
}

pub unsafe fn Wrap<TH: TypeHolderTrait>
(cx: *mut JSContext, scope: &GlobalScope<TH>, object: Box<Element<TH>>) -> DomRoot<Element<TH>> {
    let scope = scope.reflector().get_jsobject();
    assert!(!scope.get().is_null());
    assert!(((*get_object_class(scope.get())).flags & JSCLASS_IS_GLOBAL) != 0);

    rooted!(in(cx) let mut proto = ptr::null_mut::<JSObject>());
    let _ac = JSAutoCompartment::new(cx, scope.get());
    GetProtoObject(cx, scope, proto.handle_mut());
    assert!(!proto.is_null());

    let raw = Box::into_raw(object);
    let _rt = RootedTraceable::new(&*raw);
    rooted!(in(cx) let obj = JS_NewObjectWithGivenProto(
        cx, &Class::<TH>().base as *const JSClass, proto.handle()));
    assert!(!obj.is_null());

    JS_SetReservedSlot(obj.get(), DOM_OBJECT_SLOT,
                       PrivateValue(raw as *const libc::c_void));


    (*raw).init_reflector(obj.get());

    DomRoot::from_ref(&*raw)
}

const unscopable_names: &'static [&'static [u8]] = &[
    b"before\0",
    b"after\0",
    b"replaceWith\0",
    b"remove\0",
    b"prepend\0",
    b"append\0"
];

impl<TH: TypeHolderTrait> IDLInterface for Element<TH> {
    #[inline]
    fn derives(class: &'static DOMClass) -> bool {
        class.interface_chain[2] == PrototypeList::ID::Element
    }
}

impl<TH: TypeHolderTrait> PartialEq for Element<TH> {
    fn eq(&self, other: &Element<TH>) -> bool {
        self as *const Element<TH> == &*other
    }
}

pub trait ElementMethods<TH: TypeHolderTrait> {
    fn GetNamespaceURI(&self) -> Option<DOMString>;
    fn GetPrefix(&self) -> Option<DOMString>;
    fn LocalName(&self) -> DOMString;
    fn TagName(&self) -> DOMString;
    fn Id(&self) -> DOMString;
    fn SetId(&self, value: DOMString) -> ();
    fn ClassName(&self) -> DOMString;
    fn SetClassName(&self, value: DOMString) -> ();
    fn ClassList(&self) -> DomRoot<DOMTokenList<TH>>;
    fn HasAttributes(&self) -> bool;
    fn Attributes(&self) -> DomRoot<NamedNodeMap<TH>>;
    fn GetAttributeNames(&self) -> Vec<DOMString>;
    fn GetAttribute(&self, name: DOMString) -> Option<DOMString>;
    fn GetAttributeNS(&self, namespace: Option<DOMString>, localName: DOMString) -> Option<DOMString>;
    fn SetAttribute(&self, name: DOMString, value: DOMString) -> Fallible<(), TH>;
    fn SetAttributeNS(&self, namespace: Option<DOMString>, name: DOMString, value: DOMString) -> Fallible<(), TH>;
    fn RemoveAttribute(&self, name: DOMString) -> ();
    fn RemoveAttributeNS(&self, namespace: Option<DOMString>, localName: DOMString) -> ();
    fn HasAttribute(&self, name: DOMString) -> bool;
    fn HasAttributeNS(&self, namespace: Option<DOMString>, localName: DOMString) -> bool;
    fn GetAttributeNode(&self, name: DOMString) -> Option<DomRoot<Attr<TH>>>;
    fn GetAttributeNodeNS(&self, namespace: Option<DOMString>, localName: DOMString) -> Option<DomRoot<Attr<TH>>>;
    fn SetAttributeNode(&self, attr: &Attr<TH>) -> Fallible<Option<DomRoot<Attr<TH>>>, TH>;
    fn SetAttributeNodeNS(&self, attr: &Attr<TH>) -> Fallible<Option<DomRoot<Attr<TH>>>, TH>;
    fn RemoveAttributeNode(&self, oldAttr: &Attr<TH>) -> Fallible<DomRoot<Attr<TH>>, TH>;
    fn Closest(&self, selectors: DOMString) -> Fallible<Option<DomRoot<Element<TH>>>, TH>;
    fn Matches(&self, selectors: DOMString) -> Fallible<bool, TH>;
    fn WebkitMatchesSelector(&self, selectors: DOMString) -> Fallible<bool, TH>;
    fn GetElementsByTagName(&self, localName: DOMString) -> DomRoot<HTMLCollection<TH>>;
    fn GetElementsByTagNameNS(&self, namespace: Option<DOMString>, localName: DOMString) -> DomRoot<HTMLCollection<TH>>;
    fn GetElementsByClassName(&self, classNames: DOMString) -> DomRoot<HTMLCollection<TH>>;
    fn InsertAdjacentElement(&self, where_: DOMString, element: &Element<TH>) -> Fallible<Option<DomRoot<Element<TH>>>, TH>;
    fn InsertAdjacentText(&self, where_: DOMString, data: DOMString) -> Fallible<(), TH>;
    fn InsertAdjacentHTML(&self, position: DOMString, html: DOMString) -> Fallible<(), TH>;
    fn GetClientRects(&self) -> Vec<DomRoot<DOMRect<TH>>>;
    fn GetBoundingClientRect(&self) -> DomRoot<DOMRect<TH>>;
    fn Scroll(&self, options: &dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions) -> ();
    fn Scroll_(&self, x: f64, y: f64) -> ();
    fn ScrollTo(&self, options: &dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions) -> ();
    fn ScrollTo_(&self, x: f64, y: f64) -> ();
    fn ScrollBy(&self, options: &dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions) -> ();
    fn ScrollBy_(&self, x: f64, y: f64) -> ();
    fn ScrollTop(&self) -> f64;
    fn SetScrollTop(&self, value: f64) -> ();
    fn ScrollLeft(&self) -> f64;
    fn SetScrollLeft(&self, value: f64) -> ();
    fn ScrollWidth(&self) -> i32;
    fn ScrollHeight(&self) -> i32;
    fn ClientTop(&self) -> i32;
    fn ClientLeft(&self) -> i32;
    fn ClientWidth(&self) -> i32;
    fn ClientHeight(&self) -> i32;
    fn GetInnerHTML(&self) -> Fallible<DOMString, TH>;
    fn SetInnerHTML(&self, value: DOMString) -> ErrorResult<TH>;
    fn GetOuterHTML(&self) -> Fallible<DOMString, TH>;
    fn SetOuterHTML(&self, value: DOMString) -> ErrorResult<TH>;
    fn RequestFullscreen(&self) -> Rc<Promise<TH>>;
    fn EnterFormalActivationState(&self) -> Fallible<(), TH>;
    fn ExitFormalActivationState(&self) -> Fallible<(), TH>;
    fn Before(&self, nodes: Vec<UnionTypes::NodeOrString<TH>>) -> Fallible<(), TH>;
    fn After(&self, nodes: Vec<UnionTypes::NodeOrString<TH>>) -> Fallible<(), TH>;
    fn ReplaceWith(&self, nodes: Vec<UnionTypes::NodeOrString<TH>>) -> Fallible<(), TH>;
    fn Remove(&self) -> ();
    fn GetPreviousElementSibling(&self) -> Option<DomRoot<Element<TH>>>;
    fn GetNextElementSibling(&self) -> Option<DomRoot<Element<TH>>>;
    fn Children(&self) -> DomRoot<HTMLCollection<TH>>;
    fn GetFirstElementChild(&self) -> Option<DomRoot<Element<TH>>>;
    fn GetLastElementChild(&self) -> Option<DomRoot<Element<TH>>>;
    fn ChildElementCount(&self) -> u32;
    fn Prepend(&self, nodes: Vec<UnionTypes::NodeOrString<TH>>) -> Fallible<(), TH>;
    fn Append(&self, nodes: Vec<UnionTypes::NodeOrString<TH>>) -> Fallible<(), TH>;
    fn QuerySelector(&self, selectors: DOMString) -> Fallible<Option<DomRoot<Element<TH>>>, TH>;
    fn QuerySelectorAll(&self, selectors: DOMString) -> Fallible<DomRoot<NodeList<TH>>, TH>;
}
fn sMethods_specs<TH: TypeHolderTrait>() -> &'static [&'static[JSFunctionSpec]] { &[
&[
    JSFunctionSpec {
        name: b"hasAttributes\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &hasAttributes_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getAttributeNames\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getAttributeNames_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getAttribute\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getAttribute_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getAttributeNS\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getAttributeNS_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"setAttribute\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &setAttribute_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"setAttributeNS\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &setAttributeNS_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 3,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"removeAttribute\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &removeAttribute_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"removeAttributeNS\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &removeAttributeNS_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"hasAttribute\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &hasAttribute_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"hasAttributeNS\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &hasAttributeNS_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getAttributeNode\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getAttributeNode_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getAttributeNodeNS\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getAttributeNodeNS_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"setAttributeNode\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &setAttributeNode_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"setAttributeNodeNS\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &setAttributeNodeNS_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"removeAttributeNode\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &removeAttributeNode_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"closest\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &closest_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"matches\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &matches_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"webkitMatchesSelector\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &webkitMatchesSelector_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getElementsByTagName\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getElementsByTagName_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getElementsByTagNameNS\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getElementsByTagNameNS_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getElementsByClassName\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getElementsByClassName_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"insertAdjacentElement\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &insertAdjacentElement_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"insertAdjacentText\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &insertAdjacentText_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"insertAdjacentHTML\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &insertAdjacentHTML_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getClientRects\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getClientRects_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getBoundingClientRect\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getBoundingClientRect_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"scroll\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &scroll_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"scrollTo\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &scrollTo_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"scrollBy\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &scrollBy_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"requestFullscreen\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &requestFullscreen_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]
,
&[
    JSFunctionSpec {
        name: b"enterFormalActivationState\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &enterFormalActivationState_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"exitFormalActivationState\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &exitFormalActivationState_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]
,
&[
    JSFunctionSpec {
        name: b"before\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &before_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"after\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &after_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"replaceWith\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &replaceWith_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"remove\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &remove_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"prepend\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &prepend_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"append\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &append_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"querySelector\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &querySelector_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"querySelectorAll\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &querySelectorAll_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]

]}
fn sMethods<TH: TypeHolderTrait>() -> &'static [Guard<&'static [JSFunctionSpec]>] { &[
    Guard::new(Condition::Satisfied, sMethods_specs::<TH>()[0]),
    Guard::new(Condition::Pref("dom.testing.element.activation.enabled"), sMethods_specs::<TH>()[1]),
    Guard::new(Condition::Satisfied, sMethods_specs::<TH>()[2])
]}
fn sAttributes_specs<TH: TypeHolderTrait>() -> &'static [&'static[JSPropertySpec]] { &[
&[
    JSPropertySpec {
        name: b"namespaceURI\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &namespaceURI_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"prefix\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &prefix_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"localName\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &localName_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"tagName\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &tagName_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"id\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &id_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &id_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"className\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &className_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &className_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"classList\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &classList_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &classList_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"attributes\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &attributes_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"scrollTop\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &scrollTop_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &scrollTop_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"scrollLeft\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &scrollLeft_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &scrollLeft_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"scrollWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &scrollWidth_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"scrollHeight\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &scrollHeight_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"clientTop\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &clientTop_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"clientLeft\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &clientLeft_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"clientWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &clientWidth_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"clientHeight\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &clientHeight_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"innerHTML\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &innerHTML_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &innerHTML_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"outerHTML\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &outerHTML_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &outerHTML_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"previousElementSibling\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &previousElementSibling_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"nextElementSibling\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &nextElementSibling_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"children\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &children_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"firstElementChild\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &firstElementChild_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"lastElementChild\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &lastElementChild_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"childElementCount\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &childElementCount_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]

]}
fn sAttributes<TH: TypeHolderTrait>() -> &'static [Guard<&'static [JSPropertySpec]>] { &[
    Guard::new(Condition::Satisfied, sAttributes_specs::<TH>()[0])
]}

pub unsafe fn GetProtoObject<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject, mut rval: MutableHandleObject) {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    assert!(((*get_object_class(global.get())).flags & JSCLASS_DOM_GLOBAL) != 0);

    /* Check to see whether the interface objects are already installed */
    let proto_or_iface_array = get_proto_or_iface_array(global.get());
    rval.set((*proto_or_iface_array)[PrototypeList::ID::Element as usize]);
    if !rval.get().is_null() {
        return;
    }

    CreateInterfaceObjects(cx, global, proto_or_iface_array);
    rval.set((*proto_or_iface_array)[PrototypeList::ID::Element as usize]);
    assert!(!rval.get().is_null());

}

static PrototypeClass: JSClass = JSClass {
    name: b"ElementPrototype\0" as *const u8 as *const libc::c_char,
    flags:
        // JSCLASS_HAS_RESERVED_SLOTS(0)
        (0 & JSCLASS_RESERVED_SLOTS_MASK) << JSCLASS_RESERVED_SLOTS_SHIFT,
    cOps: 0 as *const _,
    reserved: [0 as *mut os::raw::c_void; 3]
};

static INTERFACE_OBJECT_CLASS: NonCallbackInterfaceObjectClass =
    NonCallbackInterfaceObjectClass::new(
        &InterfaceConstructorBehavior::throw(),
        b"function Element() {\n    [native code]\n}",
        PrototypeList::ID::Element,
        2);

pub unsafe fn GetConstructorObject<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject, mut rval: MutableHandleObject) {
    /* Get the interface object for this class.  This will create the object as
       needed. */
    assert!(((*get_object_class(global.get())).flags & JSCLASS_DOM_GLOBAL) != 0);

    /* Check to see whether the interface objects are already installed */
    let proto_or_iface_array = get_proto_or_iface_array(global.get());
    rval.set((*proto_or_iface_array)[PrototypeList::Constructor::Element as usize]);
    if !rval.get().is_null() {
        return;
    }

    CreateInterfaceObjects(cx, global, proto_or_iface_array);
    rval.set((*proto_or_iface_array)[PrototypeList::Constructor::Element as usize]);
    assert!(!rval.get().is_null());

}

pub unsafe fn DefineDOMInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject) {
    assert!(!global.get().is_null());

    if !ConstructorEnabled(cx, global) {
        return;
    }

    rooted!(in(cx) let mut proto = ptr::null_mut::<JSObject>());
    GetProtoObject(cx, global, proto.handle_mut());
    assert!(!proto.is_null());
}

unsafe fn ConstructorEnabled<TH: TypeHolderTrait>
(aCx: *mut JSContext, aObj: HandleObject) -> bool {
    is_exposed_in(aObj, InterfaceObjectMap::Globals::WINDOW)
}

unsafe fn CreateInterfaceObjects<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject, cache: *mut ProtoOrIfaceArray) {
    rooted!(in(cx) let mut prototype_proto = ptr::null_mut::<JSObject>());
    NodeBinding::GetProtoObject(cx, global, prototype_proto.handle_mut());
    assert!(!prototype_proto.is_null());

    rooted!(in(cx) let mut prototype = ptr::null_mut::<JSObject>());
    create_interface_prototype_object(cx,
                                      prototype_proto.handle().into(),
                                      &PrototypeClass,
                                      sMethods::<TH>(),
                                      sAttributes::<TH>(),
                                      &[],
                                      unscopable_names,
                                      prototype.handle_mut().into());
    assert!(!prototype.is_null());
    assert!((*cache)[PrototypeList::ID::Element as usize].is_null());
    (*cache)[PrototypeList::ID::Element as usize] = prototype.get();
    <*mut JSObject>::post_barrier((*cache).as_mut_ptr().offset(PrototypeList::ID::Element as isize),
                                  ptr::null_mut(),
                                  prototype.get());


    rooted!(in(cx) let mut interface_proto = ptr::null_mut::<JSObject>());
    NodeBinding::GetConstructorObject(cx, global, interface_proto.handle_mut());
    assert!(!interface_proto.is_null());

    rooted!(in(cx) let mut interface = ptr::null_mut::<JSObject>());
    create_noncallback_interface_object(cx,
                                        global.into(),
                                        interface_proto.handle(),
                                        &INTERFACE_OBJECT_CLASS,
                                        &[],
                                        &[],
                                        &[],
                                        prototype.handle(),
                                        b"Element\0",
                                        0,
                                        interface.handle_mut());
    assert!(!interface.is_null());
    assert!((*cache)[PrototypeList::Constructor::Element as usize].is_null());
    (*cache)[PrototypeList::Constructor::Element as usize] = interface.get();
    <*mut JSObject>::post_barrier((*cache).as_mut_ptr().offset(PrototypeList::Constructor::Element as isize),
                                  ptr::null_mut(),
                                  interface.get());

}
} // mod ElementBinding


