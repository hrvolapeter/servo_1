/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */

#![allow(non_camel_case_types,non_upper_case_globals,unused_imports,unused_variables,unused_assignments,unused_mut)]
use dom;
use dom::bindings;
use dom::bindings::callback::CallSetup;
use dom::bindings::callback::CallbackContainer;
use dom::bindings::callback::CallbackFunction;
use dom::bindings::callback::CallbackInterface;
use dom::bindings::callback::CallbackObject;
use dom::bindings::callback::ExceptionHandling;
use dom::bindings::callback::wrap_call_this_object;
use dom::bindings::codegen::InterfaceObjectMap;
use dom::bindings::codegen::PrototypeList;
use dom::bindings::codegen::RegisterBindings;
use dom::bindings::codegen::UnionTypes;
use dom::bindings::constant::ConstantSpec;
use dom::bindings::constant::ConstantVal;
use dom::bindings::conversions::ConversionBehavior;
use dom::bindings::conversions::ConversionResult;
use dom::bindings::conversions::DOM_OBJECT_SLOT;
use dom::bindings::conversions::FromJSValConvertible;
use dom::bindings::conversions::IDLInterface;
use dom::bindings::conversions::StringificationBehavior;
use dom::bindings::conversions::ToJSValConvertible;
use dom::bindings::conversions::is_array_like;
use dom::bindings::conversions::jsid_to_string;
use dom::bindings::conversions::native_from_handlevalue;
use dom::bindings::conversions::native_from_object;
use dom::bindings::conversions::private_from_object;
use dom::bindings::conversions::root_from_handleobject;
use dom::bindings::conversions::root_from_handlevalue;
use dom::bindings::conversions::root_from_object;
use dom::bindings::error::Error;
use dom::bindings::error::Error::JSFailed;
use dom::bindings::error::ErrorResult;
use dom::bindings::error::Fallible;
use dom::bindings::error::throw_dom_exception;
use dom::bindings::guard::Condition;
use dom::bindings::guard::Guard;
use dom::bindings::htmlconstructor::html_constructor;
use dom::bindings::htmlconstructor::pop_current_element_queue;
use dom::bindings::htmlconstructor::push_new_element_queue;
use dom::bindings::inheritance::Castable;
use dom::bindings::interface::ConstructorClassHook;
use dom::bindings::interface::InterfaceConstructorBehavior;
use dom::bindings::interface::NonCallbackInterfaceObjectClass;
use dom::bindings::interface::create_callback_interface_object;
use dom::bindings::interface::create_global_object;
use dom::bindings::interface::create_interface_prototype_object;
use dom::bindings::interface::create_named_constructors;
use dom::bindings::interface::create_noncallback_interface_object;
use dom::bindings::interface::define_guarded_constants;
use dom::bindings::interface::define_guarded_methods;
use dom::bindings::interface::define_guarded_properties;
use dom::bindings::interface::is_exposed_in;
use dom::bindings::iterable::Iterable;
use dom::bindings::iterable::IteratorType;
use dom::bindings::mozmap::MozMap;
use dom::bindings::namespace::NamespaceObjectClass;
use dom::bindings::namespace::create_namespace_object;
use dom::bindings::num::Finite;
use dom::bindings::proxyhandler;
use dom::bindings::proxyhandler::ensure_expando_object;
use dom::bindings::proxyhandler::fill_property_descriptor;
use dom::bindings::proxyhandler::get_expando_object;
use dom::bindings::proxyhandler::get_property_descriptor;
use dom::bindings::reflector::DomObject;
use dom::bindings::reflector::MutDomObject;
use dom::bindings::root::Dom;
use dom::bindings::root::DomRoot;
use dom::bindings::root::OptionalHeapSetter;
use dom::bindings::root::RootedReference;
use dom::bindings::str::ByteString;
use dom::bindings::str::DOMString;
use dom::bindings::str::USVString;
use dom::bindings::trace::JSTraceable;
use dom::bindings::trace::RootedTraceable;
use dom::bindings::trace::RootedTraceableBox;
use dom::bindings::utils::AsVoidPtr;
use dom::bindings::utils::DOMClass;
use dom::bindings::utils::DOMJSClass;
use dom::bindings::utils::DOM_PROTO_UNFORGEABLE_HOLDER_SLOT;
use dom::bindings::utils::JSCLASS_DOM_GLOBAL;
use dom::bindings::utils::ProtoOrIfaceArray;
use dom::bindings::utils::enumerate_global;
use dom::bindings::utils::finalize_global;
use dom::bindings::utils::find_enum_value;
use dom::bindings::utils::generic_getter;
use dom::bindings::utils::generic_lenient_getter;
use dom::bindings::utils::generic_lenient_setter;
use dom::bindings::utils::generic_method;
use dom::bindings::utils::generic_setter;
use dom::bindings::utils::get_array_index_from_id;
use dom::bindings::utils::get_dictionary_property;
use dom::bindings::utils::get_property_on_prototype;
use dom::bindings::utils::get_proto_or_iface_array;
use dom::bindings::utils::has_property_on_prototype;
use dom::bindings::utils::is_platform_object;
use dom::bindings::utils::resolve_global;
use dom::bindings::utils::set_dictionary_property;
use dom::bindings::utils::trace_global;
use dom::bindings::weakref::DOM_WEAK_SLOT;
use dom::bindings::weakref::WeakBox;
use dom::bindings::weakref::WeakReferenceable;
use dom::globalscope::GlobalScope;
use dom::windowproxy::WindowProxy;
use js;
use js::JSCLASS_GLOBAL_SLOT_COUNT;
use js::JSCLASS_IS_DOMJSCLASS;
use js::JSCLASS_IS_GLOBAL;
use js::JSCLASS_RESERVED_SLOTS_MASK;
use js::JS_CALLEE;
use js::error::throw_internal_error;
use js::error::throw_type_error;
use js::glue::AppendToAutoIdVector;
use js::glue::CallJitGetterOp;
use js::glue::CallJitMethodOp;
use js::glue::CallJitSetterOp;
use js::glue::CreateProxyHandler;
use js::glue::GetProxyPrivate;
use js::glue::ProxyTraps;
use js::glue::RUST_JSID_IS_INT;
use js::glue::RUST_JSID_IS_STRING;
use js::glue::RUST_SYMBOL_TO_JSID;
use js::glue::UnwrapObject;
use js::glue::int_to_jsid;
use js::jsapi::AutoIdVector;
use js::jsapi::CallArgs;
use js::jsapi::CurrentGlobalOrNull;
use js::jsapi::FreeOp;
use js::jsapi::GetWellKnownSymbol;
use js::jsapi::Handle as RawHandle;
use js::jsapi::HandleId as RawHandleId;
use js::jsapi::HandleObject as RawHandleObject;
use js::jsapi::HandleValue as RawHandleValue;
use js::jsapi::HandleValueArray;
use js::jsapi::Heap;
use js::jsapi::INTERNED_STRING_TO_JSID;
use js::jsapi::IsCallable;
use js::jsapi::JSAutoCompartment;
use js::jsapi::JSCLASS_RESERVED_SLOTS_SHIFT;
use js::jsapi::JSClass;
use js::jsapi::JSContext;
use js::jsapi::JSFreeOp;
use js::jsapi::JSFunctionSpec;
use js::jsapi::JSITER_HIDDEN;
use js::jsapi::JSITER_OWNONLY;
use js::jsapi::JSITER_SYMBOLS;
use js::jsapi::JSJitGetterCallArgs;
use js::jsapi::JSJitInfo;
use js::jsapi::JSJitInfo_AliasSet;
use js::jsapi::JSJitInfo_ArgType;
use js::jsapi::JSJitInfo_OpType;
use js::jsapi::JSJitMethodCallArgs;
use js::jsapi::JSJitSetterCallArgs;
use js::jsapi::JSNative;
use js::jsapi::JSNativeWrapper;
use js::jsapi::JSObject;
use js::jsapi::JSPROP_ENUMERATE;
use js::jsapi::JSPROP_PERMANENT;
use js::jsapi::JSPROP_READONLY;
use js::jsapi::JSPROP_SHARED;
use js::jsapi::JSPropertySpec;
use js::jsapi::JSString;
use js::jsapi::JSTracer;
use js::jsapi::JSType;
use js::jsapi::JSTypedMethodJitInfo;
use js::jsapi::JSValueType;
use js::jsapi::JS_AtomizeAndPinString;
use js::jsapi::JS_ForwardGetPropertyTo;
use js::jsapi::JS_GetErrorPrototype;
use js::jsapi::JS_GetGlobalForObject;
use js::jsapi::JS_GetIteratorPrototype;
use js::jsapi::JS_GetPropertyById;
use js::jsapi::JS_GetPropertyDescriptorById;
use js::jsapi::JS_GetReservedSlot;
use js::jsapi::JS_HasProperty;
use js::jsapi::JS_HasPropertyById;
use js::jsapi::JS_NewObject;
use js::jsapi::JS_SetReservedSlot;
use js::jsapi::MutableHandle as RawMutableHandle;
use js::jsapi::MutableHandleObject as RawMutableHandleObject;
use js::jsapi::MutableHandleValue as RawMutableHandleValue;
use js::jsapi::ObjectOpResult;
use js::jsapi::PropertyDescriptor;
use js::jsapi::Rooted;
use js::jsapi::RootedId;
use js::jsapi::RootedObject;
use js::jsapi::RootedString;
use js::jsapi::SymbolCode;
use js::jsapi::jsid;
use js::jsval::JSVal;
use js::jsval::NullValue;
use js::jsval::ObjectOrNullValue;
use js::jsval::ObjectValue;
use js::jsval::PrivateValue;
use js::jsval::UndefinedValue;
use js::panic::maybe_resume_unwind;
use js::panic::wrap_panic;
use js::rust::CustomAutoRooterGuard;
use js::rust::GCMethods;
use js::rust::Handle;
use js::rust::HandleId;
use js::rust::HandleObject;
use js::rust::HandleValue;
use js::rust::MutableHandle;
use js::rust::MutableHandleObject;
use js::rust::MutableHandleValue;
use js::rust::define_methods;
use js::rust::define_properties;
use js::rust::get_object_class;
use js::rust::wrappers::Call;
use js::rust::wrappers::GetPropertyKeys;
use js::rust::wrappers::JS_CallFunctionValue;
use js::rust::wrappers::JS_CopyPropertiesFrom;
use js::rust::wrappers::JS_DefineProperty;
use js::rust::wrappers::JS_DefinePropertyById2;
use js::rust::wrappers::JS_GetFunctionPrototype;
use js::rust::wrappers::JS_GetObjectPrototype;
use js::rust::wrappers::JS_GetProperty;
use js::rust::wrappers::JS_InitializePropertiesFromCompatibleNativeObject;
use js::rust::wrappers::JS_NewObjectWithGivenProto;
use js::rust::wrappers::JS_NewObjectWithoutMetadata;
use js::rust::wrappers::JS_ObjectIsDate;
use js::rust::wrappers::JS_SetImmutablePrototype;
use js::rust::wrappers::JS_SetProperty;
use js::rust::wrappers::JS_SetPrototype;
use js::rust::wrappers::JS_SplicePrototype;
use js::rust::wrappers::JS_WrapObject;
use js::rust::wrappers::JS_WrapValue;
use js::rust::wrappers::NewProxyObject;
use js::typedarray;
use libc;
use malloc_size_of::MallocSizeOfOps;
use mem::malloc_size_of_including_raw_self;
use servo_config::prefs::PREFS;
use std::borrow::ToOwned;
use std::cmp;
use std::default::Default;
use std::ffi::CString;
use std::mem;
use std::num;
use std::os;
use std::os::raw::c_void;
use std::panic;
use std::ptr;
use std::ptr::NonNull;
use std::rc;
use std::rc::Rc;
use std::str;
use typeholder::TypeHolderTrait;

pub use self::HTMLFrameSetElementBinding::{Wrap, HTMLFrameSetElementMethods, GetProtoObject, GetConstructorObject, DefineDOMInterface};
pub mod HTMLFrameSetElementBinding {
#![allow(non_camel_case_types,non_upper_case_globals,unused_imports,unused_variables,unused_assignments,unused_mut)]
use dom;
use dom::bindings;
use dom::bindings::callback::CallSetup;
use dom::bindings::callback::CallbackContainer;
use dom::bindings::callback::CallbackFunction;
use dom::bindings::callback::CallbackInterface;
use dom::bindings::callback::CallbackObject;
use dom::bindings::callback::ExceptionHandling;
use dom::bindings::callback::wrap_call_this_object;
use dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull;
use dom::bindings::codegen::Bindings::EventHandlerBinding::OnBeforeUnloadEventHandlerNonNull;
use dom::bindings::codegen::Bindings::HTMLElementBinding::HTMLElementBinding;
use dom::bindings::codegen::InterfaceObjectMap;
use dom::bindings::codegen::PrototypeList;
use dom::bindings::codegen::RegisterBindings;
use dom::bindings::codegen::UnionTypes;
use dom::bindings::constant::ConstantSpec;
use dom::bindings::constant::ConstantVal;
use dom::bindings::conversions::ConversionBehavior;
use dom::bindings::conversions::ConversionResult;
use dom::bindings::conversions::DOM_OBJECT_SLOT;
use dom::bindings::conversions::FromJSValConvertible;
use dom::bindings::conversions::IDLInterface;
use dom::bindings::conversions::StringificationBehavior;
use dom::bindings::conversions::ToJSValConvertible;
use dom::bindings::conversions::is_array_like;
use dom::bindings::conversions::jsid_to_string;
use dom::bindings::conversions::native_from_handlevalue;
use dom::bindings::conversions::native_from_object;
use dom::bindings::conversions::private_from_object;
use dom::bindings::conversions::root_from_handleobject;
use dom::bindings::conversions::root_from_handlevalue;
use dom::bindings::conversions::root_from_object;
use dom::bindings::error::Error;
use dom::bindings::error::Error::JSFailed;
use dom::bindings::error::ErrorResult;
use dom::bindings::error::Fallible;
use dom::bindings::error::throw_dom_exception;
use dom::bindings::guard::Condition;
use dom::bindings::guard::Guard;
use dom::bindings::htmlconstructor::html_constructor;
use dom::bindings::htmlconstructor::pop_current_element_queue;
use dom::bindings::htmlconstructor::push_new_element_queue;
use dom::bindings::inheritance::Castable;
use dom::bindings::interface::ConstructorClassHook;
use dom::bindings::interface::InterfaceConstructorBehavior;
use dom::bindings::interface::NonCallbackInterfaceObjectClass;
use dom::bindings::interface::create_callback_interface_object;
use dom::bindings::interface::create_global_object;
use dom::bindings::interface::create_interface_prototype_object;
use dom::bindings::interface::create_named_constructors;
use dom::bindings::interface::create_noncallback_interface_object;
use dom::bindings::interface::define_guarded_constants;
use dom::bindings::interface::define_guarded_methods;
use dom::bindings::interface::define_guarded_properties;
use dom::bindings::interface::is_exposed_in;
use dom::bindings::iterable::Iterable;
use dom::bindings::iterable::IteratorType;
use dom::bindings::mozmap::MozMap;
use dom::bindings::namespace::NamespaceObjectClass;
use dom::bindings::namespace::create_namespace_object;
use dom::bindings::num::Finite;
use dom::bindings::proxyhandler;
use dom::bindings::proxyhandler::ensure_expando_object;
use dom::bindings::proxyhandler::fill_property_descriptor;
use dom::bindings::proxyhandler::get_expando_object;
use dom::bindings::proxyhandler::get_property_descriptor;
use dom::bindings::reflector::DomObject;
use dom::bindings::reflector::MutDomObject;
use dom::bindings::root::Dom;
use dom::bindings::root::DomRoot;
use dom::bindings::root::OptionalHeapSetter;
use dom::bindings::root::RootedReference;
use dom::bindings::str::ByteString;
use dom::bindings::str::DOMString;
use dom::bindings::str::USVString;
use dom::bindings::trace::JSTraceable;
use dom::bindings::trace::RootedTraceable;
use dom::bindings::trace::RootedTraceableBox;
use dom::bindings::utils::AsVoidPtr;
use dom::bindings::utils::DOMClass;
use dom::bindings::utils::DOMJSClass;
use dom::bindings::utils::DOM_PROTO_UNFORGEABLE_HOLDER_SLOT;
use dom::bindings::utils::JSCLASS_DOM_GLOBAL;
use dom::bindings::utils::ProtoOrIfaceArray;
use dom::bindings::utils::enumerate_global;
use dom::bindings::utils::finalize_global;
use dom::bindings::utils::find_enum_value;
use dom::bindings::utils::generic_getter;
use dom::bindings::utils::generic_lenient_getter;
use dom::bindings::utils::generic_lenient_setter;
use dom::bindings::utils::generic_method;
use dom::bindings::utils::generic_setter;
use dom::bindings::utils::get_array_index_from_id;
use dom::bindings::utils::get_dictionary_property;
use dom::bindings::utils::get_property_on_prototype;
use dom::bindings::utils::get_proto_or_iface_array;
use dom::bindings::utils::has_property_on_prototype;
use dom::bindings::utils::is_platform_object;
use dom::bindings::utils::resolve_global;
use dom::bindings::utils::set_dictionary_property;
use dom::bindings::utils::trace_global;
use dom::bindings::weakref::DOM_WEAK_SLOT;
use dom::bindings::weakref::WeakBox;
use dom::bindings::weakref::WeakReferenceable;
use dom::globalscope::GlobalScope;
use dom::types::HTMLElement;
use dom::types::HTMLFrameSetElement;
use dom::windowproxy::WindowProxy;
use js;
use js::JSCLASS_GLOBAL_SLOT_COUNT;
use js::JSCLASS_IS_DOMJSCLASS;
use js::JSCLASS_IS_GLOBAL;
use js::JSCLASS_RESERVED_SLOTS_MASK;
use js::JS_CALLEE;
use js::error::throw_internal_error;
use js::error::throw_type_error;
use js::glue::AppendToAutoIdVector;
use js::glue::CallJitGetterOp;
use js::glue::CallJitMethodOp;
use js::glue::CallJitSetterOp;
use js::glue::CreateProxyHandler;
use js::glue::GetProxyPrivate;
use js::glue::ProxyTraps;
use js::glue::RUST_JSID_IS_INT;
use js::glue::RUST_JSID_IS_STRING;
use js::glue::RUST_SYMBOL_TO_JSID;
use js::glue::UnwrapObject;
use js::glue::int_to_jsid;
use js::jsapi::AutoIdVector;
use js::jsapi::CallArgs;
use js::jsapi::CurrentGlobalOrNull;
use js::jsapi::FreeOp;
use js::jsapi::GetWellKnownSymbol;
use js::jsapi::Handle as RawHandle;
use js::jsapi::HandleId as RawHandleId;
use js::jsapi::HandleObject as RawHandleObject;
use js::jsapi::HandleValue as RawHandleValue;
use js::jsapi::HandleValueArray;
use js::jsapi::Heap;
use js::jsapi::INTERNED_STRING_TO_JSID;
use js::jsapi::IsCallable;
use js::jsapi::JSAutoCompartment;
use js::jsapi::JSCLASS_RESERVED_SLOTS_SHIFT;
use js::jsapi::JSClass;
use js::jsapi::JSContext;
use js::jsapi::JSFreeOp;
use js::jsapi::JSFunctionSpec;
use js::jsapi::JSITER_HIDDEN;
use js::jsapi::JSITER_OWNONLY;
use js::jsapi::JSITER_SYMBOLS;
use js::jsapi::JSJitGetterCallArgs;
use js::jsapi::JSJitInfo;
use js::jsapi::JSJitInfo_AliasSet;
use js::jsapi::JSJitInfo_ArgType;
use js::jsapi::JSJitInfo_OpType;
use js::jsapi::JSJitMethodCallArgs;
use js::jsapi::JSJitSetterCallArgs;
use js::jsapi::JSNative;
use js::jsapi::JSNativeWrapper;
use js::jsapi::JSObject;
use js::jsapi::JSPROP_ENUMERATE;
use js::jsapi::JSPROP_PERMANENT;
use js::jsapi::JSPROP_READONLY;
use js::jsapi::JSPROP_SHARED;
use js::jsapi::JSPropertySpec;
use js::jsapi::JSString;
use js::jsapi::JSTracer;
use js::jsapi::JSType;
use js::jsapi::JSTypedMethodJitInfo;
use js::jsapi::JSValueType;
use js::jsapi::JS_AtomizeAndPinString;
use js::jsapi::JS_ForwardGetPropertyTo;
use js::jsapi::JS_GetErrorPrototype;
use js::jsapi::JS_GetGlobalForObject;
use js::jsapi::JS_GetIteratorPrototype;
use js::jsapi::JS_GetPropertyById;
use js::jsapi::JS_GetPropertyDescriptorById;
use js::jsapi::JS_GetReservedSlot;
use js::jsapi::JS_HasProperty;
use js::jsapi::JS_HasPropertyById;
use js::jsapi::JS_NewObject;
use js::jsapi::JS_SetReservedSlot;
use js::jsapi::MutableHandle as RawMutableHandle;
use js::jsapi::MutableHandleObject as RawMutableHandleObject;
use js::jsapi::MutableHandleValue as RawMutableHandleValue;
use js::jsapi::ObjectOpResult;
use js::jsapi::PropertyDescriptor;
use js::jsapi::Rooted;
use js::jsapi::RootedId;
use js::jsapi::RootedObject;
use js::jsapi::RootedString;
use js::jsapi::SymbolCode;
use js::jsapi::jsid;
use js::jsval::JSVal;
use js::jsval::NullValue;
use js::jsval::ObjectOrNullValue;
use js::jsval::ObjectValue;
use js::jsval::PrivateValue;
use js::jsval::UndefinedValue;
use js::panic::maybe_resume_unwind;
use js::panic::wrap_panic;
use js::rust::CustomAutoRooterGuard;
use js::rust::GCMethods;
use js::rust::Handle;
use js::rust::HandleId;
use js::rust::HandleObject;
use js::rust::HandleValue;
use js::rust::MutableHandle;
use js::rust::MutableHandleObject;
use js::rust::MutableHandleValue;
use js::rust::define_methods;
use js::rust::define_properties;
use js::rust::get_object_class;
use js::rust::wrappers::Call;
use js::rust::wrappers::GetPropertyKeys;
use js::rust::wrappers::JS_CallFunctionValue;
use js::rust::wrappers::JS_CopyPropertiesFrom;
use js::rust::wrappers::JS_DefineProperty;
use js::rust::wrappers::JS_DefinePropertyById2;
use js::rust::wrappers::JS_GetFunctionPrototype;
use js::rust::wrappers::JS_GetObjectPrototype;
use js::rust::wrappers::JS_GetProperty;
use js::rust::wrappers::JS_InitializePropertiesFromCompatibleNativeObject;
use js::rust::wrappers::JS_NewObjectWithGivenProto;
use js::rust::wrappers::JS_NewObjectWithoutMetadata;
use js::rust::wrappers::JS_ObjectIsDate;
use js::rust::wrappers::JS_SetImmutablePrototype;
use js::rust::wrappers::JS_SetProperty;
use js::rust::wrappers::JS_SetPrototype;
use js::rust::wrappers::JS_SplicePrototype;
use js::rust::wrappers::JS_WrapObject;
use js::rust::wrappers::JS_WrapValue;
use js::rust::wrappers::NewProxyObject;
use js::typedarray;
use libc;
use malloc_size_of::MallocSizeOfOps;
use mem::malloc_size_of_including_raw_self;
use servo_config::prefs::PREFS;
use std::borrow::ToOwned;
use std::cmp;
use std::default::Default;
use std::ffi::CString;
use std::mem;
use std::num;
use std::os;
use std::os::raw::c_void;
use std::panic;
use std::ptr;
use std::ptr::NonNull;
use std::rc;
use std::rc::Rc;
use std::str;
use typeholder::TypeHolderTrait;

unsafe extern fn get_onafterprint<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnafterprint();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onafterprint<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnafterprint(arg0);

        return true;
    }), false);
}


const onafterprint_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onafterprint as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onafterprint_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onafterprint as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onbeforeprint<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnbeforeprint();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onbeforeprint<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnbeforeprint(arg0);

        return true;
    }), false);
}


const onbeforeprint_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onbeforeprint as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onbeforeprint_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onbeforeprint as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onbeforeunload<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::OnBeforeUnloadEventHandlerNonNull>> = this.GetOnbeforeunload();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onbeforeunload<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<OnBeforeUnloadEventHandlerNonNull>> = if args.get(0).get().is_object() {
            Some(OnBeforeUnloadEventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnbeforeunload(arg0);

        return true;
    }), false);
}


const onbeforeunload_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onbeforeunload as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onbeforeunload_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onbeforeunload as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onhashchange<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnhashchange();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onhashchange<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnhashchange(arg0);

        return true;
    }), false);
}


const onhashchange_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onhashchange as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onhashchange_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onhashchange as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onlanguagechange<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnlanguagechange();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onlanguagechange<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnlanguagechange(arg0);

        return true;
    }), false);
}


const onlanguagechange_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onlanguagechange as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onlanguagechange_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onlanguagechange as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onmessage<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnmessage();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onmessage<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnmessage(arg0);

        return true;
    }), false);
}


const onmessage_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onmessage as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onmessage_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onmessage as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onoffline<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnoffline();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onoffline<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnoffline(arg0);

        return true;
    }), false);
}


const onoffline_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onoffline as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onoffline_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onoffline as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_ononline<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnonline();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_ononline<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnonline(arg0);

        return true;
    }), false);
}


const ononline_getterinfo: JSJitInfo = JSJitInfo {
    call: get_ononline as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const ononline_setterinfo: JSJitInfo = JSJitInfo {
    call: set_ononline as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onpagehide<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnpagehide();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onpagehide<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnpagehide(arg0);

        return true;
    }), false);
}


const onpagehide_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onpagehide as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onpagehide_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onpagehide as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onpageshow<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnpageshow();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onpageshow<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnpageshow(arg0);

        return true;
    }), false);
}


const onpageshow_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onpageshow as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onpageshow_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onpageshow as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onpopstate<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnpopstate();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onpopstate<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnpopstate(arg0);

        return true;
    }), false);
}


const onpopstate_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onpopstate as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onpopstate_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onpopstate as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onrejectionhandled<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnrejectionhandled();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onrejectionhandled<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnrejectionhandled(arg0);

        return true;
    }), false);
}


const onrejectionhandled_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onrejectionhandled as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onrejectionhandled_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onrejectionhandled as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onstorage<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnstorage();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onstorage<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnstorage(arg0);

        return true;
    }), false);
}


const onstorage_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onstorage as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onstorage_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onstorage as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onunhandledrejection<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnunhandledrejection();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onunhandledrejection<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnunhandledrejection(arg0);

        return true;
    }), false);
}


const onunhandledrejection_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onunhandledrejection as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onunhandledrejection_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onunhandledrejection as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onunload<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnunload();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onunload<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnunload(arg0);

        return true;
    }), false);
}


const onunload_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onunload as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onunload_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onunload as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onvrdisplayconnect<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnvrdisplayconnect();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onvrdisplayconnect<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnvrdisplayconnect(arg0);

        return true;
    }), false);
}


const onvrdisplayconnect_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onvrdisplayconnect as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onvrdisplayconnect_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onvrdisplayconnect as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onvrdisplaydisconnect<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnvrdisplaydisconnect();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onvrdisplaydisconnect<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnvrdisplaydisconnect(arg0);

        return true;
    }), false);
}


const onvrdisplaydisconnect_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onvrdisplaydisconnect as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onvrdisplaydisconnect_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onvrdisplaydisconnect as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onvrdisplayactivate<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnvrdisplayactivate();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onvrdisplayactivate<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnvrdisplayactivate(arg0);

        return true;
    }), false);
}


const onvrdisplayactivate_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onvrdisplayactivate as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onvrdisplayactivate_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onvrdisplayactivate as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onvrdisplaydeactivate<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnvrdisplaydeactivate();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onvrdisplaydeactivate<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnvrdisplaydeactivate(arg0);

        return true;
    }), false);
}


const onvrdisplaydeactivate_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onvrdisplaydeactivate as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onvrdisplaydeactivate_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onvrdisplaydeactivate as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onvrdisplayblur<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnvrdisplayblur();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onvrdisplayblur<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnvrdisplayblur(arg0);

        return true;
    }), false);
}


const onvrdisplayblur_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onvrdisplayblur as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onvrdisplayblur_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onvrdisplayblur as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onvrdisplayfocus<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnvrdisplayfocus();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onvrdisplayfocus<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnvrdisplayfocus(arg0);

        return true;
    }), false);
}


const onvrdisplayfocus_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onvrdisplayfocus as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onvrdisplayfocus_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onvrdisplayfocus as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_onvrdisplaypresentchange<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnvrdisplaypresentchange();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onvrdisplaypresentchange<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const HTMLFrameSetElement<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnvrdisplaypresentchange(arg0);

        return true;
    }), false);
}


const onvrdisplaypresentchange_getterinfo: JSJitInfo = JSJitInfo {
    call: get_onvrdisplaypresentchange as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const onvrdisplaypresentchange_setterinfo: JSJitInfo = JSJitInfo {
    call: set_onvrdisplaypresentchange as *const os::raw::c_void,
    protoID: PrototypeList::ID::HTMLFrameSetElement as u16,
    depth: 4,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn _finalize<TH: TypeHolderTrait>
(_fop: *mut JSFreeOp, obj: *mut JSObject) {
    return wrap_panic(panic::AssertUnwindSafe(|| {

        let this = native_from_object::<HTMLFrameSetElement<TH>, TH>(obj).unwrap();
            if !this.is_null() {
                // The pointer can be null if the object is the unforgeable holder of that interface.
                let _ = Box::from_raw(this as *mut HTMLFrameSetElement<TH>);
            }
            debug!("HTMLFrameSetElement<TH> finalize: {:p}", this);
    }), ());
}

unsafe extern fn _trace<TH: TypeHolderTrait>
(trc: *mut JSTracer, obj: *mut JSObject) {
    return wrap_panic(panic::AssertUnwindSafe(|| {

        let this = native_from_object::<HTMLFrameSetElement<TH>, TH>(obj).unwrap();
        if this.is_null() { return; } // GC during obj creation
        (*this).trace(trc);
    }), ());
}

static CLASS_OPS: js::jsapi::JSClassOps = js::jsapi::JSClassOps {
    addProperty: None,
    delProperty: None,
    getProperty: None,
    setProperty: None,
    enumerate: None,
    resolve: None,
    mayResolve: None,
    finalize: Some(_finalize),
    call: None,
    hasInstance: None,
    construct: None,
    trace: Some(_trace),
};

static Class: DOMJSClass = DOMJSClass {
    base: js::jsapi::JSClass {
        name: b"HTMLFrameSetElement\0" as *const u8 as *const libc::c_char,
        flags: JSCLASS_IS_DOMJSCLASS | 0 |
               (((1) & JSCLASS_RESERVED_SLOTS_MASK) << JSCLASS_RESERVED_SLOTS_SHIFT)
               /* JSCLASS_HAS_RESERVED_SLOTS(1) */,
        cOps: &CLASS_OPS,
        reserved: [0 as *mut _; 3],
    },
    dom_class: DOMClass {
    interface_chain: [ PrototypeList::ID::EventTarget, PrototypeList::ID::Node, PrototypeList::ID::Element, PrototypeList::ID::HTMLElement, PrototypeList::ID::HTMLFrameSetElement, PrototypeList::ID::Last ],
    type_id: ::dom::bindings::codegen::InheritTypes::TopTypeId { eventtarget: (::dom::bindings::codegen::InheritTypes::EventTargetTypeId::Node(::dom::bindings::codegen::InheritTypes::NodeTypeId::Element(::dom::bindings::codegen::InheritTypes::ElementTypeId::HTMLElement(::dom::bindings::codegen::InheritTypes::HTMLElementTypeId::HTMLFrameSetElement)))) },
    global: InterfaceObjectMap::Globals::EMPTY,
}
};

#[inline]
fn malloc_size<TH: TypeHolderTrait>(ops: &mut MallocSizeOfOps, obj: *const c_void) -> usize {
    malloc_size_of_including_raw_self::<HTMLFrameSetElement<TH>>(ops, obj)
}

pub unsafe fn Wrap<TH: TypeHolderTrait>
(cx: *mut JSContext, scope: &GlobalScope<TH>, object: Box<HTMLFrameSetElement<TH>>) -> DomRoot<HTMLFrameSetElement<TH>> {
    let scope = scope.reflector().get_jsobject();
    assert!(!scope.get().is_null());
    assert!(((*get_object_class(scope.get())).flags & JSCLASS_IS_GLOBAL) != 0);

    rooted!(in(cx) let mut proto = ptr::null_mut::<JSObject>());
    let _ac = JSAutoCompartment::new(cx, scope.get());
    GetProtoObject(cx, scope, proto.handle_mut());
    assert!(!proto.is_null());

    let raw = Box::into_raw(object);
    let _rt = RootedTraceable::new(&*raw);
    rooted!(in(cx) let obj = JS_NewObjectWithGivenProto(
        cx, &Class.base as *const JSClass, proto.handle()));
    assert!(!obj.is_null());

    JS_SetReservedSlot(obj.get(), DOM_OBJECT_SLOT,
                       PrivateValue(raw as *const libc::c_void));


    (*raw).init_reflector(obj.get());

    DomRoot::from_ref(&*raw)
}

impl<TH: TypeHolderTrait> IDLInterface for HTMLFrameSetElement<TH> {
    #[inline]
    fn derives(class: &'static DOMClass) -> bool {
        class as *const _ == &Class.dom_class as *const _
    }
}

impl<TH: TypeHolderTrait> PartialEq for HTMLFrameSetElement<TH> {
    fn eq(&self, other: &HTMLFrameSetElement<TH>) -> bool {
        self as *const HTMLFrameSetElement<TH> == &*other
    }
}

pub trait HTMLFrameSetElementMethods<TH: TypeHolderTrait> {
    fn GetOnafterprint(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnafterprint(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnbeforeprint(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnbeforeprint(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnbeforeunload(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::OnBeforeUnloadEventHandlerNonNull<TH>>>;
    fn SetOnbeforeunload(&self, value: Option<Rc<OnBeforeUnloadEventHandlerNonNull<TH>>>) -> ();
    fn GetOnhashchange(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnhashchange(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnlanguagechange(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnlanguagechange(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnmessage(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnmessage(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnoffline(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnoffline(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnonline(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnonline(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnpagehide(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnpagehide(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnpageshow(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnpageshow(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnpopstate(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnpopstate(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnrejectionhandled(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnrejectionhandled(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnstorage(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnstorage(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnunhandledrejection(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnunhandledrejection(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnunload(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnunload(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnvrdisplayconnect(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnvrdisplayconnect(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnvrdisplaydisconnect(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnvrdisplaydisconnect(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnvrdisplayactivate(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnvrdisplayactivate(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnvrdisplaydeactivate(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnvrdisplaydeactivate(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnvrdisplayblur(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnvrdisplayblur(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnvrdisplayfocus(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnvrdisplayfocus(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnvrdisplaypresentchange(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnvrdisplaypresentchange(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
}
const sAttributes_specs: &'static [&'static[JSPropertySpec]] = &[
&[
    JSPropertySpec {
        name: b"onafterprint\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onafterprint_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onafterprint_setterinfo }
    },
    JSPropertySpec {
        name: b"onbeforeprint\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onbeforeprint_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onbeforeprint_setterinfo }
    },
    JSPropertySpec {
        name: b"onbeforeunload\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onbeforeunload_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onbeforeunload_setterinfo }
    },
    JSPropertySpec {
        name: b"onhashchange\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onhashchange_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onhashchange_setterinfo }
    },
    JSPropertySpec {
        name: b"onlanguagechange\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onlanguagechange_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onlanguagechange_setterinfo }
    },
    JSPropertySpec {
        name: b"onmessage\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onmessage_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onmessage_setterinfo }
    },
    JSPropertySpec {
        name: b"onoffline\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onoffline_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onoffline_setterinfo }
    },
    JSPropertySpec {
        name: b"ononline\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &ononline_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &ononline_setterinfo }
    },
    JSPropertySpec {
        name: b"onpagehide\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onpagehide_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onpagehide_setterinfo }
    },
    JSPropertySpec {
        name: b"onpageshow\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onpageshow_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onpageshow_setterinfo }
    },
    JSPropertySpec {
        name: b"onpopstate\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onpopstate_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onpopstate_setterinfo }
    },
    JSPropertySpec {
        name: b"onrejectionhandled\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onrejectionhandled_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onrejectionhandled_setterinfo }
    },
    JSPropertySpec {
        name: b"onstorage\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onstorage_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onstorage_setterinfo }
    },
    JSPropertySpec {
        name: b"onunhandledrejection\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onunhandledrejection_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onunhandledrejection_setterinfo }
    },
    JSPropertySpec {
        name: b"onunload\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onunload_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onunload_setterinfo }
    },
    JSPropertySpec {
        name: b"onvrdisplayconnect\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onvrdisplayconnect_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onvrdisplayconnect_setterinfo }
    },
    JSPropertySpec {
        name: b"onvrdisplaydisconnect\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onvrdisplaydisconnect_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onvrdisplaydisconnect_setterinfo }
    },
    JSPropertySpec {
        name: b"onvrdisplayactivate\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onvrdisplayactivate_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onvrdisplayactivate_setterinfo }
    },
    JSPropertySpec {
        name: b"onvrdisplaydeactivate\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onvrdisplaydeactivate_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onvrdisplaydeactivate_setterinfo }
    },
    JSPropertySpec {
        name: b"onvrdisplayblur\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onvrdisplayblur_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onvrdisplayblur_setterinfo }
    },
    JSPropertySpec {
        name: b"onvrdisplayfocus\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onvrdisplayfocus_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onvrdisplayfocus_setterinfo }
    },
    JSPropertySpec {
        name: b"onvrdisplaypresentchange\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onvrdisplaypresentchange_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onvrdisplaypresentchange_setterinfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]

];
const sAttributes: &'static [Guard<&'static [JSPropertySpec]>] = &[
    Guard::new(Condition::Satisfied, sAttributes_specs[0])
];

pub unsafe fn GetProtoObject<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject, mut rval: MutableHandleObject) {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    assert!(((*get_object_class(global.get())).flags & JSCLASS_DOM_GLOBAL) != 0);

    /* Check to see whether the interface objects are already installed */
    let proto_or_iface_array = get_proto_or_iface_array(global.get());
    rval.set((*proto_or_iface_array)[PrototypeList::ID::HTMLFrameSetElement as usize]);
    if !rval.get().is_null() {
        return;
    }

    CreateInterfaceObjects(cx, global, proto_or_iface_array);
    rval.set((*proto_or_iface_array)[PrototypeList::ID::HTMLFrameSetElement as usize]);
    assert!(!rval.get().is_null());

}

static PrototypeClass: JSClass = JSClass {
    name: b"HTMLFrameSetElementPrototype\0" as *const u8 as *const libc::c_char,
    flags:
        // JSCLASS_HAS_RESERVED_SLOTS(0)
        (0 & JSCLASS_RESERVED_SLOTS_MASK) << JSCLASS_RESERVED_SLOTS_SHIFT,
    cOps: 0 as *const _,
    reserved: [0 as *mut os::raw::c_void; 3]
};

unsafe extern fn _constructor<TH: TypeHolderTrait>
(cx: *mut JSContext, argc: u32, vp: *mut JSVal) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let global = GlobalScope::from_object(JS_CALLEE(cx, vp).to_object());
        let global = DomRoot::downcast::<dom::types::Window>(global).unwrap();
        let args = CallArgs::from_vp(vp, argc);
        // Step 2 https://html.spec.whatwg.org/multipage/#htmlconstructor
        // The custom element definition cannot use an element interface as its constructor

        // The new_target might be a cross-compartment wrapper. Get the underlying object
        // so we can do the spec's object-identity checks.
        rooted!(in(cx) let new_target = UnwrapObject(args.new_target().to_object(), 1));
        if new_target.is_null() {
            throw_dom_exception(cx, global.upcast::<GlobalScope<TH>>(), Error::Type("new.target is null".to_owned()));
            return false;
        }

        if args.callee() == new_target.get() {
            throw_dom_exception(cx, global.upcast::<GlobalScope<TH>>(),
                Error::Type("new.target must not be the active function object".to_owned()));
            return false;
        }

        // Step 6
        rooted!(in(cx) let mut prototype = ptr::null_mut::<JSObject>());
        {
            rooted!(in(cx) let mut proto_val = UndefinedValue());
            let _ac = JSAutoCompartment::new(cx, new_target.get());
            if !JS_GetProperty(cx, new_target.handle(), b"prototype\0".as_ptr() as *const _, proto_val.handle_mut()) {
                return false;
            }

            if !proto_val.is_object() {
                // Step 7 of https://html.spec.whatwg.org/multipage/#htmlconstructor.
                // This fallback behavior is designed to match analogous behavior for the
                // JavaScript built-ins. So we enter the compartment of our underlying
                // newTarget object and fall back to the prototype object from that global.
                // XXX The spec says to use GetFunctionRealm(), which is not actually
                // the same thing as what we have here (e.g. in the case of scripted callable proxies
                // whose target is not same-compartment with the proxy, or bound functions, etc).
                // https://bugzilla.mozilla.org/show_bug.cgi?id=1317658

                rooted!(in(cx) let global_object = CurrentGlobalOrNull(cx));
                GetProtoObject(cx, global_object.handle(), prototype.handle_mut());
            } else {
                // Step 6
                prototype.set(proto_val.to_object());
            };
        }

        // Wrap prototype in this context since it is from the newTarget compartment
        if !JS_WrapObject(cx, prototype.handle_mut()) {
            return false;
        }

        let result: Result<DomRoot<HTMLFrameSetElement>, Error> = html_constructor(&global, &args);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, global.upcast::<GlobalScope<TH>>(), e);
                return false;
            },
        };

        rooted!(in(cx) let mut element = result.reflector().get_jsobject().get());
        if !JS_WrapObject(cx, element.handle_mut()) {
            return false;
        }

        JS_SetPrototype(cx, element.handle(), prototype.handle());

        (result).to_jsval(cx, args.rval());
        return true;

    }), false);
}

static INTERFACE_OBJECT_CLASS: NonCallbackInterfaceObjectClass =
    NonCallbackInterfaceObjectClass::new(
        &InterfaceConstructorBehavior::call(_constructor),
        b"function HTMLFrameSetElement() {\n    [native code]\n}",
        PrototypeList::ID::HTMLFrameSetElement,
        4);

pub unsafe fn GetConstructorObject<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject, mut rval: MutableHandleObject) {
    /* Get the interface object for this class.  This will create the object as
       needed. */
    assert!(((*get_object_class(global.get())).flags & JSCLASS_DOM_GLOBAL) != 0);

    /* Check to see whether the interface objects are already installed */
    let proto_or_iface_array = get_proto_or_iface_array(global.get());
    rval.set((*proto_or_iface_array)[PrototypeList::Constructor::HTMLFrameSetElement as usize]);
    if !rval.get().is_null() {
        return;
    }

    CreateInterfaceObjects(cx, global, proto_or_iface_array);
    rval.set((*proto_or_iface_array)[PrototypeList::Constructor::HTMLFrameSetElement as usize]);
    assert!(!rval.get().is_null());

}

pub unsafe fn DefineDOMInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject) {
    assert!(!global.get().is_null());

    if !ConstructorEnabled(cx, global) {
        return;
    }

    rooted!(in(cx) let mut proto = ptr::null_mut::<JSObject>());
    GetProtoObject(cx, global, proto.handle_mut());
    assert!(!proto.is_null());
}

unsafe fn ConstructorEnabled<TH: TypeHolderTrait>
(aCx: *mut JSContext, aObj: HandleObject) -> bool {
    is_exposed_in(aObj, InterfaceObjectMap::Globals::WINDOW)
}

unsafe fn CreateInterfaceObjects<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject, cache: *mut ProtoOrIfaceArray) {
    rooted!(in(cx) let mut prototype_proto = ptr::null_mut::<JSObject>());
    HTMLElementBinding::GetProtoObject(cx, global, prototype_proto.handle_mut());
    assert!(!prototype_proto.is_null());

    rooted!(in(cx) let mut prototype = ptr::null_mut::<JSObject>());
    create_interface_prototype_object(cx,
                                      prototype_proto.handle().into(),
                                      &PrototypeClass,
                                      &[],
                                      sAttributes,
                                      &[],
                                      &[],
                                      prototype.handle_mut().into());
    assert!(!prototype.is_null());
    assert!((*cache)[PrototypeList::ID::HTMLFrameSetElement as usize].is_null());
    (*cache)[PrototypeList::ID::HTMLFrameSetElement as usize] = prototype.get();
    <*mut JSObject>::post_barrier((*cache).as_mut_ptr().offset(PrototypeList::ID::HTMLFrameSetElement as isize),
                                  ptr::null_mut(),
                                  prototype.get());


    rooted!(in(cx) let mut interface_proto = ptr::null_mut::<JSObject>());
    HTMLElementBinding::GetConstructorObject(cx, global, interface_proto.handle_mut());
    assert!(!interface_proto.is_null());

    rooted!(in(cx) let mut interface = ptr::null_mut::<JSObject>());
    create_noncallback_interface_object(cx,
                                        global.into(),
                                        interface_proto.handle(),
                                        &INTERFACE_OBJECT_CLASS,
                                        &[],
                                        &[],
                                        &[],
                                        prototype.handle(),
                                        b"HTMLFrameSetElement\0",
                                        0,
                                        interface.handle_mut());
    assert!(!interface.is_null());
    assert!((*cache)[PrototypeList::Constructor::HTMLFrameSetElement as usize].is_null());
    (*cache)[PrototypeList::Constructor::HTMLFrameSetElement as usize] = interface.get();
    <*mut JSObject>::post_barrier((*cache).as_mut_ptr().offset(PrototypeList::Constructor::HTMLFrameSetElement as isize),
                                  ptr::null_mut(),
                                  interface.get());

}
} // mod HTMLFrameSetElementBinding


