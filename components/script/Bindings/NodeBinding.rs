/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */

#![allow(non_camel_case_types,non_upper_case_globals,unused_imports,unused_variables,unused_assignments,unused_mut)]
use dom;
use dom::bindings;
use dom::bindings::callback::CallSetup;
use dom::bindings::callback::CallbackContainer;
use dom::bindings::callback::CallbackFunction;
use dom::bindings::callback::CallbackInterface;
use dom::bindings::callback::CallbackObject;
use dom::bindings::callback::ExceptionHandling;
use dom::bindings::callback::wrap_call_this_object;
use dom::bindings::codegen::InterfaceObjectMap;
use dom::bindings::codegen::PrototypeList;
use dom::bindings::codegen::RegisterBindings;
use dom::bindings::codegen::UnionTypes;
use dom::bindings::constant::ConstantSpec;
use dom::bindings::constant::ConstantVal;
use dom::bindings::conversions::ConversionBehavior;
use dom::bindings::conversions::ConversionResult;
use dom::bindings::conversions::DOM_OBJECT_SLOT;
use dom::bindings::conversions::FromJSValConvertible;
use dom::bindings::conversions::IDLInterface;
use dom::bindings::conversions::StringificationBehavior;
use dom::bindings::conversions::ToJSValConvertible;
use dom::bindings::conversions::is_array_like;
use dom::bindings::conversions::jsid_to_string;
use dom::bindings::conversions::native_from_handlevalue;
use dom::bindings::conversions::native_from_object;
use dom::bindings::conversions::private_from_object;
use dom::bindings::conversions::root_from_handleobject;
use dom::bindings::conversions::root_from_handlevalue;
use dom::bindings::conversions::root_from_object;
use dom::bindings::error::Error;
use dom::bindings::error::Error::JSFailed;
use dom::bindings::error::ErrorResult;
use dom::bindings::error::Fallible;
use dom::bindings::error::throw_dom_exception;
use dom::bindings::guard::Condition;
use dom::bindings::guard::Guard;
use dom::bindings::htmlconstructor::html_constructor;
use dom::bindings::htmlconstructor::pop_current_element_queue;
use dom::bindings::htmlconstructor::push_new_element_queue;
use dom::bindings::inheritance::Castable;
use dom::bindings::interface::ConstructorClassHook;
use dom::bindings::interface::InterfaceConstructorBehavior;
use dom::bindings::interface::NonCallbackInterfaceObjectClass;
use dom::bindings::interface::create_callback_interface_object;
use dom::bindings::interface::create_global_object;
use dom::bindings::interface::create_interface_prototype_object;
use dom::bindings::interface::create_named_constructors;
use dom::bindings::interface::create_noncallback_interface_object;
use dom::bindings::interface::define_guarded_constants;
use dom::bindings::interface::define_guarded_methods;
use dom::bindings::interface::define_guarded_properties;
use dom::bindings::interface::is_exposed_in;
use dom::bindings::iterable::Iterable;
use dom::bindings::iterable::IteratorType;
use dom::bindings::mozmap::MozMap;
use dom::bindings::namespace::NamespaceObjectClass;
use dom::bindings::namespace::create_namespace_object;
use dom::bindings::num::Finite;
use dom::bindings::proxyhandler;
use dom::bindings::proxyhandler::ensure_expando_object;
use dom::bindings::proxyhandler::fill_property_descriptor;
use dom::bindings::proxyhandler::get_expando_object;
use dom::bindings::proxyhandler::get_property_descriptor;
use dom::bindings::reflector::DomObject;
use dom::bindings::reflector::MutDomObject;
use dom::bindings::root::Dom;
use dom::bindings::root::DomRoot;
use dom::bindings::root::OptionalHeapSetter;
use dom::bindings::root::RootedReference;
use dom::bindings::str::ByteString;
use dom::bindings::str::DOMString;
use dom::bindings::str::USVString;
use dom::bindings::trace::JSTraceable;
use dom::bindings::trace::RootedTraceable;
use dom::bindings::trace::RootedTraceableBox;
use dom::bindings::utils::AsVoidPtr;
use dom::bindings::utils::DOMClass;
use dom::bindings::utils::DOMJSClass;
use dom::bindings::utils::DOM_PROTO_UNFORGEABLE_HOLDER_SLOT;
use dom::bindings::utils::JSCLASS_DOM_GLOBAL;
use dom::bindings::utils::ProtoOrIfaceArray;
use dom::bindings::utils::enumerate_global;
use dom::bindings::utils::finalize_global;
use dom::bindings::utils::find_enum_value;
use dom::bindings::utils::generic_getter;
use dom::bindings::utils::generic_lenient_getter;
use dom::bindings::utils::generic_lenient_setter;
use dom::bindings::utils::generic_method;
use dom::bindings::utils::generic_setter;
use dom::bindings::utils::get_array_index_from_id;
use dom::bindings::utils::get_dictionary_property;
use dom::bindings::utils::get_property_on_prototype;
use dom::bindings::utils::get_proto_or_iface_array;
use dom::bindings::utils::has_property_on_prototype;
use dom::bindings::utils::is_platform_object;
use dom::bindings::utils::resolve_global;
use dom::bindings::utils::set_dictionary_property;
use dom::bindings::utils::trace_global;
use dom::bindings::weakref::DOM_WEAK_SLOT;
use dom::bindings::weakref::WeakBox;
use dom::bindings::weakref::WeakReferenceable;
use dom::globalscope::GlobalScope;
use dom::windowproxy::WindowProxy;
use js;
use js::JSCLASS_GLOBAL_SLOT_COUNT;
use js::JSCLASS_IS_DOMJSCLASS;
use js::JSCLASS_IS_GLOBAL;
use js::JSCLASS_RESERVED_SLOTS_MASK;
use js::JS_CALLEE;
use js::error::throw_internal_error;
use js::error::throw_type_error;
use js::glue::AppendToAutoIdVector;
use js::glue::CallJitGetterOp;
use js::glue::CallJitMethodOp;
use js::glue::CallJitSetterOp;
use js::glue::CreateProxyHandler;
use js::glue::GetProxyPrivate;
use js::glue::ProxyTraps;
use js::glue::RUST_JSID_IS_INT;
use js::glue::RUST_JSID_IS_STRING;
use js::glue::RUST_SYMBOL_TO_JSID;
use js::glue::UnwrapObject;
use js::glue::int_to_jsid;
use js::jsapi::AutoIdVector;
use js::jsapi::CallArgs;
use js::jsapi::CurrentGlobalOrNull;
use js::jsapi::FreeOp;
use js::jsapi::GetWellKnownSymbol;
use js::jsapi::Handle as RawHandle;
use js::jsapi::HandleId as RawHandleId;
use js::jsapi::HandleObject as RawHandleObject;
use js::jsapi::HandleValue as RawHandleValue;
use js::jsapi::HandleValueArray;
use js::jsapi::Heap;
use js::jsapi::INTERNED_STRING_TO_JSID;
use js::jsapi::IsCallable;
use js::jsapi::JSAutoCompartment;
use js::jsapi::JSCLASS_RESERVED_SLOTS_SHIFT;
use js::jsapi::JSClass;
use js::jsapi::JSContext;
use js::jsapi::JSFreeOp;
use js::jsapi::JSFunctionSpec;
use js::jsapi::JSITER_HIDDEN;
use js::jsapi::JSITER_OWNONLY;
use js::jsapi::JSITER_SYMBOLS;
use js::jsapi::JSJitGetterCallArgs;
use js::jsapi::JSJitInfo;
use js::jsapi::JSJitInfo_AliasSet;
use js::jsapi::JSJitInfo_ArgType;
use js::jsapi::JSJitInfo_OpType;
use js::jsapi::JSJitMethodCallArgs;
use js::jsapi::JSJitSetterCallArgs;
use js::jsapi::JSNative;
use js::jsapi::JSNativeWrapper;
use js::jsapi::JSObject;
use js::jsapi::JSPROP_ENUMERATE;
use js::jsapi::JSPROP_PERMANENT;
use js::jsapi::JSPROP_READONLY;
use js::jsapi::JSPROP_SHARED;
use js::jsapi::JSPropertySpec;
use js::jsapi::JSString;
use js::jsapi::JSTracer;
use js::jsapi::JSType;
use js::jsapi::JSTypedMethodJitInfo;
use js::jsapi::JSValueType;
use js::jsapi::JS_AtomizeAndPinString;
use js::jsapi::JS_ForwardGetPropertyTo;
use js::jsapi::JS_GetErrorPrototype;
use js::jsapi::JS_GetGlobalForObject;
use js::jsapi::JS_GetIteratorPrototype;
use js::jsapi::JS_GetPropertyById;
use js::jsapi::JS_GetPropertyDescriptorById;
use js::jsapi::JS_GetReservedSlot;
use js::jsapi::JS_HasProperty;
use js::jsapi::JS_HasPropertyById;
use js::jsapi::JS_NewObject;
use js::jsapi::JS_SetReservedSlot;
use js::jsapi::MutableHandle as RawMutableHandle;
use js::jsapi::MutableHandleObject as RawMutableHandleObject;
use js::jsapi::MutableHandleValue as RawMutableHandleValue;
use js::jsapi::ObjectOpResult;
use js::jsapi::PropertyDescriptor;
use js::jsapi::Rooted;
use js::jsapi::RootedId;
use js::jsapi::RootedObject;
use js::jsapi::RootedString;
use js::jsapi::SymbolCode;
use js::jsapi::jsid;
use js::jsval::JSVal;
use js::jsval::NullValue;
use js::jsval::ObjectOrNullValue;
use js::jsval::ObjectValue;
use js::jsval::PrivateValue;
use js::jsval::UndefinedValue;
use js::panic::maybe_resume_unwind;
use js::panic::wrap_panic;
use js::rust::CustomAutoRooterGuard;
use js::rust::GCMethods;
use js::rust::Handle;
use js::rust::HandleId;
use js::rust::HandleObject;
use js::rust::HandleValue;
use js::rust::MutableHandle;
use js::rust::MutableHandleObject;
use js::rust::MutableHandleValue;
use js::rust::define_methods;
use js::rust::define_properties;
use js::rust::get_object_class;
use js::rust::wrappers::Call;
use js::rust::wrappers::GetPropertyKeys;
use js::rust::wrappers::JS_CallFunctionValue;
use js::rust::wrappers::JS_CopyPropertiesFrom;
use js::rust::wrappers::JS_DefineProperty;
use js::rust::wrappers::JS_DefinePropertyById2;
use js::rust::wrappers::JS_GetFunctionPrototype;
use js::rust::wrappers::JS_GetObjectPrototype;
use js::rust::wrappers::JS_GetProperty;
use js::rust::wrappers::JS_InitializePropertiesFromCompatibleNativeObject;
use js::rust::wrappers::JS_NewObjectWithGivenProto;
use js::rust::wrappers::JS_NewObjectWithoutMetadata;
use js::rust::wrappers::JS_ObjectIsDate;
use js::rust::wrappers::JS_SetImmutablePrototype;
use js::rust::wrappers::JS_SetProperty;
use js::rust::wrappers::JS_SetPrototype;
use js::rust::wrappers::JS_SplicePrototype;
use js::rust::wrappers::JS_WrapObject;
use js::rust::wrappers::JS_WrapValue;
use js::rust::wrappers::NewProxyObject;
use js::typedarray;
use libc;
use malloc_size_of::MallocSizeOfOps;
use mem::malloc_size_of_including_raw_self;
use servo_config::prefs::PREFS;
use std::borrow::ToOwned;
use std::cmp;
use std::default::Default;
use std::ffi::CString;
use std::mem;
use std::num;
use std::os;
use std::os::raw::c_void;
use std::panic;
use std::ptr;
use std::ptr::NonNull;
use std::rc;
use std::rc::Rc;
use std::str;
use typeholder::TypeHolderTrait;

pub use self::NodeBinding::{NodeConstants, NodeMethods, GetProtoObject, GetConstructorObject, DefineDOMInterface};
pub mod NodeBinding {
#![allow(non_camel_case_types,non_upper_case_globals,unused_imports,unused_variables,unused_assignments,unused_mut)]
use dom;
use dom::bindings;
use dom::bindings::callback::CallSetup;
use dom::bindings::callback::CallbackContainer;
use dom::bindings::callback::CallbackFunction;
use dom::bindings::callback::CallbackInterface;
use dom::bindings::callback::CallbackObject;
use dom::bindings::callback::ExceptionHandling;
use dom::bindings::callback::wrap_call_this_object;
use dom::bindings::codegen::Bindings::EventTargetBinding::EventTargetBinding;
use dom::bindings::codegen::Bindings::NodeBinding::NodeBinding;
use dom::bindings::codegen::InterfaceObjectMap;
use dom::bindings::codegen::PrototypeList;
use dom::bindings::codegen::RegisterBindings;
use dom::bindings::codegen::UnionTypes;
use dom::bindings::constant::ConstantSpec;
use dom::bindings::constant::ConstantVal;
use dom::bindings::conversions::ConversionBehavior;
use dom::bindings::conversions::ConversionResult;
use dom::bindings::conversions::DOM_OBJECT_SLOT;
use dom::bindings::conversions::FromJSValConvertible;
use dom::bindings::conversions::IDLInterface;
use dom::bindings::conversions::StringificationBehavior;
use dom::bindings::conversions::ToJSValConvertible;
use dom::bindings::conversions::is_array_like;
use dom::bindings::conversions::jsid_to_string;
use dom::bindings::conversions::native_from_handlevalue;
use dom::bindings::conversions::native_from_object;
use dom::bindings::conversions::private_from_object;
use dom::bindings::conversions::root_from_handleobject;
use dom::bindings::conversions::root_from_handlevalue;
use dom::bindings::conversions::root_from_object;
use dom::bindings::error::Error;
use dom::bindings::error::Error::JSFailed;
use dom::bindings::error::ErrorResult;
use dom::bindings::error::Fallible;
use dom::bindings::error::throw_dom_exception;
use dom::bindings::guard::Condition;
use dom::bindings::guard::Guard;
use dom::bindings::htmlconstructor::html_constructor;
use dom::bindings::htmlconstructor::pop_current_element_queue;
use dom::bindings::htmlconstructor::push_new_element_queue;
use dom::bindings::inheritance::Castable;
use dom::bindings::interface::ConstructorClassHook;
use dom::bindings::interface::InterfaceConstructorBehavior;
use dom::bindings::interface::NonCallbackInterfaceObjectClass;
use dom::bindings::interface::create_callback_interface_object;
use dom::bindings::interface::create_global_object;
use dom::bindings::interface::create_interface_prototype_object;
use dom::bindings::interface::create_named_constructors;
use dom::bindings::interface::create_noncallback_interface_object;
use dom::bindings::interface::define_guarded_constants;
use dom::bindings::interface::define_guarded_methods;
use dom::bindings::interface::define_guarded_properties;
use dom::bindings::interface::is_exposed_in;
use dom::bindings::iterable::Iterable;
use dom::bindings::iterable::IteratorType;
use dom::bindings::mozmap::MozMap;
use dom::bindings::namespace::NamespaceObjectClass;
use dom::bindings::namespace::create_namespace_object;
use dom::bindings::num::Finite;
use dom::bindings::proxyhandler;
use dom::bindings::proxyhandler::ensure_expando_object;
use dom::bindings::proxyhandler::fill_property_descriptor;
use dom::bindings::proxyhandler::get_expando_object;
use dom::bindings::proxyhandler::get_property_descriptor;
use dom::bindings::reflector::DomObject;
use dom::bindings::reflector::MutDomObject;
use dom::bindings::root::Dom;
use dom::bindings::root::DomRoot;
use dom::bindings::root::OptionalHeapSetter;
use dom::bindings::root::RootedReference;
use dom::bindings::str::ByteString;
use dom::bindings::str::DOMString;
use dom::bindings::str::USVString;
use dom::bindings::trace::JSTraceable;
use dom::bindings::trace::RootedTraceable;
use dom::bindings::trace::RootedTraceableBox;
use dom::bindings::utils::AsVoidPtr;
use dom::bindings::utils::DOMClass;
use dom::bindings::utils::DOMJSClass;
use dom::bindings::utils::DOM_PROTO_UNFORGEABLE_HOLDER_SLOT;
use dom::bindings::utils::JSCLASS_DOM_GLOBAL;
use dom::bindings::utils::ProtoOrIfaceArray;
use dom::bindings::utils::enumerate_global;
use dom::bindings::utils::finalize_global;
use dom::bindings::utils::find_enum_value;
use dom::bindings::utils::generic_getter;
use dom::bindings::utils::generic_lenient_getter;
use dom::bindings::utils::generic_lenient_setter;
use dom::bindings::utils::generic_method;
use dom::bindings::utils::generic_setter;
use dom::bindings::utils::get_array_index_from_id;
use dom::bindings::utils::get_dictionary_property;
use dom::bindings::utils::get_property_on_prototype;
use dom::bindings::utils::get_proto_or_iface_array;
use dom::bindings::utils::has_property_on_prototype;
use dom::bindings::utils::is_platform_object;
use dom::bindings::utils::resolve_global;
use dom::bindings::utils::set_dictionary_property;
use dom::bindings::utils::trace_global;
use dom::bindings::weakref::DOM_WEAK_SLOT;
use dom::bindings::weakref::WeakBox;
use dom::bindings::weakref::WeakReferenceable;
use dom::globalscope::GlobalScope;
use dom::types::Document;
use dom::types::Element;
use dom::types::EventTarget;
use dom::types::Node;
use dom::types::NodeList;
use dom::windowproxy::WindowProxy;
use js;
use js::JSCLASS_GLOBAL_SLOT_COUNT;
use js::JSCLASS_IS_DOMJSCLASS;
use js::JSCLASS_IS_GLOBAL;
use js::JSCLASS_RESERVED_SLOTS_MASK;
use js::JS_CALLEE;
use js::error::throw_internal_error;
use js::error::throw_type_error;
use js::glue::AppendToAutoIdVector;
use js::glue::CallJitGetterOp;
use js::glue::CallJitMethodOp;
use js::glue::CallJitSetterOp;
use js::glue::CreateProxyHandler;
use js::glue::GetProxyPrivate;
use js::glue::ProxyTraps;
use js::glue::RUST_JSID_IS_INT;
use js::glue::RUST_JSID_IS_STRING;
use js::glue::RUST_SYMBOL_TO_JSID;
use js::glue::UnwrapObject;
use js::glue::int_to_jsid;
use js::jsapi::AutoIdVector;
use js::jsapi::CallArgs;
use js::jsapi::CurrentGlobalOrNull;
use js::jsapi::FreeOp;
use js::jsapi::GetWellKnownSymbol;
use js::jsapi::Handle as RawHandle;
use js::jsapi::HandleId as RawHandleId;
use js::jsapi::HandleObject as RawHandleObject;
use js::jsapi::HandleValue as RawHandleValue;
use js::jsapi::HandleValueArray;
use js::jsapi::Heap;
use js::jsapi::INTERNED_STRING_TO_JSID;
use js::jsapi::IsCallable;
use js::jsapi::JSAutoCompartment;
use js::jsapi::JSCLASS_RESERVED_SLOTS_SHIFT;
use js::jsapi::JSClass;
use js::jsapi::JSContext;
use js::jsapi::JSFreeOp;
use js::jsapi::JSFunctionSpec;
use js::jsapi::JSITER_HIDDEN;
use js::jsapi::JSITER_OWNONLY;
use js::jsapi::JSITER_SYMBOLS;
use js::jsapi::JSJitGetterCallArgs;
use js::jsapi::JSJitInfo;
use js::jsapi::JSJitInfo_AliasSet;
use js::jsapi::JSJitInfo_ArgType;
use js::jsapi::JSJitInfo_OpType;
use js::jsapi::JSJitMethodCallArgs;
use js::jsapi::JSJitSetterCallArgs;
use js::jsapi::JSNative;
use js::jsapi::JSNativeWrapper;
use js::jsapi::JSObject;
use js::jsapi::JSPROP_ENUMERATE;
use js::jsapi::JSPROP_PERMANENT;
use js::jsapi::JSPROP_READONLY;
use js::jsapi::JSPROP_SHARED;
use js::jsapi::JSPropertySpec;
use js::jsapi::JSString;
use js::jsapi::JSTracer;
use js::jsapi::JSType;
use js::jsapi::JSTypedMethodJitInfo;
use js::jsapi::JSValueType;
use js::jsapi::JS_AtomizeAndPinString;
use js::jsapi::JS_ForwardGetPropertyTo;
use js::jsapi::JS_GetErrorPrototype;
use js::jsapi::JS_GetGlobalForObject;
use js::jsapi::JS_GetIteratorPrototype;
use js::jsapi::JS_GetPropertyById;
use js::jsapi::JS_GetPropertyDescriptorById;
use js::jsapi::JS_GetReservedSlot;
use js::jsapi::JS_HasProperty;
use js::jsapi::JS_HasPropertyById;
use js::jsapi::JS_NewObject;
use js::jsapi::JS_SetReservedSlot;
use js::jsapi::MutableHandle as RawMutableHandle;
use js::jsapi::MutableHandleObject as RawMutableHandleObject;
use js::jsapi::MutableHandleValue as RawMutableHandleValue;
use js::jsapi::ObjectOpResult;
use js::jsapi::PropertyDescriptor;
use js::jsapi::Rooted;
use js::jsapi::RootedId;
use js::jsapi::RootedObject;
use js::jsapi::RootedString;
use js::jsapi::SymbolCode;
use js::jsapi::jsid;
use js::jsval::JSVal;
use js::jsval::NullValue;
use js::jsval::ObjectOrNullValue;
use js::jsval::ObjectValue;
use js::jsval::PrivateValue;
use js::jsval::UndefinedValue;
use js::panic::maybe_resume_unwind;
use js::panic::wrap_panic;
use js::rust::CustomAutoRooterGuard;
use js::rust::GCMethods;
use js::rust::Handle;
use js::rust::HandleId;
use js::rust::HandleObject;
use js::rust::HandleValue;
use js::rust::MutableHandle;
use js::rust::MutableHandleObject;
use js::rust::MutableHandleValue;
use js::rust::define_methods;
use js::rust::define_properties;
use js::rust::get_object_class;
use js::rust::wrappers::Call;
use js::rust::wrappers::GetPropertyKeys;
use js::rust::wrappers::JS_CallFunctionValue;
use js::rust::wrappers::JS_CopyPropertiesFrom;
use js::rust::wrappers::JS_DefineProperty;
use js::rust::wrappers::JS_DefinePropertyById2;
use js::rust::wrappers::JS_GetFunctionPrototype;
use js::rust::wrappers::JS_GetObjectPrototype;
use js::rust::wrappers::JS_GetProperty;
use js::rust::wrappers::JS_InitializePropertiesFromCompatibleNativeObject;
use js::rust::wrappers::JS_NewObjectWithGivenProto;
use js::rust::wrappers::JS_NewObjectWithoutMetadata;
use js::rust::wrappers::JS_ObjectIsDate;
use js::rust::wrappers::JS_SetImmutablePrototype;
use js::rust::wrappers::JS_SetProperty;
use js::rust::wrappers::JS_SetPrototype;
use js::rust::wrappers::JS_SplicePrototype;
use js::rust::wrappers::JS_WrapObject;
use js::rust::wrappers::JS_WrapValue;
use js::rust::wrappers::NewProxyObject;
use js::typedarray;
use libc;
use malloc_size_of::MallocSizeOfOps;
use mem::malloc_size_of_including_raw_self;
use servo_config::prefs::PREFS;
use std::borrow::ToOwned;
use std::cmp;
use std::default::Default;
use std::ffi::CString;
use std::mem;
use std::num;
use std::os;
use std::os::raw::c_void;
use std::panic;
use std::ptr;
use std::ptr::NonNull;
use std::rc;
use std::rc::Rc;
use std::str;
use typeholder::TypeHolderTrait;

unsafe extern fn get_nodeType<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Node<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: u16 = this.NodeType();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn nodeType_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_nodeType::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Node as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasNone as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_nodeName<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Node<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DOMString = this.NodeName();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn nodeName_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_nodeName::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Node as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasDOMSets as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_baseURI<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Node<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: USVString = this.BaseURI();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn baseURI_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_baseURI::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Node as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasDOMSets as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_ownerDocument<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Node<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DomRoot<Document<TH>>> = this.GetOwnerDocument();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn ownerDocument_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_ownerDocument::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Node as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasDOMSets as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getRootNode<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Node<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: DomRoot<Node<TH>> = this.GetRootNode();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

const getRootNode_methodinfo_argTypes: [i32; 1] = [ JSJitInfo_ArgType::ArgTypeListEnd as i32 ];
fn getRootNode_methodinfo<TH: TypeHolderTrait>() -> JSTypedMethodJitInfo { JSTypedMethodJitInfo {
    base:   JSJitInfo {
      call: getRootNode::<TH> as *const os::raw::c_void,
      protoID: PrototypeList::ID::Node as u16,
      depth: 1,
      _bitfield_1: new_jsjitinfo_bitfield_1!(
          JSJitInfo_OpType::Method as u8,
          JSJitInfo_AliasSet::AliasDOMSets as u8,
          JSValueType::JSVAL_TYPE_OBJECT as u8,
          true,
          true,
          false,
          false,
          false,
          true,
          0,
      ),
  },
    argTypes: &getRootNode_methodinfo_argTypes as *const _ as *const JSJitInfo_ArgType,
}}

unsafe extern fn get_parentNode<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Node<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DomRoot<Node<TH>>> = this.GetParentNode();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn parentNode_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_parentNode::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Node as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasDOMSets as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_parentElement<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Node<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DomRoot<Element<TH>>> = this.GetParentElement();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn parentElement_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_parentElement::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Node as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasDOMSets as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn hasChildNodes<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Node<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: bool = this.HasChildNodes();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

const hasChildNodes_methodinfo_argTypes: [i32; 1] = [ JSJitInfo_ArgType::ArgTypeListEnd as i32 ];
fn hasChildNodes_methodinfo<TH: TypeHolderTrait>() -> JSTypedMethodJitInfo { JSTypedMethodJitInfo {
    base:   JSJitInfo {
      call: hasChildNodes::<TH> as *const os::raw::c_void,
      protoID: PrototypeList::ID::Node as u16,
      depth: 1,
      _bitfield_1: new_jsjitinfo_bitfield_1!(
          JSJitInfo_OpType::Method as u8,
          JSJitInfo_AliasSet::AliasDOMSets as u8,
          JSValueType::JSVAL_TYPE_BOOLEAN as u8,
          true,
          true,
          false,
          false,
          false,
          true,
          0,
      ),
  },
    argTypes: &hasChildNodes_methodinfo_argTypes as *const _ as *const JSJitInfo_ArgType,
}}

unsafe extern fn get_childNodes<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Node<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<NodeList<TH>> = this.ChildNodes();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn childNodes_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_childNodes::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Node as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasNone as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_firstChild<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Node<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DomRoot<Node<TH>>> = this.GetFirstChild();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn firstChild_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_firstChild::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Node as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasDOMSets as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_lastChild<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Node<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DomRoot<Node<TH>>> = this.GetLastChild();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn lastChild_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_lastChild::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Node as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasDOMSets as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_previousSibling<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Node<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DomRoot<Node<TH>>> = this.GetPreviousSibling();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn previousSibling_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_previousSibling::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Node as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasDOMSets as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_nextSibling<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Node<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DomRoot<Node<TH>>> = this.GetNextSibling();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn nextSibling_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_nextSibling::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Node as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasDOMSets as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_nodeValue<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Node<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: Option<DOMString> = this.GetNodeValue();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_nodeValue<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Node<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<DOMString> = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: () = this.SetNodeValue(arg0);
        pop_current_element_queue();


        return true;
    }), false);
}


fn nodeValue_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_nodeValue::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Node as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasDOMSets as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn nodeValue_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_nodeValue::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Node as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_textContent<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Node<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        push_new_element_queue();

        let result: Option<DOMString> = this.GetTextContent();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_textContent<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Node<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<DOMString> = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        push_new_element_queue();

        let result: () = this.SetTextContent(arg0);
        pop_current_element_queue();


        return true;
    }), false);
}


fn textContent_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_textContent::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Node as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasDOMSets as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn textContent_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_textContent::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Node as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn normalize<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Node<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        push_new_element_queue();

        let result: () = this.Normalize();
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn normalize_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: normalize::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Node as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn cloneNode<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Node<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: bool = if args.get(0).is_undefined() {
            false
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        push_new_element_queue();

        let result: DomRoot<Node<TH>> = this.CloneNode(arg0);
        pop_current_element_queue();


        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn cloneNode_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: cloneNode::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Node as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn isEqualNode<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Node<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Node.isEqualNode\".");
            return false;
        }
        let arg0: Option<DomRoot<Node<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface Node.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: bool = this.IsEqualNode(arg0.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

const isEqualNode_methodinfo_argTypes: [i32; 2] = [ JSJitInfo_ArgType::Null as i32 | JSJitInfo_ArgType::Object as i32, JSJitInfo_ArgType::ArgTypeListEnd as i32 ];
fn isEqualNode_methodinfo<TH: TypeHolderTrait>() -> JSTypedMethodJitInfo { JSTypedMethodJitInfo {
    base:   JSJitInfo {
      call: isEqualNode::<TH> as *const os::raw::c_void,
      protoID: PrototypeList::ID::Node as u16,
      depth: 1,
      _bitfield_1: new_jsjitinfo_bitfield_1!(
          JSJitInfo_OpType::Method as u8,
          JSJitInfo_AliasSet::AliasDOMSets as u8,
          JSValueType::JSVAL_TYPE_BOOLEAN as u8,
          false,
          true,
          false,
          false,
          false,
          true,
          0,
      ),
  },
    argTypes: &isEqualNode_methodinfo_argTypes as *const _ as *const JSJitInfo_ArgType,
}}

unsafe extern fn isSameNode<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Node<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Node.isSameNode\".");
            return false;
        }
        let arg0: Option<DomRoot<Node<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface Node.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: bool = this.IsSameNode(arg0.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

const isSameNode_methodinfo_argTypes: [i32; 2] = [ JSJitInfo_ArgType::Null as i32 | JSJitInfo_ArgType::Object as i32, JSJitInfo_ArgType::ArgTypeListEnd as i32 ];
fn isSameNode_methodinfo<TH: TypeHolderTrait>() -> JSTypedMethodJitInfo { JSTypedMethodJitInfo {
    base:   JSJitInfo {
      call: isSameNode::<TH> as *const os::raw::c_void,
      protoID: PrototypeList::ID::Node as u16,
      depth: 1,
      _bitfield_1: new_jsjitinfo_bitfield_1!(
          JSJitInfo_OpType::Method as u8,
          JSJitInfo_AliasSet::AliasDOMSets as u8,
          JSValueType::JSVAL_TYPE_BOOLEAN as u8,
          false,
          true,
          false,
          false,
          false,
          true,
          0,
      ),
  },
    argTypes: &isSameNode_methodinfo_argTypes as *const _ as *const JSJitInfo_ArgType,
}}

unsafe extern fn compareDocumentPosition<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Node<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Node.compareDocumentPosition\".");
            return false;
        }
        let arg0: DomRoot<Node<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface Node.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: u16 = this.CompareDocumentPosition(&arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

const compareDocumentPosition_methodinfo_argTypes: [i32; 2] = [ JSJitInfo_ArgType::Object as i32, JSJitInfo_ArgType::ArgTypeListEnd as i32 ];
fn compareDocumentPosition_methodinfo<TH: TypeHolderTrait>() -> JSTypedMethodJitInfo { JSTypedMethodJitInfo {
    base:   JSJitInfo {
      call: compareDocumentPosition::<TH> as *const os::raw::c_void,
      protoID: PrototypeList::ID::Node as u16,
      depth: 1,
      _bitfield_1: new_jsjitinfo_bitfield_1!(
          JSJitInfo_OpType::Method as u8,
          JSJitInfo_AliasSet::AliasDOMSets as u8,
          JSValueType::JSVAL_TYPE_INT32 as u8,
          false,
          true,
          false,
          false,
          false,
          true,
          0,
      ),
  },
    argTypes: &compareDocumentPosition_methodinfo_argTypes as *const _ as *const JSJitInfo_ArgType,
}}

unsafe extern fn contains<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Node<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Node.contains\".");
            return false;
        }
        let arg0: Option<DomRoot<Node<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface Node.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: bool = this.Contains(arg0.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

const contains_methodinfo_argTypes: [i32; 2] = [ JSJitInfo_ArgType::Null as i32 | JSJitInfo_ArgType::Object as i32, JSJitInfo_ArgType::ArgTypeListEnd as i32 ];
fn contains_methodinfo<TH: TypeHolderTrait>() -> JSTypedMethodJitInfo { JSTypedMethodJitInfo {
    base:   JSJitInfo {
      call: contains::<TH> as *const os::raw::c_void,
      protoID: PrototypeList::ID::Node as u16,
      depth: 1,
      _bitfield_1: new_jsjitinfo_bitfield_1!(
          JSJitInfo_OpType::Method as u8,
          JSJitInfo_AliasSet::AliasDOMSets as u8,
          JSValueType::JSVAL_TYPE_BOOLEAN as u8,
          false,
          true,
          false,
          false,
          false,
          true,
          0,
      ),
  },
    argTypes: &contains_methodinfo_argTypes as *const _ as *const JSJitInfo_ArgType,
}}

unsafe extern fn lookupPrefix<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Node<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Node.lookupPrefix\".");
            return false;
        }
        let arg0: Option<DOMString> = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: Option<DOMString> = this.LookupPrefix(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

const lookupPrefix_methodinfo_argTypes: [i32; 2] = [ JSJitInfo_ArgType::Null as i32 | JSJitInfo_ArgType::String as i32, JSJitInfo_ArgType::ArgTypeListEnd as i32 ];
fn lookupPrefix_methodinfo<TH: TypeHolderTrait>() -> JSTypedMethodJitInfo { JSTypedMethodJitInfo {
    base:   JSJitInfo {
      call: lookupPrefix::<TH> as *const os::raw::c_void,
      protoID: PrototypeList::ID::Node as u16,
      depth: 1,
      _bitfield_1: new_jsjitinfo_bitfield_1!(
          JSJitInfo_OpType::Method as u8,
          JSJitInfo_AliasSet::AliasDOMSets as u8,
          JSValueType::JSVAL_TYPE_UNKNOWN as u8,
          false,
          true,
          false,
          false,
          false,
          true,
          0,
      ),
  },
    argTypes: &lookupPrefix_methodinfo_argTypes as *const _ as *const JSJitInfo_ArgType,
}}

unsafe extern fn lookupNamespaceURI<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Node<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Node.lookupNamespaceURI\".");
            return false;
        }
        let arg0: Option<DOMString> = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: Option<DOMString> = this.LookupNamespaceURI(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

const lookupNamespaceURI_methodinfo_argTypes: [i32; 2] = [ JSJitInfo_ArgType::Null as i32 | JSJitInfo_ArgType::String as i32, JSJitInfo_ArgType::ArgTypeListEnd as i32 ];
fn lookupNamespaceURI_methodinfo<TH: TypeHolderTrait>() -> JSTypedMethodJitInfo { JSTypedMethodJitInfo {
    base:   JSJitInfo {
      call: lookupNamespaceURI::<TH> as *const os::raw::c_void,
      protoID: PrototypeList::ID::Node as u16,
      depth: 1,
      _bitfield_1: new_jsjitinfo_bitfield_1!(
          JSJitInfo_OpType::Method as u8,
          JSJitInfo_AliasSet::AliasDOMSets as u8,
          JSValueType::JSVAL_TYPE_UNKNOWN as u8,
          false,
          true,
          false,
          false,
          false,
          true,
          0,
      ),
  },
    argTypes: &lookupNamespaceURI_methodinfo_argTypes as *const _ as *const JSJitInfo_ArgType,
}}

unsafe extern fn isDefaultNamespace<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Node<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Node.isDefaultNamespace\".");
            return false;
        }
        let arg0: Option<DOMString> = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: bool = this.IsDefaultNamespace(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

const isDefaultNamespace_methodinfo_argTypes: [i32; 2] = [ JSJitInfo_ArgType::Null as i32 | JSJitInfo_ArgType::String as i32, JSJitInfo_ArgType::ArgTypeListEnd as i32 ];
fn isDefaultNamespace_methodinfo<TH: TypeHolderTrait>() -> JSTypedMethodJitInfo { JSTypedMethodJitInfo {
    base:   JSJitInfo {
      call: isDefaultNamespace::<TH> as *const os::raw::c_void,
      protoID: PrototypeList::ID::Node as u16,
      depth: 1,
      _bitfield_1: new_jsjitinfo_bitfield_1!(
          JSJitInfo_OpType::Method as u8,
          JSJitInfo_AliasSet::AliasDOMSets as u8,
          JSValueType::JSVAL_TYPE_BOOLEAN as u8,
          false,
          true,
          false,
          false,
          false,
          true,
          0,
      ),
  },
    argTypes: &isDefaultNamespace_methodinfo_argTypes as *const _ as *const JSJitInfo_ArgType,
}}

unsafe extern fn insertBefore<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Node<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"Node.insertBefore\".");
            return false;
        }
        let arg0: DomRoot<Node<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface Node.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: Option<DomRoot<Node<TH>>> = if args.get(1).get().is_object() {
            Some(match root_from_handlevalue(args.get(1)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface Node.");
                    return false;

                }
            }
            )
        } else if args.get(1).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        push_new_element_queue();

        let result: Result<DomRoot<Node<TH>>, Error<TH>> = this.InsertBefore(&arg0, arg1.r());
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn insertBefore_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: insertBefore::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Node as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn appendChild<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Node<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Node.appendChild\".");
            return false;
        }
        let arg0: DomRoot<Node<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface Node.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        push_new_element_queue();

        let result: Result<DomRoot<Node<TH>>, Error<TH>> = this.AppendChild(&arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn appendChild_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: appendChild::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Node as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn replaceChild<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Node<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"Node.replaceChild\".");
            return false;
        }
        let arg0: DomRoot<Node<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface Node.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: DomRoot<Node<TH>> = if args.get(1).get().is_object() {
            match root_from_handlevalue(args.get(1)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface Node.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        push_new_element_queue();

        let result: Result<DomRoot<Node<TH>>, Error<TH>> = this.ReplaceChild(&arg0, &arg1);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn replaceChild_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: replaceChild::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Node as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn removeChild<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Node<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Node.removeChild\".");
            return false;
        }
        let arg0: DomRoot<Node<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface Node.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        push_new_element_queue();

        let result: Result<DomRoot<Node<TH>>, Error<TH>> = this.RemoveChild(&arg0);
        pop_current_element_queue();

        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn removeChild_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: removeChild::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Node as u16,
    depth: 1,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

pub mod NodeConstants {
    pub const ELEMENT_NODE: u16 = 1;
    pub const ATTRIBUTE_NODE: u16 = 2;
    pub const TEXT_NODE: u16 = 3;
    pub const CDATA_SECTION_NODE: u16 = 4;
    pub const ENTITY_REFERENCE_NODE: u16 = 5;
    pub const ENTITY_NODE: u16 = 6;
    pub const PROCESSING_INSTRUCTION_NODE: u16 = 7;
    pub const COMMENT_NODE: u16 = 8;
    pub const DOCUMENT_NODE: u16 = 9;
    pub const DOCUMENT_TYPE_NODE: u16 = 10;
    pub const DOCUMENT_FRAGMENT_NODE: u16 = 11;
    pub const NOTATION_NODE: u16 = 12;
    pub const DOCUMENT_POSITION_DISCONNECTED: u16 = 1;
    pub const DOCUMENT_POSITION_PRECEDING: u16 = 2;
    pub const DOCUMENT_POSITION_FOLLOWING: u16 = 4;
    pub const DOCUMENT_POSITION_CONTAINS: u16 = 8;
    pub const DOCUMENT_POSITION_CONTAINED_BY: u16 = 16;
    pub const DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: u16 = 32;
} // mod NodeConstants
impl<TH: TypeHolderTrait> IDLInterface for Node<TH> {
    #[inline]
    fn derives(class: &'static DOMClass) -> bool {
        class.interface_chain[1] == PrototypeList::ID::Node
    }
}

impl<TH: TypeHolderTrait> PartialEq for Node<TH> {
    fn eq(&self, other: &Node<TH>) -> bool {
        self as *const Node<TH> == &*other
    }
}

pub trait NodeMethods<TH: TypeHolderTrait> {
    fn NodeType(&self) -> u16;
    fn NodeName(&self) -> DOMString;
    fn BaseURI(&self) -> USVString;
    fn GetOwnerDocument(&self) -> Option<DomRoot<Document<TH>>>;
    fn GetRootNode(&self) -> DomRoot<Node<TH>>;
    fn GetParentNode(&self) -> Option<DomRoot<Node<TH>>>;
    fn GetParentElement(&self) -> Option<DomRoot<Element<TH>>>;
    fn HasChildNodes(&self) -> bool;
    fn ChildNodes(&self) -> DomRoot<NodeList<TH>>;
    fn GetFirstChild(&self) -> Option<DomRoot<Node<TH>>>;
    fn GetLastChild(&self) -> Option<DomRoot<Node<TH>>>;
    fn GetPreviousSibling(&self) -> Option<DomRoot<Node<TH>>>;
    fn GetNextSibling(&self) -> Option<DomRoot<Node<TH>>>;
    fn GetNodeValue(&self) -> Option<DOMString>;
    fn SetNodeValue(&self, value: Option<DOMString>) -> ();
    fn GetTextContent(&self) -> Option<DOMString>;
    fn SetTextContent(&self, value: Option<DOMString>) -> ();
    fn Normalize(&self) -> ();
    fn CloneNode(&self, deep: bool) -> DomRoot<Node<TH>>;
    fn IsEqualNode(&self, node: Option<&Node<TH>>) -> bool;
    fn IsSameNode(&self, otherNode: Option<&Node<TH>>) -> bool;
    fn CompareDocumentPosition(&self, other: &Node<TH>) -> u16;
    fn Contains(&self, other: Option<&Node<TH>>) -> bool;
    fn LookupPrefix(&self, namespace: Option<DOMString>) -> Option<DOMString>;
    fn LookupNamespaceURI(&self, prefix: Option<DOMString>) -> Option<DOMString>;
    fn IsDefaultNamespace(&self, namespace: Option<DOMString>) -> bool;
    fn InsertBefore(&self, node: &Node<TH>, child: Option<&Node<TH>>) -> Fallible<DomRoot<Node<TH>>, TH>;
    fn AppendChild(&self, node: &Node<TH>) -> Fallible<DomRoot<Node<TH>>, TH>;
    fn ReplaceChild(&self, node: &Node<TH>, child: &Node<TH>) -> Fallible<DomRoot<Node<TH>>, TH>;
    fn RemoveChild(&self, child: &Node<TH>) -> Fallible<DomRoot<Node<TH>>, TH>;
}
fn sMethods_specs<TH: TypeHolderTrait>() -> &'static [&'static[JSFunctionSpec]] { &[
&[
    JSFunctionSpec {
        name: b"getRootNode\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getRootNode_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"hasChildNodes\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &hasChildNodes_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"normalize\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &normalize_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"cloneNode\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &cloneNode_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"isEqualNode\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &isEqualNode_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"isSameNode\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &isSameNode_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"compareDocumentPosition\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &compareDocumentPosition_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"contains\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &contains_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"lookupPrefix\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &lookupPrefix_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"lookupNamespaceURI\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &lookupNamespaceURI_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"isDefaultNamespace\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &isDefaultNamespace_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"insertBefore\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &insertBefore_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"appendChild\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &appendChild_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"replaceChild\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &replaceChild_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"removeChild\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &removeChild_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]

]}
fn sMethods<TH: TypeHolderTrait>() -> &'static [Guard<&'static [JSFunctionSpec]>] { &[
    Guard::new(Condition::Satisfied, sMethods_specs::<TH>()[0])
]}
fn sAttributes_specs<TH: TypeHolderTrait>() -> &'static [&'static[JSPropertySpec]] { &[
&[
    JSPropertySpec {
        name: b"nodeType\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &nodeType_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"nodeName\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &nodeName_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"baseURI\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &baseURI_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"ownerDocument\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &ownerDocument_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"parentNode\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &parentNode_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"parentElement\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &parentElement_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"childNodes\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &childNodes_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"firstChild\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &firstChild_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"lastChild\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &lastChild_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"previousSibling\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &previousSibling_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"nextSibling\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &nextSibling_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"nodeValue\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &nodeValue_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &nodeValue_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"textContent\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &textContent_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &textContent_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]

]}
fn sAttributes<TH: TypeHolderTrait>() -> &'static [Guard<&'static [JSPropertySpec]>] { &[
    Guard::new(Condition::Satisfied, sAttributes_specs::<TH>()[0])
]}
const sConstants_specs: &'static [&'static[ConstantSpec]] = &[
&[
    ConstantSpec { name: b"ELEMENT_NODE\0", value: ConstantVal::IntVal(1) },
    ConstantSpec { name: b"ATTRIBUTE_NODE\0", value: ConstantVal::IntVal(2) },
    ConstantSpec { name: b"TEXT_NODE\0", value: ConstantVal::IntVal(3) },
    ConstantSpec { name: b"CDATA_SECTION_NODE\0", value: ConstantVal::IntVal(4) },
    ConstantSpec { name: b"ENTITY_REFERENCE_NODE\0", value: ConstantVal::IntVal(5) },
    ConstantSpec { name: b"ENTITY_NODE\0", value: ConstantVal::IntVal(6) },
    ConstantSpec { name: b"PROCESSING_INSTRUCTION_NODE\0", value: ConstantVal::IntVal(7) },
    ConstantSpec { name: b"COMMENT_NODE\0", value: ConstantVal::IntVal(8) },
    ConstantSpec { name: b"DOCUMENT_NODE\0", value: ConstantVal::IntVal(9) },
    ConstantSpec { name: b"DOCUMENT_TYPE_NODE\0", value: ConstantVal::IntVal(10) },
    ConstantSpec { name: b"DOCUMENT_FRAGMENT_NODE\0", value: ConstantVal::IntVal(11) },
    ConstantSpec { name: b"NOTATION_NODE\0", value: ConstantVal::IntVal(12) },
    ConstantSpec { name: b"DOCUMENT_POSITION_DISCONNECTED\0", value: ConstantVal::IntVal(1) },
    ConstantSpec { name: b"DOCUMENT_POSITION_PRECEDING\0", value: ConstantVal::IntVal(2) },
    ConstantSpec { name: b"DOCUMENT_POSITION_FOLLOWING\0", value: ConstantVal::IntVal(4) },
    ConstantSpec { name: b"DOCUMENT_POSITION_CONTAINS\0", value: ConstantVal::IntVal(8) },
    ConstantSpec { name: b"DOCUMENT_POSITION_CONTAINED_BY\0", value: ConstantVal::IntVal(16) },
    ConstantSpec { name: b"DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC\0", value: ConstantVal::IntVal(32) }]

];
const sConstants: &'static [Guard<&'static [ConstantSpec]>] = &[
    Guard::new(Condition::Satisfied, sConstants_specs[0])
];

pub unsafe fn GetProtoObject<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject, mut rval: MutableHandleObject) {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    assert!(((*get_object_class(global.get())).flags & JSCLASS_DOM_GLOBAL) != 0);

    /* Check to see whether the interface objects are already installed */
    let proto_or_iface_array = get_proto_or_iface_array(global.get());
    rval.set((*proto_or_iface_array)[PrototypeList::ID::Node as usize]);
    if !rval.get().is_null() {
        return;
    }

    CreateInterfaceObjects(cx, global, proto_or_iface_array);
    rval.set((*proto_or_iface_array)[PrototypeList::ID::Node as usize]);
    assert!(!rval.get().is_null());

}

static PrototypeClass: JSClass = JSClass {
    name: b"NodePrototype\0" as *const u8 as *const libc::c_char,
    flags:
        // JSCLASS_HAS_RESERVED_SLOTS(0)
        (0 & JSCLASS_RESERVED_SLOTS_MASK) << JSCLASS_RESERVED_SLOTS_SHIFT,
    cOps: 0 as *const _,
    reserved: [0 as *mut os::raw::c_void; 3]
};

static INTERFACE_OBJECT_CLASS: NonCallbackInterfaceObjectClass =
    NonCallbackInterfaceObjectClass::new(
        &InterfaceConstructorBehavior::throw(),
        b"function Node() {\n    [native code]\n}",
        PrototypeList::ID::Node,
        1);

pub unsafe fn GetConstructorObject<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject, mut rval: MutableHandleObject) {
    /* Get the interface object for this class.  This will create the object as
       needed. */
    assert!(((*get_object_class(global.get())).flags & JSCLASS_DOM_GLOBAL) != 0);

    /* Check to see whether the interface objects are already installed */
    let proto_or_iface_array = get_proto_or_iface_array(global.get());
    rval.set((*proto_or_iface_array)[PrototypeList::Constructor::Node as usize]);
    if !rval.get().is_null() {
        return;
    }

    CreateInterfaceObjects(cx, global, proto_or_iface_array);
    rval.set((*proto_or_iface_array)[PrototypeList::Constructor::Node as usize]);
    assert!(!rval.get().is_null());

}

pub unsafe fn DefineDOMInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject) {
    assert!(!global.get().is_null());

    if !ConstructorEnabled(cx, global) {
        return;
    }

    rooted!(in(cx) let mut proto = ptr::null_mut::<JSObject>());
    GetProtoObject(cx, global, proto.handle_mut());
    assert!(!proto.is_null());
}

unsafe fn ConstructorEnabled<TH: TypeHolderTrait>
(aCx: *mut JSContext, aObj: HandleObject) -> bool {
    is_exposed_in(aObj, InterfaceObjectMap::Globals::WINDOW)
}

unsafe fn CreateInterfaceObjects<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject, cache: *mut ProtoOrIfaceArray) {
    rooted!(in(cx) let mut prototype_proto = ptr::null_mut::<JSObject>());
    EventTargetBinding::GetProtoObject(cx, global, prototype_proto.handle_mut());
    assert!(!prototype_proto.is_null());

    rooted!(in(cx) let mut prototype = ptr::null_mut::<JSObject>());
    create_interface_prototype_object(cx,
                                      prototype_proto.handle().into(),
                                      &PrototypeClass,
                                      sMethods::<TH>(),
                                      sAttributes::<TH>(),
                                      sConstants,
                                      &[],
                                      prototype.handle_mut().into());
    assert!(!prototype.is_null());
    assert!((*cache)[PrototypeList::ID::Node as usize].is_null());
    (*cache)[PrototypeList::ID::Node as usize] = prototype.get();
    <*mut JSObject>::post_barrier((*cache).as_mut_ptr().offset(PrototypeList::ID::Node as isize),
                                  ptr::null_mut(),
                                  prototype.get());


    rooted!(in(cx) let mut interface_proto = ptr::null_mut::<JSObject>());
    EventTargetBinding::GetConstructorObject(cx, global, interface_proto.handle_mut());
    assert!(!interface_proto.is_null());

    rooted!(in(cx) let mut interface = ptr::null_mut::<JSObject>());
    create_noncallback_interface_object(cx,
                                        global.into(),
                                        interface_proto.handle(),
                                        &INTERFACE_OBJECT_CLASS,
                                        &[],
                                        &[],
                                        sConstants,
                                        prototype.handle(),
                                        b"Node\0",
                                        0,
                                        interface.handle_mut());
    assert!(!interface.is_null());
    assert!((*cache)[PrototypeList::Constructor::Node as usize].is_null());
    (*cache)[PrototypeList::Constructor::Node as usize] = interface.get();
    <*mut JSObject>::post_barrier((*cache).as_mut_ptr().offset(PrototypeList::Constructor::Node as isize),
                                  ptr::null_mut(),
                                  interface.get());

}
} // mod NodeBinding


