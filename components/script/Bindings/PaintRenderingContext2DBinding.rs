/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */

#![allow(non_camel_case_types,non_upper_case_globals,unused_imports,unused_variables,unused_assignments,unused_mut)]
use dom;
use dom::bindings;
use dom::bindings::callback::CallSetup;
use dom::bindings::callback::CallbackContainer;
use dom::bindings::callback::CallbackFunction;
use dom::bindings::callback::CallbackInterface;
use dom::bindings::callback::CallbackObject;
use dom::bindings::callback::ExceptionHandling;
use dom::bindings::callback::wrap_call_this_object;
use dom::bindings::codegen::InterfaceObjectMap;
use dom::bindings::codegen::PrototypeList;
use dom::bindings::codegen::RegisterBindings;
use dom::bindings::codegen::UnionTypes;
use dom::bindings::constant::ConstantSpec;
use dom::bindings::constant::ConstantVal;
use dom::bindings::conversions::ConversionBehavior;
use dom::bindings::conversions::ConversionResult;
use dom::bindings::conversions::DOM_OBJECT_SLOT;
use dom::bindings::conversions::FromJSValConvertible;
use dom::bindings::conversions::IDLInterface;
use dom::bindings::conversions::StringificationBehavior;
use dom::bindings::conversions::ToJSValConvertible;
use dom::bindings::conversions::is_array_like;
use dom::bindings::conversions::jsid_to_string;
use dom::bindings::conversions::native_from_handlevalue;
use dom::bindings::conversions::native_from_object;
use dom::bindings::conversions::private_from_object;
use dom::bindings::conversions::root_from_handleobject;
use dom::bindings::conversions::root_from_handlevalue;
use dom::bindings::conversions::root_from_object;
use dom::bindings::error::Error;
use dom::bindings::error::Error::JSFailed;
use dom::bindings::error::ErrorResult;
use dom::bindings::error::Fallible;
use dom::bindings::error::throw_dom_exception;
use dom::bindings::guard::Condition;
use dom::bindings::guard::Guard;
use dom::bindings::htmlconstructor::html_constructor;
use dom::bindings::htmlconstructor::pop_current_element_queue;
use dom::bindings::htmlconstructor::push_new_element_queue;
use dom::bindings::inheritance::Castable;
use dom::bindings::interface::ConstructorClassHook;
use dom::bindings::interface::InterfaceConstructorBehavior;
use dom::bindings::interface::NonCallbackInterfaceObjectClass;
use dom::bindings::interface::create_callback_interface_object;
use dom::bindings::interface::create_global_object;
use dom::bindings::interface::create_interface_prototype_object;
use dom::bindings::interface::create_named_constructors;
use dom::bindings::interface::create_noncallback_interface_object;
use dom::bindings::interface::define_guarded_constants;
use dom::bindings::interface::define_guarded_methods;
use dom::bindings::interface::define_guarded_properties;
use dom::bindings::interface::is_exposed_in;
use dom::bindings::iterable::Iterable;
use dom::bindings::iterable::IteratorType;
use dom::bindings::mozmap::MozMap;
use dom::bindings::namespace::NamespaceObjectClass;
use dom::bindings::namespace::create_namespace_object;
use dom::bindings::num::Finite;
use dom::bindings::proxyhandler;
use dom::bindings::proxyhandler::ensure_expando_object;
use dom::bindings::proxyhandler::fill_property_descriptor;
use dom::bindings::proxyhandler::get_expando_object;
use dom::bindings::proxyhandler::get_property_descriptor;
use dom::bindings::reflector::DomObject;
use dom::bindings::reflector::MutDomObject;
use dom::bindings::root::Dom;
use dom::bindings::root::DomRoot;
use dom::bindings::root::OptionalHeapSetter;
use dom::bindings::root::RootedReference;
use dom::bindings::str::ByteString;
use dom::bindings::str::DOMString;
use dom::bindings::str::USVString;
use dom::bindings::trace::JSTraceable;
use dom::bindings::trace::RootedTraceable;
use dom::bindings::trace::RootedTraceableBox;
use dom::bindings::utils::AsVoidPtr;
use dom::bindings::utils::DOMClass;
use dom::bindings::utils::DOMJSClass;
use dom::bindings::utils::DOM_PROTO_UNFORGEABLE_HOLDER_SLOT;
use dom::bindings::utils::JSCLASS_DOM_GLOBAL;
use dom::bindings::utils::ProtoOrIfaceArray;
use dom::bindings::utils::enumerate_global;
use dom::bindings::utils::finalize_global;
use dom::bindings::utils::find_enum_value;
use dom::bindings::utils::generic_getter;
use dom::bindings::utils::generic_lenient_getter;
use dom::bindings::utils::generic_lenient_setter;
use dom::bindings::utils::generic_method;
use dom::bindings::utils::generic_setter;
use dom::bindings::utils::get_array_index_from_id;
use dom::bindings::utils::get_dictionary_property;
use dom::bindings::utils::get_property_on_prototype;
use dom::bindings::utils::get_proto_or_iface_array;
use dom::bindings::utils::has_property_on_prototype;
use dom::bindings::utils::is_platform_object;
use dom::bindings::utils::resolve_global;
use dom::bindings::utils::set_dictionary_property;
use dom::bindings::utils::trace_global;
use dom::bindings::weakref::DOM_WEAK_SLOT;
use dom::bindings::weakref::WeakBox;
use dom::bindings::weakref::WeakReferenceable;
use dom::globalscope::GlobalScope;
use dom::windowproxy::WindowProxy;
use js;
use js::JSCLASS_GLOBAL_SLOT_COUNT;
use js::JSCLASS_IS_DOMJSCLASS;
use js::JSCLASS_IS_GLOBAL;
use js::JSCLASS_RESERVED_SLOTS_MASK;
use js::JS_CALLEE;
use js::error::throw_internal_error;
use js::error::throw_type_error;
use js::glue::AppendToAutoIdVector;
use js::glue::CallJitGetterOp;
use js::glue::CallJitMethodOp;
use js::glue::CallJitSetterOp;
use js::glue::CreateProxyHandler;
use js::glue::GetProxyPrivate;
use js::glue::ProxyTraps;
use js::glue::RUST_JSID_IS_INT;
use js::glue::RUST_JSID_IS_STRING;
use js::glue::RUST_SYMBOL_TO_JSID;
use js::glue::UnwrapObject;
use js::glue::int_to_jsid;
use js::jsapi::AutoIdVector;
use js::jsapi::CallArgs;
use js::jsapi::CurrentGlobalOrNull;
use js::jsapi::FreeOp;
use js::jsapi::GetWellKnownSymbol;
use js::jsapi::Handle as RawHandle;
use js::jsapi::HandleId as RawHandleId;
use js::jsapi::HandleObject as RawHandleObject;
use js::jsapi::HandleValue as RawHandleValue;
use js::jsapi::HandleValueArray;
use js::jsapi::Heap;
use js::jsapi::INTERNED_STRING_TO_JSID;
use js::jsapi::IsCallable;
use js::jsapi::JSAutoCompartment;
use js::jsapi::JSCLASS_RESERVED_SLOTS_SHIFT;
use js::jsapi::JSClass;
use js::jsapi::JSContext;
use js::jsapi::JSFreeOp;
use js::jsapi::JSFunctionSpec;
use js::jsapi::JSITER_HIDDEN;
use js::jsapi::JSITER_OWNONLY;
use js::jsapi::JSITER_SYMBOLS;
use js::jsapi::JSJitGetterCallArgs;
use js::jsapi::JSJitInfo;
use js::jsapi::JSJitInfo_AliasSet;
use js::jsapi::JSJitInfo_ArgType;
use js::jsapi::JSJitInfo_OpType;
use js::jsapi::JSJitMethodCallArgs;
use js::jsapi::JSJitSetterCallArgs;
use js::jsapi::JSNative;
use js::jsapi::JSNativeWrapper;
use js::jsapi::JSObject;
use js::jsapi::JSPROP_ENUMERATE;
use js::jsapi::JSPROP_PERMANENT;
use js::jsapi::JSPROP_READONLY;
use js::jsapi::JSPROP_SHARED;
use js::jsapi::JSPropertySpec;
use js::jsapi::JSString;
use js::jsapi::JSTracer;
use js::jsapi::JSType;
use js::jsapi::JSTypedMethodJitInfo;
use js::jsapi::JSValueType;
use js::jsapi::JS_AtomizeAndPinString;
use js::jsapi::JS_ForwardGetPropertyTo;
use js::jsapi::JS_GetErrorPrototype;
use js::jsapi::JS_GetGlobalForObject;
use js::jsapi::JS_GetIteratorPrototype;
use js::jsapi::JS_GetPropertyById;
use js::jsapi::JS_GetPropertyDescriptorById;
use js::jsapi::JS_GetReservedSlot;
use js::jsapi::JS_HasProperty;
use js::jsapi::JS_HasPropertyById;
use js::jsapi::JS_NewObject;
use js::jsapi::JS_SetReservedSlot;
use js::jsapi::MutableHandle as RawMutableHandle;
use js::jsapi::MutableHandleObject as RawMutableHandleObject;
use js::jsapi::MutableHandleValue as RawMutableHandleValue;
use js::jsapi::ObjectOpResult;
use js::jsapi::PropertyDescriptor;
use js::jsapi::Rooted;
use js::jsapi::RootedId;
use js::jsapi::RootedObject;
use js::jsapi::RootedString;
use js::jsapi::SymbolCode;
use js::jsapi::jsid;
use js::jsval::JSVal;
use js::jsval::NullValue;
use js::jsval::ObjectOrNullValue;
use js::jsval::ObjectValue;
use js::jsval::PrivateValue;
use js::jsval::UndefinedValue;
use js::panic::maybe_resume_unwind;
use js::panic::wrap_panic;
use js::rust::CustomAutoRooterGuard;
use js::rust::GCMethods;
use js::rust::Handle;
use js::rust::HandleId;
use js::rust::HandleObject;
use js::rust::HandleValue;
use js::rust::MutableHandle;
use js::rust::MutableHandleObject;
use js::rust::MutableHandleValue;
use js::rust::define_methods;
use js::rust::define_properties;
use js::rust::get_object_class;
use js::rust::wrappers::Call;
use js::rust::wrappers::GetPropertyKeys;
use js::rust::wrappers::JS_CallFunctionValue;
use js::rust::wrappers::JS_CopyPropertiesFrom;
use js::rust::wrappers::JS_DefineProperty;
use js::rust::wrappers::JS_DefinePropertyById2;
use js::rust::wrappers::JS_GetFunctionPrototype;
use js::rust::wrappers::JS_GetObjectPrototype;
use js::rust::wrappers::JS_GetProperty;
use js::rust::wrappers::JS_InitializePropertiesFromCompatibleNativeObject;
use js::rust::wrappers::JS_NewObjectWithGivenProto;
use js::rust::wrappers::JS_NewObjectWithoutMetadata;
use js::rust::wrappers::JS_ObjectIsDate;
use js::rust::wrappers::JS_SetImmutablePrototype;
use js::rust::wrappers::JS_SetProperty;
use js::rust::wrappers::JS_SetPrototype;
use js::rust::wrappers::JS_SplicePrototype;
use js::rust::wrappers::JS_WrapObject;
use js::rust::wrappers::JS_WrapValue;
use js::rust::wrappers::NewProxyObject;
use js::typedarray;
use libc;
use malloc_size_of::MallocSizeOfOps;
use mem::malloc_size_of_including_raw_self;
use servo_config::prefs::PREFS;
use std::borrow::ToOwned;
use std::cmp;
use std::default::Default;
use std::ffi::CString;
use std::mem;
use std::num;
use std::os;
use std::os::raw::c_void;
use std::panic;
use std::ptr;
use std::ptr::NonNull;
use std::rc;
use std::rc::Rc;
use std::str;
use typeholder::TypeHolderTrait;

pub use self::PaintRenderingContext2DBinding::{Wrap, PaintRenderingContext2DMethods, GetProtoObject, DefineDOMInterface};
pub mod PaintRenderingContext2DBinding {
#![allow(non_camel_case_types,non_upper_case_globals,unused_imports,unused_variables,unused_assignments,unused_mut)]
use dom;
use dom::bindings;
use dom::bindings::callback::CallSetup;
use dom::bindings::callback::CallbackContainer;
use dom::bindings::callback::CallbackFunction;
use dom::bindings::callback::CallbackInterface;
use dom::bindings::callback::CallbackObject;
use dom::bindings::callback::ExceptionHandling;
use dom::bindings::callback::wrap_call_this_object;
use dom::bindings::codegen::Bindings::CanvasRenderingContext2DBinding::CanvasFillRule;
use dom::bindings::codegen::Bindings::CanvasRenderingContext2DBinding::CanvasFillRuleValues;
use dom::bindings::codegen::Bindings::CanvasRenderingContext2DBinding::CanvasLineCap;
use dom::bindings::codegen::Bindings::CanvasRenderingContext2DBinding::CanvasLineCapValues;
use dom::bindings::codegen::Bindings::CanvasRenderingContext2DBinding::CanvasLineJoin;
use dom::bindings::codegen::Bindings::CanvasRenderingContext2DBinding::CanvasLineJoinValues;
use dom::bindings::codegen::Bindings::HTMLElementBinding::HTMLElementBinding;
use dom::bindings::codegen::InterfaceObjectMap;
use dom::bindings::codegen::PrototypeList;
use dom::bindings::codegen::RegisterBindings;
use dom::bindings::codegen::UnionTypes;
use dom::bindings::constant::ConstantSpec;
use dom::bindings::constant::ConstantVal;
use dom::bindings::conversions::ConversionBehavior;
use dom::bindings::conversions::ConversionResult;
use dom::bindings::conversions::DOM_OBJECT_SLOT;
use dom::bindings::conversions::FromJSValConvertible;
use dom::bindings::conversions::IDLInterface;
use dom::bindings::conversions::StringificationBehavior;
use dom::bindings::conversions::ToJSValConvertible;
use dom::bindings::conversions::is_array_like;
use dom::bindings::conversions::jsid_to_string;
use dom::bindings::conversions::native_from_handlevalue;
use dom::bindings::conversions::native_from_object;
use dom::bindings::conversions::private_from_object;
use dom::bindings::conversions::root_from_handleobject;
use dom::bindings::conversions::root_from_handlevalue;
use dom::bindings::conversions::root_from_object;
use dom::bindings::error::Error;
use dom::bindings::error::Error::JSFailed;
use dom::bindings::error::ErrorResult;
use dom::bindings::error::Fallible;
use dom::bindings::error::throw_dom_exception;
use dom::bindings::guard::Condition;
use dom::bindings::guard::Guard;
use dom::bindings::htmlconstructor::html_constructor;
use dom::bindings::htmlconstructor::pop_current_element_queue;
use dom::bindings::htmlconstructor::push_new_element_queue;
use dom::bindings::inheritance::Castable;
use dom::bindings::interface::ConstructorClassHook;
use dom::bindings::interface::InterfaceConstructorBehavior;
use dom::bindings::interface::NonCallbackInterfaceObjectClass;
use dom::bindings::interface::create_callback_interface_object;
use dom::bindings::interface::create_global_object;
use dom::bindings::interface::create_interface_prototype_object;
use dom::bindings::interface::create_named_constructors;
use dom::bindings::interface::create_noncallback_interface_object;
use dom::bindings::interface::define_guarded_constants;
use dom::bindings::interface::define_guarded_methods;
use dom::bindings::interface::define_guarded_properties;
use dom::bindings::interface::is_exposed_in;
use dom::bindings::iterable::Iterable;
use dom::bindings::iterable::IteratorType;
use dom::bindings::mozmap::MozMap;
use dom::bindings::namespace::NamespaceObjectClass;
use dom::bindings::namespace::create_namespace_object;
use dom::bindings::num::Finite;
use dom::bindings::proxyhandler;
use dom::bindings::proxyhandler::ensure_expando_object;
use dom::bindings::proxyhandler::fill_property_descriptor;
use dom::bindings::proxyhandler::get_expando_object;
use dom::bindings::proxyhandler::get_property_descriptor;
use dom::bindings::reflector::DomObject;
use dom::bindings::reflector::MutDomObject;
use dom::bindings::root::Dom;
use dom::bindings::root::DomRoot;
use dom::bindings::root::OptionalHeapSetter;
use dom::bindings::root::RootedReference;
use dom::bindings::str::ByteString;
use dom::bindings::str::DOMString;
use dom::bindings::str::USVString;
use dom::bindings::trace::JSTraceable;
use dom::bindings::trace::RootedTraceable;
use dom::bindings::trace::RootedTraceableBox;
use dom::bindings::utils::AsVoidPtr;
use dom::bindings::utils::DOMClass;
use dom::bindings::utils::DOMJSClass;
use dom::bindings::utils::DOM_PROTO_UNFORGEABLE_HOLDER_SLOT;
use dom::bindings::utils::JSCLASS_DOM_GLOBAL;
use dom::bindings::utils::ProtoOrIfaceArray;
use dom::bindings::utils::enumerate_global;
use dom::bindings::utils::finalize_global;
use dom::bindings::utils::find_enum_value;
use dom::bindings::utils::generic_getter;
use dom::bindings::utils::generic_lenient_getter;
use dom::bindings::utils::generic_lenient_setter;
use dom::bindings::utils::generic_method;
use dom::bindings::utils::generic_setter;
use dom::bindings::utils::get_array_index_from_id;
use dom::bindings::utils::get_dictionary_property;
use dom::bindings::utils::get_property_on_prototype;
use dom::bindings::utils::get_proto_or_iface_array;
use dom::bindings::utils::has_property_on_prototype;
use dom::bindings::utils::is_platform_object;
use dom::bindings::utils::resolve_global;
use dom::bindings::utils::set_dictionary_property;
use dom::bindings::utils::trace_global;
use dom::bindings::weakref::DOM_WEAK_SLOT;
use dom::bindings::weakref::WeakBox;
use dom::bindings::weakref::WeakReferenceable;
use dom::globalscope::GlobalScope;
use dom::types::CSSStyleValue;
use dom::types::CanvasGradient;
use dom::types::CanvasPattern;
use dom::types::CanvasRenderingContext2D;
use dom::types::HTMLCanvasElement;
use dom::types::HTMLElement;
use dom::types::HTMLImageElement;
use dom::types::PaintRenderingContext2D;
use dom::windowproxy::WindowProxy;
use js;
use js::JSCLASS_GLOBAL_SLOT_COUNT;
use js::JSCLASS_IS_DOMJSCLASS;
use js::JSCLASS_IS_GLOBAL;
use js::JSCLASS_RESERVED_SLOTS_MASK;
use js::JS_CALLEE;
use js::error::throw_internal_error;
use js::error::throw_type_error;
use js::glue::AppendToAutoIdVector;
use js::glue::CallJitGetterOp;
use js::glue::CallJitMethodOp;
use js::glue::CallJitSetterOp;
use js::glue::CreateProxyHandler;
use js::glue::GetProxyPrivate;
use js::glue::ProxyTraps;
use js::glue::RUST_JSID_IS_INT;
use js::glue::RUST_JSID_IS_STRING;
use js::glue::RUST_SYMBOL_TO_JSID;
use js::glue::UnwrapObject;
use js::glue::int_to_jsid;
use js::jsapi::AutoIdVector;
use js::jsapi::CallArgs;
use js::jsapi::CurrentGlobalOrNull;
use js::jsapi::FreeOp;
use js::jsapi::GetWellKnownSymbol;
use js::jsapi::Handle as RawHandle;
use js::jsapi::HandleId as RawHandleId;
use js::jsapi::HandleObject as RawHandleObject;
use js::jsapi::HandleValue as RawHandleValue;
use js::jsapi::HandleValueArray;
use js::jsapi::Heap;
use js::jsapi::INTERNED_STRING_TO_JSID;
use js::jsapi::IsCallable;
use js::jsapi::JSAutoCompartment;
use js::jsapi::JSCLASS_RESERVED_SLOTS_SHIFT;
use js::jsapi::JSClass;
use js::jsapi::JSContext;
use js::jsapi::JSFreeOp;
use js::jsapi::JSFunctionSpec;
use js::jsapi::JSITER_HIDDEN;
use js::jsapi::JSITER_OWNONLY;
use js::jsapi::JSITER_SYMBOLS;
use js::jsapi::JSJitGetterCallArgs;
use js::jsapi::JSJitInfo;
use js::jsapi::JSJitInfo_AliasSet;
use js::jsapi::JSJitInfo_ArgType;
use js::jsapi::JSJitInfo_OpType;
use js::jsapi::JSJitMethodCallArgs;
use js::jsapi::JSJitSetterCallArgs;
use js::jsapi::JSNative;
use js::jsapi::JSNativeWrapper;
use js::jsapi::JSObject;
use js::jsapi::JSPROP_ENUMERATE;
use js::jsapi::JSPROP_PERMANENT;
use js::jsapi::JSPROP_READONLY;
use js::jsapi::JSPROP_SHARED;
use js::jsapi::JSPropertySpec;
use js::jsapi::JSString;
use js::jsapi::JSTracer;
use js::jsapi::JSType;
use js::jsapi::JSTypedMethodJitInfo;
use js::jsapi::JSValueType;
use js::jsapi::JS_AtomizeAndPinString;
use js::jsapi::JS_ForwardGetPropertyTo;
use js::jsapi::JS_GetErrorPrototype;
use js::jsapi::JS_GetGlobalForObject;
use js::jsapi::JS_GetIteratorPrototype;
use js::jsapi::JS_GetPropertyById;
use js::jsapi::JS_GetPropertyDescriptorById;
use js::jsapi::JS_GetReservedSlot;
use js::jsapi::JS_HasProperty;
use js::jsapi::JS_HasPropertyById;
use js::jsapi::JS_NewObject;
use js::jsapi::JS_SetReservedSlot;
use js::jsapi::MutableHandle as RawMutableHandle;
use js::jsapi::MutableHandleObject as RawMutableHandleObject;
use js::jsapi::MutableHandleValue as RawMutableHandleValue;
use js::jsapi::ObjectOpResult;
use js::jsapi::PropertyDescriptor;
use js::jsapi::Rooted;
use js::jsapi::RootedId;
use js::jsapi::RootedObject;
use js::jsapi::RootedString;
use js::jsapi::SymbolCode;
use js::jsapi::jsid;
use js::jsval::JSVal;
use js::jsval::NullValue;
use js::jsval::ObjectOrNullValue;
use js::jsval::ObjectValue;
use js::jsval::PrivateValue;
use js::jsval::UndefinedValue;
use js::panic::maybe_resume_unwind;
use js::panic::wrap_panic;
use js::rust::CustomAutoRooterGuard;
use js::rust::GCMethods;
use js::rust::Handle;
use js::rust::HandleId;
use js::rust::HandleObject;
use js::rust::HandleValue;
use js::rust::MutableHandle;
use js::rust::MutableHandleObject;
use js::rust::MutableHandleValue;
use js::rust::define_methods;
use js::rust::define_properties;
use js::rust::get_object_class;
use js::rust::wrappers::Call;
use js::rust::wrappers::GetPropertyKeys;
use js::rust::wrappers::JS_CallFunctionValue;
use js::rust::wrappers::JS_CopyPropertiesFrom;
use js::rust::wrappers::JS_DefineProperty;
use js::rust::wrappers::JS_DefinePropertyById2;
use js::rust::wrappers::JS_GetFunctionPrototype;
use js::rust::wrappers::JS_GetObjectPrototype;
use js::rust::wrappers::JS_GetProperty;
use js::rust::wrappers::JS_InitializePropertiesFromCompatibleNativeObject;
use js::rust::wrappers::JS_NewObjectWithGivenProto;
use js::rust::wrappers::JS_NewObjectWithoutMetadata;
use js::rust::wrappers::JS_ObjectIsDate;
use js::rust::wrappers::JS_SetImmutablePrototype;
use js::rust::wrappers::JS_SetProperty;
use js::rust::wrappers::JS_SetPrototype;
use js::rust::wrappers::JS_SplicePrototype;
use js::rust::wrappers::JS_WrapObject;
use js::rust::wrappers::JS_WrapValue;
use js::rust::wrappers::NewProxyObject;
use js::typedarray;
use libc;
use malloc_size_of::MallocSizeOfOps;
use mem::malloc_size_of_including_raw_self;
use servo_config::prefs::PREFS;
use std::borrow::ToOwned;
use std::cmp;
use std::default::Default;
use std::ffi::CString;
use std::mem;
use std::num;
use std::os;
use std::os::raw::c_void;
use std::panic;
use std::ptr;
use std::ptr::NonNull;
use std::rc;
use std::rc::Rc;
use std::str;
use typeholder::TypeHolderTrait;

unsafe extern fn get_globalAlpha<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.GlobalAlpha();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_globalAlpha<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetGlobalAlpha(arg0);

        return true;
    }), false);
}


const globalAlpha_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const globalAlpha_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_globalCompositeOperation<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DOMString = this.GlobalCompositeOperation();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_globalCompositeOperation<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetGlobalCompositeOperation(arg0);

        return true;
    }), false);
}


const globalCompositeOperation_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const globalCompositeOperation_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn drawImage<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        let argcount = cmp::min(argc, 9);
        match argcount {
            3 => {
                let arg0: UnionTypes::HTMLImageElementOrHTMLCanvasElementOrCanvasRenderingContext2DOrCSSStyleValue<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                    Ok(ConversionResult::Success(value)) => value,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                let arg1: f64 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg2: f64 = match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let result: Result<(), Error<TH>> = this.DrawImage(arg0, arg1, arg2);
                let result = match result {
                    Ok(result) => result,
                    Err(e) => {
                        throw_dom_exception(cx, &this.global(), e);
                        return false;
                    },
                };

                (result).to_jsval(cx, args.rval());
                return true;
            }
            5 => {
                let arg0: UnionTypes::HTMLImageElementOrHTMLCanvasElementOrCanvasRenderingContext2DOrCSSStyleValue<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                    Ok(ConversionResult::Success(value)) => value,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                let arg1: f64 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg2: f64 = match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg3: f64 = match FromJSValConvertible::from_jsval(cx, args.get(3), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg4: f64 = match FromJSValConvertible::from_jsval(cx, args.get(4), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let result: Result<(), Error<TH>> = this.DrawImage_(arg0, arg1, arg2, arg3, arg4);
                let result = match result {
                    Ok(result) => result,
                    Err(e) => {
                        throw_dom_exception(cx, &this.global(), e);
                        return false;
                    },
                };

                (result).to_jsval(cx, args.rval());
                return true;
            }
            9 => {
                let arg0: UnionTypes::HTMLImageElementOrHTMLCanvasElementOrCanvasRenderingContext2DOrCSSStyleValue<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                    Ok(ConversionResult::Success(value)) => value,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                let arg1: f64 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg2: f64 = match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg3: f64 = match FromJSValConvertible::from_jsval(cx, args.get(3), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg4: f64 = match FromJSValConvertible::from_jsval(cx, args.get(4), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg5: f64 = match FromJSValConvertible::from_jsval(cx, args.get(5), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg6: f64 = match FromJSValConvertible::from_jsval(cx, args.get(6), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg7: f64 = match FromJSValConvertible::from_jsval(cx, args.get(7), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg8: f64 = match FromJSValConvertible::from_jsval(cx, args.get(8), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let result: Result<(), Error<TH>> = this.DrawImage__(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
                let result = match result {
                    Ok(result) => result,
                    Err(e) => {
                        throw_dom_exception(cx, &this.global(), e);
                        return false;
                    },
                };

                (result).to_jsval(cx, args.rval());
                return true;
            }
            _ => {
                throw_type_error(cx, "Not enough arguments to \"PaintRenderingContext2D.drawImage\".");
                return false;
            }
        }
    }), false);
}


const drawImage_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn beginPath<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.BeginPath();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const beginPath_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn fill<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: CanvasFillRule = if args.get(0).is_undefined() {
            CanvasFillRule::Nonzero
        } else {
            match find_enum_value(cx, args.get(0), CanvasFillRuleValues::pairs) {
                Err(_) => { return false;
             },
                Ok((None, search)) => { throw_type_error(cx, &format!("'{}' is not a valid enum value for enumeration 'CanvasFillRule'.", search)); return false;
             },
                Ok((Some(&value), _)) => value,
            }
        };
        let result: () = this.Fill(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const fill_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn stroke<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.Stroke();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const stroke_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn clip<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: CanvasFillRule = if args.get(0).is_undefined() {
            CanvasFillRule::Nonzero
        } else {
            match find_enum_value(cx, args.get(0), CanvasFillRuleValues::pairs) {
                Err(_) => { return false;
             },
                Ok((None, search)) => { throw_type_error(cx, &format!("'{}' is not a valid enum value for enumeration 'CanvasFillRule'.", search)); return false;
             },
                Ok((Some(&value), _)) => value,
            }
        };
        let result: () = this.Clip(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const clip_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn isPointInPath<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"PaintRenderingContext2D.isPointInPath\".");
            return false;
        }
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: f64 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: CanvasFillRule = if args.get(2).is_undefined() {
            CanvasFillRule::Nonzero
        } else {
            match find_enum_value(cx, args.get(2), CanvasFillRuleValues::pairs) {
                Err(_) => { return false;
             },
                Ok((None, search)) => { throw_type_error(cx, &format!("'{}' is not a valid enum value for enumeration 'CanvasFillRule'.", search)); return false;
             },
                Ok((Some(&value), _)) => value,
            }
        };
        let result: bool = this.IsPointInPath(arg0, arg1, arg2);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const isPointInPath_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_BOOLEAN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_strokeStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: UnionTypes::StringOrCanvasGradientOrCanvasPattern<TH> = this.StrokeStyle();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_strokeStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: UnionTypes::StringOrCanvasGradientOrCanvasPattern<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetStrokeStyle(arg0);

        return true;
    }), false);
}


const strokeStyle_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const strokeStyle_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_fillStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: UnionTypes::StringOrCanvasGradientOrCanvasPattern<TH> = this.FillStyle();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_fillStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: UnionTypes::StringOrCanvasGradientOrCanvasPattern<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetFillStyle(arg0);

        return true;
    }), false);
}


const fillStyle_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const fillStyle_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn createLinearGradient<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 4 {
            throw_type_error(cx, "Not enough arguments to \"PaintRenderingContext2D.createLinearGradient\".");
            return false;
        }
        let arg0: Finite<f64> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: Finite<f64> = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: Finite<f64> = match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: Finite<f64> = match FromJSValConvertible::from_jsval(cx, args.get(3), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: DomRoot<CanvasGradient<TH>> = this.CreateLinearGradient(arg0, arg1, arg2, arg3);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const createLinearGradient_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn createRadialGradient<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 6 {
            throw_type_error(cx, "Not enough arguments to \"PaintRenderingContext2D.createRadialGradient\".");
            return false;
        }
        let arg0: Finite<f64> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: Finite<f64> = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: Finite<f64> = match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: Finite<f64> = match FromJSValConvertible::from_jsval(cx, args.get(3), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg4: Finite<f64> = match FromJSValConvertible::from_jsval(cx, args.get(4), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg5: Finite<f64> = match FromJSValConvertible::from_jsval(cx, args.get(5), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: Result<DomRoot<CanvasGradient<TH>>, Error<TH>> = this.CreateRadialGradient(arg0, arg1, arg2, arg3, arg4, arg5);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const createRadialGradient_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn createPattern<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"PaintRenderingContext2D.createPattern\".");
            return false;
        }
        let arg0: UnionTypes::HTMLImageElementOrHTMLCanvasElementOrCanvasRenderingContext2DOrCSSStyleValue<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let arg1: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(1), StringificationBehavior::Empty) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: Result<DomRoot<CanvasPattern<TH>>, Error<TH>> = this.CreatePattern(arg0, arg1);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const createPattern_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_imageSmoothingEnabled<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: bool = this.ImageSmoothingEnabled();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_imageSmoothingEnabled<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: bool = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetImageSmoothingEnabled(arg0);

        return true;
    }), false);
}


const imageSmoothingEnabled_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_BOOLEAN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const imageSmoothingEnabled_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn closePath<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.ClosePath();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const closePath_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn moveTo<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"PaintRenderingContext2D.moveTo\".");
            return false;
        }
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: f64 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.MoveTo(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const moveTo_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn lineTo<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"PaintRenderingContext2D.lineTo\".");
            return false;
        }
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: f64 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.LineTo(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const lineTo_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn quadraticCurveTo<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 4 {
            throw_type_error(cx, "Not enough arguments to \"PaintRenderingContext2D.quadraticCurveTo\".");
            return false;
        }
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: f64 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: f64 = match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: f64 = match FromJSValConvertible::from_jsval(cx, args.get(3), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.QuadraticCurveTo(arg0, arg1, arg2, arg3);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const quadraticCurveTo_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn bezierCurveTo<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 6 {
            throw_type_error(cx, "Not enough arguments to \"PaintRenderingContext2D.bezierCurveTo\".");
            return false;
        }
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: f64 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: f64 = match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: f64 = match FromJSValConvertible::from_jsval(cx, args.get(3), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg4: f64 = match FromJSValConvertible::from_jsval(cx, args.get(4), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg5: f64 = match FromJSValConvertible::from_jsval(cx, args.get(5), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.BezierCurveTo(arg0, arg1, arg2, arg3, arg4, arg5);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const bezierCurveTo_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn arcTo<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 5 {
            throw_type_error(cx, "Not enough arguments to \"PaintRenderingContext2D.arcTo\".");
            return false;
        }
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: f64 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: f64 = match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: f64 = match FromJSValConvertible::from_jsval(cx, args.get(3), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg4: f64 = match FromJSValConvertible::from_jsval(cx, args.get(4), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: Result<(), Error<TH>> = this.ArcTo(arg0, arg1, arg2, arg3, arg4);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const arcTo_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn rect<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 4 {
            throw_type_error(cx, "Not enough arguments to \"PaintRenderingContext2D.rect\".");
            return false;
        }
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: f64 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: f64 = match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: f64 = match FromJSValConvertible::from_jsval(cx, args.get(3), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.Rect(arg0, arg1, arg2, arg3);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const rect_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn arc<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 5 {
            throw_type_error(cx, "Not enough arguments to \"PaintRenderingContext2D.arc\".");
            return false;
        }
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: f64 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: f64 = match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: f64 = match FromJSValConvertible::from_jsval(cx, args.get(3), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg4: f64 = match FromJSValConvertible::from_jsval(cx, args.get(4), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg5: bool = if args.get(5).is_undefined() {
            false
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(5), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: Result<(), Error<TH>> = this.Arc(arg0, arg1, arg2, arg3, arg4, arg5);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const arc_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn ellipse<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 7 {
            throw_type_error(cx, "Not enough arguments to \"PaintRenderingContext2D.ellipse\".");
            return false;
        }
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: f64 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: f64 = match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: f64 = match FromJSValConvertible::from_jsval(cx, args.get(3), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg4: f64 = match FromJSValConvertible::from_jsval(cx, args.get(4), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg5: f64 = match FromJSValConvertible::from_jsval(cx, args.get(5), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg6: f64 = match FromJSValConvertible::from_jsval(cx, args.get(6), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg7: bool = if args.get(7).is_undefined() {
            false
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(7), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: Result<(), Error<TH>> = this.Ellipse(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const ellipse_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_lineWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.LineWidth();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_lineWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetLineWidth(arg0);

        return true;
    }), false);
}


const lineWidth_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const lineWidth_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_lineCap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: CanvasLineCap = this.LineCap();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_lineCap<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: CanvasLineCap = match find_enum_value(cx, args.get(0), CanvasLineCapValues::pairs) {
            Err(_) => { return false;
         },
            Ok((None, search)) => { return true; },
            Ok((Some(&value), _)) => value,
        };
        let result: () = this.SetLineCap(arg0);

        return true;
    }), false);
}


const lineCap_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const lineCap_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_lineJoin<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: CanvasLineJoin = this.LineJoin();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_lineJoin<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: CanvasLineJoin = match find_enum_value(cx, args.get(0), CanvasLineJoinValues::pairs) {
            Err(_) => { return false;
         },
            Ok((None, search)) => { return true; },
            Ok((Some(&value), _)) => value,
        };
        let result: () = this.SetLineJoin(arg0);

        return true;
    }), false);
}


const lineJoin_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const lineJoin_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_miterLimit<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.MiterLimit();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_miterLimit<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetMiterLimit(arg0);

        return true;
    }), false);
}


const miterLimit_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const miterLimit_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn clearRect<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 4 {
            throw_type_error(cx, "Not enough arguments to \"PaintRenderingContext2D.clearRect\".");
            return false;
        }
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: f64 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: f64 = match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: f64 = match FromJSValConvertible::from_jsval(cx, args.get(3), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.ClearRect(arg0, arg1, arg2, arg3);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const clearRect_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn fillRect<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 4 {
            throw_type_error(cx, "Not enough arguments to \"PaintRenderingContext2D.fillRect\".");
            return false;
        }
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: f64 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: f64 = match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: f64 = match FromJSValConvertible::from_jsval(cx, args.get(3), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.FillRect(arg0, arg1, arg2, arg3);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const fillRect_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn strokeRect<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 4 {
            throw_type_error(cx, "Not enough arguments to \"PaintRenderingContext2D.strokeRect\".");
            return false;
        }
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: f64 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: f64 = match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: f64 = match FromJSValConvertible::from_jsval(cx, args.get(3), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.StrokeRect(arg0, arg1, arg2, arg3);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const strokeRect_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_shadowOffsetX<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.ShadowOffsetX();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_shadowOffsetX<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetShadowOffsetX(arg0);

        return true;
    }), false);
}


const shadowOffsetX_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const shadowOffsetX_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_shadowOffsetY<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.ShadowOffsetY();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_shadowOffsetY<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetShadowOffsetY(arg0);

        return true;
    }), false);
}


const shadowOffsetY_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const shadowOffsetY_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_shadowBlur<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.ShadowBlur();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_shadowBlur<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetShadowBlur(arg0);

        return true;
    }), false);
}


const shadowBlur_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const shadowBlur_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_shadowColor<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DOMString = this.ShadowColor();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_shadowColor<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetShadowColor(arg0);

        return true;
    }), false);
}


const shadowColor_getterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const shadowColor_setterinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn save<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.Save();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const save_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn restore<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.Restore();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const restore_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn scale<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"PaintRenderingContext2D.scale\".");
            return false;
        }
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: f64 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.Scale(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const scale_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn rotate<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"PaintRenderingContext2D.rotate\".");
            return false;
        }
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.Rotate(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const rotate_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn translate<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"PaintRenderingContext2D.translate\".");
            return false;
        }
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: f64 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.Translate(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const translate_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn transform<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 6 {
            throw_type_error(cx, "Not enough arguments to \"PaintRenderingContext2D.transform\".");
            return false;
        }
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: f64 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: f64 = match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: f64 = match FromJSValConvertible::from_jsval(cx, args.get(3), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg4: f64 = match FromJSValConvertible::from_jsval(cx, args.get(4), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg5: f64 = match FromJSValConvertible::from_jsval(cx, args.get(5), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.Transform(arg0, arg1, arg2, arg3, arg4, arg5);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const transform_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn setTransform<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 6 {
            throw_type_error(cx, "Not enough arguments to \"PaintRenderingContext2D.setTransform\".");
            return false;
        }
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: f64 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: f64 = match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: f64 = match FromJSValConvertible::from_jsval(cx, args.get(3), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg4: f64 = match FromJSValConvertible::from_jsval(cx, args.get(4), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg5: f64 = match FromJSValConvertible::from_jsval(cx, args.get(5), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetTransform(arg0, arg1, arg2, arg3, arg4, arg5);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const setTransform_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn resetTransform<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const PaintRenderingContext2D<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.ResetTransform();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const resetTransform_methodinfo: JSJitInfo = JSJitInfo {
        call: 0 as *const os::raw::c_void,
    protoID: PrototypeList::ID::PaintRenderingContext2D as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn FOO_finalize(_fop: *mut JSFreeOp, obj: *mut JSObject) {
	unimplemented!();
}

unsafe extern fn _finalize<TH: TypeHolderTrait>
(_fop: *mut JSFreeOp, obj: *mut JSObject) {
    return wrap_panic(panic::AssertUnwindSafe(|| {

        let this = native_from_object::<PaintRenderingContext2D<TH>>(obj).unwrap();
            if !this.is_null() {
                // The pointer can be null if the object is the unforgeable holder of that interface.
                let _ = Box::from_raw(this as *mut PaintRenderingContext2D<TH>);
            }
            debug!("PaintRenderingContext2D<TH> finalize: {:p}", this);
    }), ());
}

unsafe extern fn FOO_trace(trc: *mut JSTracer, obj: *mut JSObject) {
	unimplemented!();
}

unsafe extern fn _trace<TH: TypeHolderTrait>
(trc: *mut JSTracer, obj: *mut JSObject) {
    return wrap_panic(panic::AssertUnwindSafe(|| {

        let this = native_from_object::<PaintRenderingContext2D<TH>>(obj).unwrap();
        if this.is_null() { return; } // GC during obj creation
        (*this).trace(trc);
    }), ());
}

static CLASS_OPS: js::jsapi::JSClassOps = js::jsapi::JSClassOps {
    addProperty: None,
    delProperty: None,
    getProperty: None,
    setProperty: None,
    enumerate: None,
    resolve: None,
    mayResolve: None,
    finalize: Some(FOO_finalize),
    call: None,
    hasInstance: None,
    construct: None,
    trace: Some(FOO_trace),
};

pub unsafe fn FOO_malloc_size_of(
    ops: &mut MallocSizeOfOps, obj: *const c_void) -> usize {
	unimplemented!()
}

static Class: DOMJSClass = DOMJSClass {
    base: js::jsapi::JSClass {
        name: b"PaintRenderingContext2D\0" as *const u8 as *const libc::c_char,
        flags: JSCLASS_IS_DOMJSCLASS | 0 |
               (((1) & JSCLASS_RESERVED_SLOTS_MASK) << JSCLASS_RESERVED_SLOTS_SHIFT)
               /* JSCLASS_HAS_RESERVED_SLOTS(1) */,
        cOps: &CLASS_OPS,
        reserved: [0 as *mut _; 3],
    },
    dom_class: DOMClass {
    interface_chain: [ PrototypeList::ID::PaintRenderingContext2D, PrototypeList::ID::Last, PrototypeList::ID::Last, PrototypeList::ID::Last, PrototypeList::ID::Last, PrototypeList::ID::Last ],
    type_id: ::dom::bindings::codegen::InheritTypes::TopTypeId { alone: () },
    global: InterfaceObjectMap::Globals::EMPTY,
   	malloc_size_of: FOO_malloc_size_of as unsafe fn(&mut _, _) -> _,
}
};



pub unsafe fn Wrap<TH: TypeHolderTrait>
(cx: *mut JSContext, scope: &GlobalScope<TH>, object: Box<PaintRenderingContext2D<TH>>) -> DomRoot<PaintRenderingContext2D<TH>> {
    let scope = scope.reflector().get_jsobject();
    assert!(!scope.get().is_null());
    assert!(((*get_object_class(scope.get())).flags & JSCLASS_IS_GLOBAL) != 0);

    rooted!(in(cx) let mut proto = ptr::null_mut::<JSObject>());
    let _ac = JSAutoCompartment::new(cx, scope.get());
    GetProtoObject::<TH>(cx, scope, proto.handle_mut());
    assert!(!proto.is_null());

    let raw = Box::into_raw(object);
    let _rt = RootedTraceable::new(&*raw);
    rooted!(in(cx) let obj = JS_NewObjectWithGivenProto(
        cx, &Class.base as *const JSClass, proto.handle()));
    assert!(!obj.is_null());

    JS_SetReservedSlot(obj.get(), DOM_OBJECT_SLOT,
                       PrivateValue(raw as *const libc::c_void));


    (*raw).init_reflector(obj.get());

    DomRoot::from_ref(&*raw)
}

impl<TH: TypeHolderTrait> IDLInterface for PaintRenderingContext2D<TH> {
    #[inline]
    fn derives(class: &'static DOMClass) -> bool {
        class as *const _ == &Class.dom_class as *const _
    }
}

impl<TH: TypeHolderTrait> PartialEq for PaintRenderingContext2D<TH> {
    fn eq(&self, other: &PaintRenderingContext2D<TH>) -> bool {
        self as *const PaintRenderingContext2D<TH> == &*other
    }
}

pub trait PaintRenderingContext2DMethods<TH: TypeHolderTrait> {
    fn GlobalAlpha(&self) -> f64;
    fn SetGlobalAlpha(&self, value: f64) -> ();
    fn GlobalCompositeOperation(&self) -> DOMString;
    fn SetGlobalCompositeOperation(&self, value: DOMString) -> ();
    fn DrawImage(&self, image: UnionTypes::HTMLImageElementOrHTMLCanvasElementOrCanvasRenderingContext2DOrCSSStyleValue<TH>, dx: f64, dy: f64) -> Fallible<(), TH>;
    fn DrawImage_(&self, image: UnionTypes::HTMLImageElementOrHTMLCanvasElementOrCanvasRenderingContext2DOrCSSStyleValue<TH>, dx: f64, dy: f64, dw: f64, dh: f64) -> Fallible<(), TH>;
    fn DrawImage__(&self, image: UnionTypes::HTMLImageElementOrHTMLCanvasElementOrCanvasRenderingContext2DOrCSSStyleValue<TH>, sx: f64, sy: f64, sw: f64, sh: f64, dx: f64, dy: f64, dw: f64, dh: f64) -> Fallible<(), TH>;
    fn BeginPath(&self) -> ();
    fn Fill(&self, fillRule: CanvasFillRule) -> ();
    fn Stroke(&self) -> ();
    fn Clip(&self, fillRule: CanvasFillRule) -> ();
    fn IsPointInPath(&self, x: f64, y: f64, fillRule: CanvasFillRule) -> bool;
    fn StrokeStyle(&self) -> UnionTypes::StringOrCanvasGradientOrCanvasPattern<TH>;
    fn SetStrokeStyle(&self, value: UnionTypes::StringOrCanvasGradientOrCanvasPattern<TH>) -> ();
    fn FillStyle(&self) -> UnionTypes::StringOrCanvasGradientOrCanvasPattern<TH>;
    fn SetFillStyle(&self, value: UnionTypes::StringOrCanvasGradientOrCanvasPattern<TH>) -> ();
    fn CreateLinearGradient(&self, x0: Finite<f64>, y0: Finite<f64>, x1: Finite<f64>, y1: Finite<f64>) -> DomRoot<CanvasGradient<TH>>;
    fn CreateRadialGradient(&self, x0: Finite<f64>, y0: Finite<f64>, r0: Finite<f64>, x1: Finite<f64>, y1: Finite<f64>, r1: Finite<f64>) -> Fallible<DomRoot<CanvasGradient<TH>>, TH>;
    fn CreatePattern(&self, image: UnionTypes::HTMLImageElementOrHTMLCanvasElementOrCanvasRenderingContext2DOrCSSStyleValue<TH>, repetition: DOMString) -> Fallible<DomRoot<CanvasPattern<TH>>, TH>;
    fn ImageSmoothingEnabled(&self) -> bool;
    fn SetImageSmoothingEnabled(&self, value: bool) -> ();
    fn ClosePath(&self) -> ();
    fn MoveTo(&self, x: f64, y: f64) -> ();
    fn LineTo(&self, x: f64, y: f64) -> ();
    fn QuadraticCurveTo(&self, cpx: f64, cpy: f64, x: f64, y: f64) -> ();
    fn BezierCurveTo(&self, cp1x: f64, cp1y: f64, cp2x: f64, cp2y: f64, x: f64, y: f64) -> ();
    fn ArcTo(&self, x1: f64, y1: f64, x2: f64, y2: f64, radius: f64) -> Fallible<(), TH>;
    fn Rect(&self, x: f64, y: f64, w: f64, h: f64) -> ();
    fn Arc(&self, x: f64, y: f64, radius: f64, startAngle: f64, endAngle: f64, anticlockwise: bool) -> Fallible<(), TH>;
    fn Ellipse(&self, x: f64, y: f64, radius_x: f64, radius_y: f64, rotation: f64, startAngle: f64, endAngle: f64, anticlockwise: bool) -> Fallible<(), TH>;
    fn LineWidth(&self) -> f64;
    fn SetLineWidth(&self, value: f64) -> ();
    fn LineCap(&self) -> CanvasLineCap;
    fn SetLineCap(&self, value: CanvasLineCap) -> ();
    fn LineJoin(&self) -> CanvasLineJoin;
    fn SetLineJoin(&self, value: CanvasLineJoin) -> ();
    fn MiterLimit(&self) -> f64;
    fn SetMiterLimit(&self, value: f64) -> ();
    fn ClearRect(&self, x: f64, y: f64, w: f64, h: f64) -> ();
    fn FillRect(&self, x: f64, y: f64, w: f64, h: f64) -> ();
    fn StrokeRect(&self, x: f64, y: f64, w: f64, h: f64) -> ();
    fn ShadowOffsetX(&self) -> f64;
    fn SetShadowOffsetX(&self, value: f64) -> ();
    fn ShadowOffsetY(&self) -> f64;
    fn SetShadowOffsetY(&self, value: f64) -> ();
    fn ShadowBlur(&self) -> f64;
    fn SetShadowBlur(&self, value: f64) -> ();
    fn ShadowColor(&self) -> DOMString;
    fn SetShadowColor(&self, value: DOMString) -> ();
    fn Save(&self) -> ();
    fn Restore(&self) -> ();
    fn Scale(&self, x: f64, y: f64) -> ();
    fn Rotate(&self, angle: f64) -> ();
    fn Translate(&self, x: f64, y: f64) -> ();
    fn Transform(&self, a: f64, b: f64, c: f64, d: f64, e: f64, f: f64) -> ();
    fn SetTransform(&self, a: f64, b: f64, c: f64, d: f64, e: f64, f: f64) -> ();
    fn ResetTransform(&self) -> ();
}
const sMethods_specs: &'static [&'static[JSFunctionSpec]] = &[
&[
    JSFunctionSpec {
        name: b"drawImage\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &drawImage_methodinfo as *const _ as *const JSJitInfo },
        nargs: 3,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"beginPath\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &beginPath_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"fill\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &fill_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"stroke\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &stroke_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"clip\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &clip_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"isPointInPath\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &isPointInPath_methodinfo as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"createLinearGradient\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &createLinearGradient_methodinfo as *const _ as *const JSJitInfo },
        nargs: 4,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"createRadialGradient\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &createRadialGradient_methodinfo as *const _ as *const JSJitInfo },
        nargs: 6,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"createPattern\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &createPattern_methodinfo as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"closePath\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &closePath_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"moveTo\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &moveTo_methodinfo as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"lineTo\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &lineTo_methodinfo as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"quadraticCurveTo\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &quadraticCurveTo_methodinfo as *const _ as *const JSJitInfo },
        nargs: 4,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"bezierCurveTo\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &bezierCurveTo_methodinfo as *const _ as *const JSJitInfo },
        nargs: 6,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"arcTo\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &arcTo_methodinfo as *const _ as *const JSJitInfo },
        nargs: 5,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"rect\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &rect_methodinfo as *const _ as *const JSJitInfo },
        nargs: 4,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"arc\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &arc_methodinfo as *const _ as *const JSJitInfo },
        nargs: 5,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"ellipse\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &ellipse_methodinfo as *const _ as *const JSJitInfo },
        nargs: 7,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"clearRect\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &clearRect_methodinfo as *const _ as *const JSJitInfo },
        nargs: 4,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"fillRect\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &fillRect_methodinfo as *const _ as *const JSJitInfo },
        nargs: 4,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"strokeRect\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &strokeRect_methodinfo as *const _ as *const JSJitInfo },
        nargs: 4,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"save\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &save_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"restore\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &restore_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"scale\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &scale_methodinfo as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"rotate\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &rotate_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"translate\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &translate_methodinfo as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"transform\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &transform_methodinfo as *const _ as *const JSJitInfo },
        nargs: 6,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"setTransform\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &setTransform_methodinfo as *const _ as *const JSJitInfo },
        nargs: 6,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"resetTransform\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &resetTransform_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]

];
const sMethods: &'static [Guard<&'static [JSFunctionSpec]>] = &[
    Guard::new(Condition::Satisfied, sMethods_specs[0])
];
const sAttributes_specs: &'static [&'static[JSPropertySpec]] = &[
&[
    JSPropertySpec {
        name: b"globalAlpha\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &globalAlpha_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &globalAlpha_setterinfo }
    },
    JSPropertySpec {
        name: b"globalCompositeOperation\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &globalCompositeOperation_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &globalCompositeOperation_setterinfo }
    },
    JSPropertySpec {
        name: b"strokeStyle\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &strokeStyle_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &strokeStyle_setterinfo }
    },
    JSPropertySpec {
        name: b"fillStyle\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &fillStyle_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &fillStyle_setterinfo }
    },
    JSPropertySpec {
        name: b"imageSmoothingEnabled\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &imageSmoothingEnabled_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &imageSmoothingEnabled_setterinfo }
    },
    JSPropertySpec {
        name: b"lineWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &lineWidth_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &lineWidth_setterinfo }
    },
    JSPropertySpec {
        name: b"lineCap\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &lineCap_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &lineCap_setterinfo }
    },
    JSPropertySpec {
        name: b"lineJoin\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &lineJoin_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &lineJoin_setterinfo }
    },
    JSPropertySpec {
        name: b"miterLimit\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &miterLimit_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &miterLimit_setterinfo }
    },
    JSPropertySpec {
        name: b"shadowOffsetX\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &shadowOffsetX_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &shadowOffsetX_setterinfo }
    },
    JSPropertySpec {
        name: b"shadowOffsetY\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &shadowOffsetY_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &shadowOffsetY_setterinfo }
    },
    JSPropertySpec {
        name: b"shadowBlur\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &shadowBlur_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &shadowBlur_setterinfo }
    },
    JSPropertySpec {
        name: b"shadowColor\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &shadowColor_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &shadowColor_setterinfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]

];
const sAttributes: &'static [Guard<&'static [JSPropertySpec]>] = &[
    Guard::new(Condition::Satisfied, sAttributes_specs[0])
];

pub unsafe fn GetProtoObject<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject, mut rval: MutableHandleObject) {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    assert!(((*get_object_class(global.get())).flags & JSCLASS_DOM_GLOBAL) != 0);

    /* Check to see whether the interface objects are already installed */
    let proto_or_iface_array = get_proto_or_iface_array(global.get());
    rval.set((*proto_or_iface_array)[PrototypeList::ID::PaintRenderingContext2D as usize]);
    if !rval.get().is_null() {
        return;
    }

    CreateInterfaceObjects::<TH>(cx, global, proto_or_iface_array);
    rval.set((*proto_or_iface_array)[PrototypeList::ID::PaintRenderingContext2D as usize]);
    assert!(!rval.get().is_null());

}

static PrototypeClass: JSClass = JSClass {
    name: b"PaintRenderingContext2DPrototype\0" as *const u8 as *const libc::c_char,
    flags:
        // JSCLASS_HAS_RESERVED_SLOTS(0)
        (0 & JSCLASS_RESERVED_SLOTS_MASK) << JSCLASS_RESERVED_SLOTS_SHIFT,
    cOps: 0 as *const _,
    reserved: [0 as *mut os::raw::c_void; 3]
};

static INTERFACE_OBJECT_CLASS: NonCallbackInterfaceObjectClass =
    NonCallbackInterfaceObjectClass::new(
        &InterfaceConstructorBehavior::throw(),
        b"function PaintRenderingContext2D() {\n    [native code]\n}",
        PrototypeList::ID::PaintRenderingContext2D,
        0);

pub unsafe fn DefineDOMInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject) {
    assert!(!global.get().is_null());

    if !ConstructorEnabled::<TH>(cx, global) {
        return;
    }

    rooted!(in(cx) let mut proto = ptr::null_mut::<JSObject>());
    GetProtoObject::<TH>(cx, global, proto.handle_mut());
    assert!(!proto.is_null());
}

unsafe fn ConstructorEnabled<TH: TypeHolderTrait>
(aCx: *mut JSContext, aObj: HandleObject) -> bool {
    is_exposed_in(aObj, InterfaceObjectMap::Globals::PAINT_WORKLET_GLOBAL_SCOPE) &&
    PREFS.get("dom.worklet.enabled").as_boolean().unwrap_or(false)
}

unsafe fn CreateInterfaceObjects<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject, cache: *mut ProtoOrIfaceArray) {
    rooted!(in(cx) let mut prototype_proto = ptr::null_mut::<JSObject>());
    prototype_proto.set(JS_GetObjectPrototype(cx, global));
    assert!(!prototype_proto.is_null());

    rooted!(in(cx) let mut prototype = ptr::null_mut::<JSObject>());
    create_interface_prototype_object(cx,
                                      prototype_proto.handle().into(),
                                      &PrototypeClass,
                                      sMethods,
                                      sAttributes,
                                      &[],
                                      &[],
                                      prototype.handle_mut().into());
    assert!(!prototype.is_null());
    assert!((*cache)[PrototypeList::ID::PaintRenderingContext2D as usize].is_null());
    (*cache)[PrototypeList::ID::PaintRenderingContext2D as usize] = prototype.get();
    <*mut JSObject>::post_barrier((*cache).as_mut_ptr().offset(PrototypeList::ID::PaintRenderingContext2D as isize),
                                  ptr::null_mut(),
                                  prototype.get());


    rooted!(in(cx) let interface_proto = JS_GetFunctionPrototype(cx, global));
    assert!(!interface_proto.is_null());

    rooted!(in(cx) let mut interface = ptr::null_mut::<JSObject>());
    create_noncallback_interface_object(cx,
                                        global.into(),
                                        interface_proto.handle(),
                                        &INTERFACE_OBJECT_CLASS,
                                        &[],
                                        &[],
                                        &[],
                                        prototype.handle(),
                                        b"PaintRenderingContext2D\0",
                                        0,
                                        interface.handle_mut());
    assert!(!interface.is_null());
}
} // mod PaintRenderingContext2DBinding


