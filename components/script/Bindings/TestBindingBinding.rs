/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */

#![allow(non_camel_case_types,non_upper_case_globals,unused_imports,unused_variables,unused_assignments,unused_mut)]
use dom;
use dom::bindings;
use dom::bindings::callback::CallSetup;
use dom::bindings::callback::CallbackContainer;
use dom::bindings::callback::CallbackFunction;
use dom::bindings::callback::CallbackInterface;
use dom::bindings::callback::CallbackObject;
use dom::bindings::callback::ExceptionHandling;
use dom::bindings::callback::wrap_call_this_object;
use dom::bindings::codegen::Bindings::NodeBinding::NodeBinding;
use dom::bindings::codegen::InterfaceObjectMap;
use dom::bindings::codegen::PrototypeList;
use dom::bindings::codegen::RegisterBindings;
use dom::bindings::codegen::UnionTypes;
use dom::bindings::constant::ConstantSpec;
use dom::bindings::constant::ConstantVal;
use dom::bindings::conversions::ConversionBehavior;
use dom::bindings::conversions::ConversionResult;
use dom::bindings::conversions::DOM_OBJECT_SLOT;
use dom::bindings::conversions::FromJSValConvertible;
use dom::bindings::conversions::IDLInterface;
use dom::bindings::conversions::StringificationBehavior;
use dom::bindings::conversions::ToJSValConvertible;
use dom::bindings::conversions::is_array_like;
use dom::bindings::conversions::jsid_to_string;
use dom::bindings::conversions::native_from_handlevalue;
use dom::bindings::conversions::native_from_object;
use dom::bindings::conversions::private_from_object;
use dom::bindings::conversions::root_from_handleobject;
use dom::bindings::conversions::root_from_handlevalue;
use dom::bindings::conversions::root_from_object;
use dom::bindings::error::Error;
use dom::bindings::error::Error::JSFailed;
use dom::bindings::error::ErrorResult;
use dom::bindings::error::Fallible;
use dom::bindings::error::throw_dom_exception;
use dom::bindings::guard::Condition;
use dom::bindings::guard::Guard;
use dom::bindings::htmlconstructor::html_constructor;
use dom::bindings::htmlconstructor::pop_current_element_queue;
use dom::bindings::htmlconstructor::push_new_element_queue;
use dom::bindings::inheritance::Castable;
use dom::bindings::interface::ConstructorClassHook;
use dom::bindings::interface::InterfaceConstructorBehavior;
use dom::bindings::interface::NonCallbackInterfaceObjectClass;
use dom::bindings::interface::create_callback_interface_object;
use dom::bindings::interface::create_global_object;
use dom::bindings::interface::create_interface_prototype_object;
use dom::bindings::interface::create_named_constructors;
use dom::bindings::interface::create_noncallback_interface_object;
use dom::bindings::interface::define_guarded_constants;
use dom::bindings::interface::define_guarded_methods;
use dom::bindings::interface::define_guarded_properties;
use dom::bindings::interface::is_exposed_in;
use dom::bindings::iterable::Iterable;
use dom::bindings::iterable::IteratorType;
use dom::bindings::mozmap::MozMap;
use dom::bindings::namespace::NamespaceObjectClass;
use dom::bindings::namespace::create_namespace_object;
use dom::bindings::num::Finite;
use dom::bindings::proxyhandler;
use dom::bindings::proxyhandler::ensure_expando_object;
use dom::bindings::proxyhandler::fill_property_descriptor;
use dom::bindings::proxyhandler::get_expando_object;
use dom::bindings::proxyhandler::get_property_descriptor;
use dom::bindings::reflector::DomObject;
use dom::bindings::reflector::MutDomObject;
use dom::bindings::root::Dom;
use dom::bindings::root::DomRoot;
use dom::bindings::root::OptionalHeapSetter;
use dom::bindings::root::RootedReference;
use dom::bindings::str::ByteString;
use dom::bindings::str::DOMString;
use dom::bindings::str::USVString;
use dom::bindings::trace::JSTraceable;
use dom::bindings::trace::RootedTraceable;
use dom::bindings::trace::RootedTraceableBox;
use dom::bindings::utils::AsVoidPtr;
use dom::bindings::utils::DOMClass;
use dom::bindings::utils::DOMJSClass;
use dom::bindings::utils::DOM_PROTO_UNFORGEABLE_HOLDER_SLOT;
use dom::bindings::utils::JSCLASS_DOM_GLOBAL;
use dom::bindings::utils::ProtoOrIfaceArray;
use dom::bindings::utils::enumerate_global;
use dom::bindings::utils::finalize_global;
use dom::bindings::utils::find_enum_value;
use dom::bindings::utils::generic_getter;
use dom::bindings::utils::generic_lenient_getter;
use dom::bindings::utils::generic_lenient_setter;
use dom::bindings::utils::generic_method;
use dom::bindings::utils::generic_setter;
use dom::bindings::utils::get_array_index_from_id;
use dom::bindings::utils::get_dictionary_property;
use dom::bindings::utils::get_property_on_prototype;
use dom::bindings::utils::get_proto_or_iface_array;
use dom::bindings::utils::has_property_on_prototype;
use dom::bindings::utils::is_platform_object;
use dom::bindings::utils::resolve_global;
use dom::bindings::utils::set_dictionary_property;
use dom::bindings::utils::trace_global;
use dom::bindings::weakref::DOM_WEAK_SLOT;
use dom::bindings::weakref::WeakBox;
use dom::bindings::weakref::WeakReferenceable;
use dom::globalscope::GlobalScope;
use dom::types::Blob;
use dom::types::Element;
use dom::types::Node;
use dom::types::URL;
use dom::windowproxy::WindowProxy;
use js;
use js::JSCLASS_GLOBAL_SLOT_COUNT;
use js::JSCLASS_IS_DOMJSCLASS;
use js::JSCLASS_IS_GLOBAL;
use js::JSCLASS_RESERVED_SLOTS_MASK;
use js::JS_CALLEE;
use js::error::throw_internal_error;
use js::error::throw_type_error;
use js::glue::AppendToAutoIdVector;
use js::glue::CallJitGetterOp;
use js::glue::CallJitMethodOp;
use js::glue::CallJitSetterOp;
use js::glue::CreateProxyHandler;
use js::glue::GetProxyPrivate;
use js::glue::ProxyTraps;
use js::glue::RUST_JSID_IS_INT;
use js::glue::RUST_JSID_IS_STRING;
use js::glue::RUST_SYMBOL_TO_JSID;
use js::glue::UnwrapObject;
use js::glue::int_to_jsid;
use js::jsapi::AutoIdVector;
use js::jsapi::CallArgs;
use js::jsapi::CurrentGlobalOrNull;
use js::jsapi::FreeOp;
use js::jsapi::GetWellKnownSymbol;
use js::jsapi::Handle as RawHandle;
use js::jsapi::HandleId as RawHandleId;
use js::jsapi::HandleObject as RawHandleObject;
use js::jsapi::HandleValue as RawHandleValue;
use js::jsapi::HandleValueArray;
use js::jsapi::Heap;
use js::jsapi::INTERNED_STRING_TO_JSID;
use js::jsapi::IsCallable;
use js::jsapi::JSAutoCompartment;
use js::jsapi::JSCLASS_RESERVED_SLOTS_SHIFT;
use js::jsapi::JSClass;
use js::jsapi::JSContext;
use js::jsapi::JSFreeOp;
use js::jsapi::JSFunctionSpec;
use js::jsapi::JSITER_HIDDEN;
use js::jsapi::JSITER_OWNONLY;
use js::jsapi::JSITER_SYMBOLS;
use js::jsapi::JSJitGetterCallArgs;
use js::jsapi::JSJitInfo;
use js::jsapi::JSJitInfo_AliasSet;
use js::jsapi::JSJitInfo_ArgType;
use js::jsapi::JSJitInfo_OpType;
use js::jsapi::JSJitMethodCallArgs;
use js::jsapi::JSJitSetterCallArgs;
use js::jsapi::JSNative;
use js::jsapi::JSNativeWrapper;
use js::jsapi::JSObject;
use js::jsapi::JSPROP_ENUMERATE;
use js::jsapi::JSPROP_PERMANENT;
use js::jsapi::JSPROP_READONLY;
use js::jsapi::JSPROP_SHARED;
use js::jsapi::JSPropertySpec;
use js::jsapi::JSString;
use js::jsapi::JSTracer;
use js::jsapi::JSType;
use js::jsapi::JSTypedMethodJitInfo;
use js::jsapi::JSValueType;
use js::jsapi::JS_AtomizeAndPinString;
use js::jsapi::JS_ForwardGetPropertyTo;
use js::jsapi::JS_GetErrorPrototype;
use js::jsapi::JS_GetGlobalForObject;
use js::jsapi::JS_GetIteratorPrototype;
use js::jsapi::JS_GetPropertyById;
use js::jsapi::JS_GetPropertyDescriptorById;
use js::jsapi::JS_GetReservedSlot;
use js::jsapi::JS_HasProperty;
use js::jsapi::JS_HasPropertyById;
use js::jsapi::JS_NewObject;
use js::jsapi::JS_SetReservedSlot;
use js::jsapi::MutableHandle as RawMutableHandle;
use js::jsapi::MutableHandleObject as RawMutableHandleObject;
use js::jsapi::MutableHandleValue as RawMutableHandleValue;
use js::jsapi::ObjectOpResult;
use js::jsapi::PropertyDescriptor;
use js::jsapi::Rooted;
use js::jsapi::RootedId;
use js::jsapi::RootedObject;
use js::jsapi::RootedString;
use js::jsapi::SymbolCode;
use js::jsapi::jsid;
use js::jsval::JSVal;
use js::jsval::NullValue;
use js::jsval::ObjectOrNullValue;
use js::jsval::ObjectValue;
use js::jsval::PrivateValue;
use js::jsval::UndefinedValue;
use js::panic::maybe_resume_unwind;
use js::panic::wrap_panic;
use js::rust::CustomAutoRooterGuard;
use js::rust::GCMethods;
use js::rust::Handle;
use js::rust::HandleId;
use js::rust::HandleObject;
use js::rust::HandleValue;
use js::rust::MutableHandle;
use js::rust::MutableHandleObject;
use js::rust::MutableHandleValue;
use js::rust::define_methods;
use js::rust::define_properties;
use js::rust::get_object_class;
use js::rust::wrappers::Call;
use js::rust::wrappers::GetPropertyKeys;
use js::rust::wrappers::JS_CallFunctionValue;
use js::rust::wrappers::JS_CopyPropertiesFrom;
use js::rust::wrappers::JS_DefineProperty;
use js::rust::wrappers::JS_DefinePropertyById2;
use js::rust::wrappers::JS_GetFunctionPrototype;
use js::rust::wrappers::JS_GetObjectPrototype;
use js::rust::wrappers::JS_GetProperty;
use js::rust::wrappers::JS_InitializePropertiesFromCompatibleNativeObject;
use js::rust::wrappers::JS_NewObjectWithGivenProto;
use js::rust::wrappers::JS_NewObjectWithoutMetadata;
use js::rust::wrappers::JS_ObjectIsDate;
use js::rust::wrappers::JS_SetImmutablePrototype;
use js::rust::wrappers::JS_SetProperty;
use js::rust::wrappers::JS_SetPrototype;
use js::rust::wrappers::JS_SplicePrototype;
use js::rust::wrappers::JS_WrapObject;
use js::rust::wrappers::JS_WrapValue;
use js::rust::wrappers::NewProxyObject;
use js::typedarray;
use libc;
use malloc_size_of::MallocSizeOfOps;
use mem::malloc_size_of_including_raw_self;
use servo_config::prefs::PREFS;
use std::borrow::ToOwned;
use std::cmp;
use std::default::Default;
use std::ffi::CString;
use std::mem;
use std::num;
use std::os;
use std::os::raw::c_void;
use std::panic;
use std::ptr;
use std::ptr::NonNull;
use std::rc;
use std::rc::Rc;
use std::str;
use typeholder::TypeHolderTrait;

#[repr(usize)]
#[derive(Copy, Clone, Debug, JSTraceable, MallocSizeOf, PartialEq)]
pub enum TestEnum {
    _empty,
    Foo,
    Bar
}
pub mod TestEnumValues {
    use dom::bindings::conversions::ToJSValConvertible;
    use js::jsapi::JSContext;
    use js::rust::MutableHandleValue;
    use js::jsval::JSVal;

    pub const pairs: &'static [(&'static str, super::TestEnum)] = &[
        ("", super::TestEnum::_empty),
        ("foo", super::TestEnum::Foo),
        ("bar", super::TestEnum::Bar),
    ];

    impl super::TestEnum {
        pub fn as_str(&self) -> &'static str {
            pairs[*self as usize].0
        }
    }

    impl Default for super::TestEnum {
        fn default() -> super::TestEnum {
            pairs[0].1
        }
    }

    impl ToJSValConvertible for super::TestEnum {
        unsafe fn to_jsval(&self, cx: *mut JSContext, rval: MutableHandleValue) {
            pairs[*self as usize].0.to_jsval(cx, rval);
        }
    }
        } // mod TestEnumValues

pub use self::UnionTypes::StringOrURLOrBlob as TestTypedef;

pub type TestTypedefNullableUnion<TH> = Option<UnionTypes::StringOrURLOrBlob<TH>>;

pub type TestTypedefString = DOMString;

pub type TestTypedefInterface<TH> = DomRoot<Blob<TH>>;

#[derive(JSTraceable)]
#[must_root]
pub struct TestDictionary<TH: TypeHolderTrait + 'static> {
    pub anyValue: RootedTraceableBox<Heap<JSVal>>,
    pub booleanValue: Option<bool>,
    pub byteValue: Option<i8>,
    pub dict: RootedTraceableBox<dom::bindings::codegen::Bindings::TestBindingBinding::TestDictionaryDefaults>,
    pub doubleValue: Option<Finite<f64>>,
    pub elementSequence: Option<Vec<DomRoot<Element<TH>>>>,
    pub enumValue: Option<TestEnum>,
    pub floatValue: Option<Finite<f32>>,
    pub interfaceValue: Option<DomRoot<Blob<TH>>>,
    pub longLongValue: Option<i64>,
    pub longValue: Option<i32>,
    pub nonRequiredNullable: Option<Option<DOMString>>,
    pub nonRequiredNullable2: Option<Option<DOMString>>,
    pub objectValue: Option<RootedTraceableBox<Heap<*mut JSObject>>>,
    pub octetValue: Option<u8>,
    pub requiredValue: bool,
    pub seqDict: Option<Vec<RootedTraceableBox<dom::bindings::codegen::Bindings::TestBindingBinding::TestDictionaryDefaults>>>,
    pub shortValue: Option<i16>,
    pub stringValue: Option<DOMString>,
    pub type_: Option<DOMString>,
    pub unrestrictedDoubleValue: Option<f64>,
    pub unrestrictedFloatValue: Option<f32>,
    pub unsignedLongLongValue: Option<u64>,
    pub unsignedLongValue: Option<u32>,
    pub unsignedShortValue: Option<u16>,
    pub usvstringValue: Option<USVString>,
}

impl<TH: TypeHolderTrait> Default for TestDictionary<TH> {
    fn default() -> Self {
        Self {
            anyValue: RootedTraceableBox::default(),
            booleanValue: Option::default(),
            byteValue: Option::default(),
            dict: RootedTraceableBox::default(),
            doubleValue: Option::default(),
            elementSequence: Option::default(),
            enumValue: Option::default(),
            floatValue: Option::default(),
            interfaceValue: Option::default(),
            longLongValue: Option::default(),
            longValue: Option::default(),
            nonRequiredNullable: Option::default(),
            nonRequiredNullable2: Option::default(),
            objectValue: Option::default(),
            octetValue: Option::default(),
            requiredValue: false,
            seqDict: Option::default(),
            shortValue: Option::default(),
            stringValue: Option::default(),
            type_: Option::default(),
            unrestrictedDoubleValue: Option::default(),
            unrestrictedFloatValue: Option::default(),
            unsignedLongLongValue: Option::default(),
            unsignedLongValue: Option::default(),
            unsignedShortValue: Option::default(),
            usvstringValue: Option::default(),
        }
    }
}

impl<TH: TypeHolderTrait> TestDictionary<TH> {
    pub unsafe fn empty(cx: *mut JSContext) -> RootedTraceableBox<TestDictionary<TH>> {
        match TestDictionary::new(cx, HandleValue::null()) {
            Ok(ConversionResult::Success(v)) => v,
            _ => unreachable!(),
        }
    }
    pub unsafe fn new(cx: *mut JSContext, val: HandleValue)
                      -> Result<ConversionResult<RootedTraceableBox<TestDictionary<TH>>>, ()> {
        let object = if val.get().is_null_or_undefined() {
            ptr::null_mut()
        } else if val.get().is_object() {
            val.get().to_object()
        } else {
            return Ok(ConversionResult::Failure("Value is not an object.".into()));
        };
        rooted!(in(cx) let object = object);
            let mut dictionary = RootedTraceableBox::new(TestDictionary::<TH>::default());
            dictionary.anyValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "anyValue", rval.handle_mut())) {
                    true => {
                        RootedTraceableBox::from_box(Heap::boxed(rval.handle().get()))
                    },
                    false => {
                        RootedTraceableBox::from_box(Heap::boxed(UndefinedValue()))
                    },
                }
            };
            dictionary.booleanValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "booleanValue", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.byteValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "byteValue", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.dict = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "dict", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(dictionary)) => dictionary,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); },
                        }
                    },
                    false => {
                        dom::bindings::codegen::Bindings::TestBindingBinding::TestDictionaryDefaults::empty(cx)
                    },
                }
            };
            dictionary.doubleValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "doubleValue", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.elementSequence = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "elementSequence", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(value)) => value,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); },
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.enumValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "enumValue", rval.handle_mut())) {
                    true => {
                        Some(match find_enum_value(cx, rval.handle(), TestEnumValues::pairs) {
                            Err(_) => { return Err(()); },
                            Ok((None, search)) => { throw_type_error(cx, &format!("'{}' is not a valid enum value for enumeration 'TestEnum'.", search)); return Err(()); },
                            Ok((Some(&value), _)) => value,
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.floatValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "floatValue", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.interfaceValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "interfaceValue", rval.handle_mut())) {
                    true => {
                        Some(if rval.handle().get().is_object() {
                            match root_from_handlevalue(rval.handle()) {
                                Ok(val) => val,
                                Err(()) => {
                                    throw_type_error(cx, "value does not implement interface Blob.");
                                    return Err(());
                                }
                            }

                        } else {
                            throw_type_error(cx, "Value is not an object.");
                            return Err(());
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.longLongValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "longLongValue", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.longValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "longValue", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.nonRequiredNullable = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nonRequiredNullable", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), StringificationBehavior::Default) {
                            Ok(ConversionResult::Success(strval)) => strval,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); },
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.nonRequiredNullable2 = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nonRequiredNullable2", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), StringificationBehavior::Default) {
                            Ok(ConversionResult::Success(strval)) => strval,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); },
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.objectValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "objectValue", rval.handle_mut())) {
                    true => {
                        Some(if rval.handle().get().is_object() {
                            RootedTraceableBox::from_box(Heap::boxed(rval.handle().get().to_object()))
                        } else {
                            throw_type_error(cx, "Value is not an object.");
                            return Err(());
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.octetValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "octetValue", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.requiredValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "requiredValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        throw_type_error(cx, "Missing required member \"requiredValue\".");
                        return Err(());
                    },
                }
            };
            dictionary.seqDict = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "seqDict", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(value)) => value,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); },
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.shortValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "shortValue", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.stringValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "stringValue", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), StringificationBehavior::Default) {
                            Ok(ConversionResult::Success(strval)) => strval,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); },
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.type_ = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "type", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), StringificationBehavior::Default) {
                            Ok(ConversionResult::Success(strval)) => strval,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); },
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.unrestrictedDoubleValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "unrestrictedDoubleValue", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.unrestrictedFloatValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "unrestrictedFloatValue", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.unsignedLongLongValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "unsignedLongLongValue", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.unsignedLongValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "unsignedLongValue", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.unsignedShortValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "unsignedShortValue", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.usvstringValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "usvstringValue", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(strval)) => strval,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); },
                        })
                    },
                    false => {
                        None
                    },
                }
            };
        Ok(ConversionResult::Success(dictionary))
    }
}

impl<TH: TypeHolderTrait> FromJSValConvertible for RootedTraceableBox<TestDictionary<TH>> {
    type Config = ();
    unsafe fn from_jsval(cx: *mut JSContext, value: HandleValue, _option: ())
                         -> Result<ConversionResult<RootedTraceableBox<TestDictionary<TH>>>, ()> {
        TestDictionary::new(cx, value)
    }
}

impl<TH: TypeHolderTrait> ToJSValConvertible for RootedTraceableBox<TestDictionary<TH>> {
    unsafe fn to_jsval(&self, cx: *mut JSContext, mut rval: MutableHandleValue) {
        rooted!(in(cx) let obj = JS_NewObject(cx, ptr::null()));
        let anyValue = &self.anyValue;
        rooted!(in(cx) let mut anyValue_js = UndefinedValue());
        anyValue.to_jsval(cx, anyValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "anyValue", anyValue_js.handle()).unwrap();
        if let Some(ref booleanValue) = self.booleanValue {
            rooted!(in(cx) let mut booleanValue_js = UndefinedValue());
            booleanValue.to_jsval(cx, booleanValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "booleanValue", booleanValue_js.handle()).unwrap();
        }
        if let Some(ref byteValue) = self.byteValue {
            rooted!(in(cx) let mut byteValue_js = UndefinedValue());
            byteValue.to_jsval(cx, byteValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "byteValue", byteValue_js.handle()).unwrap();
        }
        let dict = &self.dict;
        rooted!(in(cx) let mut dict_js = UndefinedValue());
        dict.to_jsval(cx, dict_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "dict", dict_js.handle()).unwrap();
        if let Some(ref doubleValue) = self.doubleValue {
            rooted!(in(cx) let mut doubleValue_js = UndefinedValue());
            doubleValue.to_jsval(cx, doubleValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "doubleValue", doubleValue_js.handle()).unwrap();
        }
        if let Some(ref elementSequence) = self.elementSequence {
            rooted!(in(cx) let mut elementSequence_js = UndefinedValue());
            elementSequence.to_jsval(cx, elementSequence_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "elementSequence", elementSequence_js.handle()).unwrap();
        }
        if let Some(ref enumValue) = self.enumValue {
            rooted!(in(cx) let mut enumValue_js = UndefinedValue());
            enumValue.to_jsval(cx, enumValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "enumValue", enumValue_js.handle()).unwrap();
        }
        if let Some(ref floatValue) = self.floatValue {
            rooted!(in(cx) let mut floatValue_js = UndefinedValue());
            floatValue.to_jsval(cx, floatValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "floatValue", floatValue_js.handle()).unwrap();
        }
        if let Some(ref interfaceValue) = self.interfaceValue {
            rooted!(in(cx) let mut interfaceValue_js = UndefinedValue());
            interfaceValue.to_jsval(cx, interfaceValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "interfaceValue", interfaceValue_js.handle()).unwrap();
        }
        if let Some(ref longLongValue) = self.longLongValue {
            rooted!(in(cx) let mut longLongValue_js = UndefinedValue());
            longLongValue.to_jsval(cx, longLongValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "longLongValue", longLongValue_js.handle()).unwrap();
        }
        if let Some(ref longValue) = self.longValue {
            rooted!(in(cx) let mut longValue_js = UndefinedValue());
            longValue.to_jsval(cx, longValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "longValue", longValue_js.handle()).unwrap();
        }
        if let Some(ref nonRequiredNullable) = self.nonRequiredNullable {
            rooted!(in(cx) let mut nonRequiredNullable_js = UndefinedValue());
            nonRequiredNullable.to_jsval(cx, nonRequiredNullable_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "nonRequiredNullable", nonRequiredNullable_js.handle()).unwrap();
        }
        if let Some(ref nonRequiredNullable2) = self.nonRequiredNullable2 {
            rooted!(in(cx) let mut nonRequiredNullable2_js = UndefinedValue());
            nonRequiredNullable2.to_jsval(cx, nonRequiredNullable2_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "nonRequiredNullable2", nonRequiredNullable2_js.handle()).unwrap();
        }
        if let Some(ref objectValue) = self.objectValue {
            rooted!(in(cx) let mut objectValue_js = UndefinedValue());
            objectValue.to_jsval(cx, objectValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "objectValue", objectValue_js.handle()).unwrap();
        }
        if let Some(ref octetValue) = self.octetValue {
            rooted!(in(cx) let mut octetValue_js = UndefinedValue());
            octetValue.to_jsval(cx, octetValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "octetValue", octetValue_js.handle()).unwrap();
        }
        let requiredValue = &self.requiredValue;
        rooted!(in(cx) let mut requiredValue_js = UndefinedValue());
        requiredValue.to_jsval(cx, requiredValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "requiredValue", requiredValue_js.handle()).unwrap();
        if let Some(ref seqDict) = self.seqDict {
            rooted!(in(cx) let mut seqDict_js = UndefinedValue());
            seqDict.to_jsval(cx, seqDict_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "seqDict", seqDict_js.handle()).unwrap();
        }
        if let Some(ref shortValue) = self.shortValue {
            rooted!(in(cx) let mut shortValue_js = UndefinedValue());
            shortValue.to_jsval(cx, shortValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "shortValue", shortValue_js.handle()).unwrap();
        }
        if let Some(ref stringValue) = self.stringValue {
            rooted!(in(cx) let mut stringValue_js = UndefinedValue());
            stringValue.to_jsval(cx, stringValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "stringValue", stringValue_js.handle()).unwrap();
        }
        if let Some(ref type_) = self.type_ {
            rooted!(in(cx) let mut type__js = UndefinedValue());
            type_.to_jsval(cx, type__js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "type", type__js.handle()).unwrap();
        }
        if let Some(ref unrestrictedDoubleValue) = self.unrestrictedDoubleValue {
            rooted!(in(cx) let mut unrestrictedDoubleValue_js = UndefinedValue());
            unrestrictedDoubleValue.to_jsval(cx, unrestrictedDoubleValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "unrestrictedDoubleValue", unrestrictedDoubleValue_js.handle()).unwrap();
        }
        if let Some(ref unrestrictedFloatValue) = self.unrestrictedFloatValue {
            rooted!(in(cx) let mut unrestrictedFloatValue_js = UndefinedValue());
            unrestrictedFloatValue.to_jsval(cx, unrestrictedFloatValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "unrestrictedFloatValue", unrestrictedFloatValue_js.handle()).unwrap();
        }
        if let Some(ref unsignedLongLongValue) = self.unsignedLongLongValue {
            rooted!(in(cx) let mut unsignedLongLongValue_js = UndefinedValue());
            unsignedLongLongValue.to_jsval(cx, unsignedLongLongValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "unsignedLongLongValue", unsignedLongLongValue_js.handle()).unwrap();
        }
        if let Some(ref unsignedLongValue) = self.unsignedLongValue {
            rooted!(in(cx) let mut unsignedLongValue_js = UndefinedValue());
            unsignedLongValue.to_jsval(cx, unsignedLongValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "unsignedLongValue", unsignedLongValue_js.handle()).unwrap();
        }
        if let Some(ref unsignedShortValue) = self.unsignedShortValue {
            rooted!(in(cx) let mut unsignedShortValue_js = UndefinedValue());
            unsignedShortValue.to_jsval(cx, unsignedShortValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "unsignedShortValue", unsignedShortValue_js.handle()).unwrap();
        }
        if let Some(ref usvstringValue) = self.usvstringValue {
            rooted!(in(cx) let mut usvstringValue_js = UndefinedValue());
            usvstringValue.to_jsval(cx, usvstringValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "usvstringValue", usvstringValue_js.handle()).unwrap();
        }
        rval.set(ObjectOrNullValue(obj.get()))
    }
}


#[derive(JSTraceable, Default)]
#[must_root]
pub struct TestDictionaryDefaults {
    pub UnrestrictedDoubleValue: f64,
    pub anyValue: RootedTraceableBox<Heap<JSVal>>,
    pub booleanValue: bool,
    pub byteValue: i8,
    pub bytestringValue: ByteString,
    pub doubleValue: Finite<f64>,
    pub enumValue: TestEnum,
    pub floatValue: Finite<f32>,
    pub longLongValue: i64,
    pub longValue: i32,
    pub nullableBooleanValue: Option<bool>,
    pub nullableByteValue: Option<i8>,
    pub nullableBytestringValue: Option<ByteString>,
    pub nullableDoubleValue: Option<Finite<f64>>,
    pub nullableFloatValue: Option<Finite<f32>>,
    pub nullableLongLongValue: Option<i64>,
    pub nullableLongValue: Option<i32>,
    pub nullableObjectValue: RootedTraceableBox<Heap<*mut JSObject>>,
    pub nullableOctetValue: Option<u8>,
    pub nullableShortValue: Option<i16>,
    pub nullableStringValue: Option<DOMString>,
    pub nullableUnrestrictedDoubleValue: Option<f64>,
    pub nullableUnrestrictedFloatValue: Option<f32>,
    pub nullableUnsignedLongLongValue: Option<u64>,
    pub nullableUnsignedLongValue: Option<u32>,
    pub nullableUnsignedShortValue: Option<u16>,
    pub nullableUsvstringValue: Option<USVString>,
    pub octetValue: u8,
    pub shortValue: i16,
    pub stringValue: DOMString,
    pub unrestrictedFloatValue: f32,
    pub unsignedLongLongValue: u64,
    pub unsignedLongValue: u32,
    pub unsignedShortValue: u16,
    pub usvstringValue: USVString,
}
impl TestDictionaryDefaults {
    pub unsafe fn empty(cx: *mut JSContext) -> RootedTraceableBox<TestDictionaryDefaults> {
        match TestDictionaryDefaults::new(cx, HandleValue::null()) {
            Ok(ConversionResult::Success(v)) => v,
            _ => unreachable!(),
        }
    }
    pub unsafe fn new(cx: *mut JSContext, val: HandleValue)
                      -> Result<ConversionResult<RootedTraceableBox<TestDictionaryDefaults>>, ()> {
        let object = if val.get().is_null_or_undefined() {
            ptr::null_mut()
        } else if val.get().is_object() {
            val.get().to_object()
        } else {
            return Ok(ConversionResult::Failure("Value is not an object.".into()));
        };
        rooted!(in(cx) let object = object);
            let mut dictionary = RootedTraceableBox::new(TestDictionaryDefaults::default());
            dictionary.UnrestrictedDoubleValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "UnrestrictedDoubleValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        7.0
                    },
                }
            };
            dictionary.anyValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "anyValue", rval.handle_mut())) {
                    true => {
                        RootedTraceableBox::from_box(Heap::boxed(rval.handle().get()))
                    },
                    false => {
                        RootedTraceableBox::from_box(Heap::boxed(NullValue()))
                    },
                }
            };
            dictionary.booleanValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "booleanValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        false
                    },
                }
            };
            dictionary.byteValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "byteValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        7
                    },
                }
            };
            dictionary.bytestringValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "bytestringValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(strval)) => strval,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); },
                        }
                    },
                    false => {
                        ByteString::new(b"foo".to_vec())
                    },
                }
            };
            dictionary.doubleValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "doubleValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        Finite::wrap(7.0)
                    },
                }
            };
            dictionary.enumValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "enumValue", rval.handle_mut())) {
                    true => {
                        match find_enum_value(cx, rval.handle(), TestEnumValues::pairs) {
                            Err(_) => { return Err(()); },
                            Ok((None, search)) => { throw_type_error(cx, &format!("'{}' is not a valid enum value for enumeration 'TestEnum'.", search)); return Err(()); },
                            Ok((Some(&value), _)) => value,
                        }
                    },
                    false => {
                        TestEnum::Bar
                    },
                }
            };
            dictionary.floatValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "floatValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        Finite::wrap(7.0)
                    },
                }
            };
            dictionary.longLongValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "longLongValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        7
                    },
                }
            };
            dictionary.longValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "longValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        7
                    },
                }
            };
            dictionary.nullableBooleanValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableBooleanValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        Some(false)
                    },
                }
            };
            dictionary.nullableByteValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableByteValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        Some(7)
                    },
                }
            };
            dictionary.nullableBytestringValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableBytestringValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(strval)) => strval,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); },
                        }
                    },
                    false => {
                        Some(ByteString::new(b"foo".to_vec()))
                    },
                }
            };
            dictionary.nullableDoubleValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableDoubleValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        Some(Finite::wrap(7.0))
                    },
                }
            };
            dictionary.nullableFloatValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableFloatValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        Some(Finite::wrap(7.0))
                    },
                }
            };
            dictionary.nullableLongLongValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableLongLongValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        Some(7)
                    },
                }
            };
            dictionary.nullableLongValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableLongValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        Some(7)
                    },
                }
            };
            dictionary.nullableObjectValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableObjectValue", rval.handle_mut())) {
                    true => {
                        if rval.handle().get().is_object() {
                            RootedTraceableBox::from_box(Heap::boxed(rval.handle().get().to_object()))
                        } else if rval.handle().get().is_null_or_undefined() {
                            RootedTraceableBox::new(Heap::default())
                        } else {
                            throw_type_error(cx, "Value is not an object.");
                            return Err(());
                        }
                    },
                    false => {
                        RootedTraceableBox::new(Heap::default())
                    },
                }
            };
            dictionary.nullableOctetValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableOctetValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        Some(7)
                    },
                }
            };
            dictionary.nullableShortValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableShortValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        Some(7)
                    },
                }
            };
            dictionary.nullableStringValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableStringValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), StringificationBehavior::Default) {
                            Ok(ConversionResult::Success(strval)) => strval,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); },
                        }
                    },
                    false => {
                        Some(DOMString::from("foo"))
                    },
                }
            };
            dictionary.nullableUnrestrictedDoubleValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableUnrestrictedDoubleValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        Some(7.0)
                    },
                }
            };
            dictionary.nullableUnrestrictedFloatValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableUnrestrictedFloatValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        Some(7.0)
                    },
                }
            };
            dictionary.nullableUnsignedLongLongValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableUnsignedLongLongValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        Some(7)
                    },
                }
            };
            dictionary.nullableUnsignedLongValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableUnsignedLongValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        Some(7)
                    },
                }
            };
            dictionary.nullableUnsignedShortValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableUnsignedShortValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        Some(7)
                    },
                }
            };
            dictionary.nullableUsvstringValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableUsvstringValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(strval)) => strval,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); },
                        }
                    },
                    false => {
                        Some(USVString("foo".to_owned()))
                    },
                }
            };
            dictionary.octetValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "octetValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        7
                    },
                }
            };
            dictionary.shortValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "shortValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        7
                    },
                }
            };
            dictionary.stringValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "stringValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), StringificationBehavior::Default) {
                            Ok(ConversionResult::Success(strval)) => strval,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); },
                        }
                    },
                    false => {
                        DOMString::from("foo")
                    },
                }
            };
            dictionary.unrestrictedFloatValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "unrestrictedFloatValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        7.0
                    },
                }
            };
            dictionary.unsignedLongLongValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "unsignedLongLongValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        7
                    },
                }
            };
            dictionary.unsignedLongValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "unsignedLongValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        7
                    },
                }
            };
            dictionary.unsignedShortValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "unsignedShortValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        7
                    },
                }
            };
            dictionary.usvstringValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "usvstringValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(strval)) => strval,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); },
                        }
                    },
                    false => {
                        USVString("foo".to_owned())
                    },
                }
            };
        Ok(ConversionResult::Success(dictionary))
    }
}

impl FromJSValConvertible for RootedTraceableBox<TestDictionaryDefaults> {
    type Config = ();
    unsafe fn from_jsval(cx: *mut JSContext, value: HandleValue, _option: ())
                         -> Result<ConversionResult<RootedTraceableBox<TestDictionaryDefaults>>, ()> {
        TestDictionaryDefaults::new(cx, value)
    }
}

impl ToJSValConvertible for RootedTraceableBox<TestDictionaryDefaults> {
    unsafe fn to_jsval(&self, cx: *mut JSContext, mut rval: MutableHandleValue) {
        rooted!(in(cx) let obj = JS_NewObject(cx, ptr::null()));
        let UnrestrictedDoubleValue = &self.UnrestrictedDoubleValue;
        rooted!(in(cx) let mut UnrestrictedDoubleValue_js = UndefinedValue());
        UnrestrictedDoubleValue.to_jsval(cx, UnrestrictedDoubleValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "UnrestrictedDoubleValue", UnrestrictedDoubleValue_js.handle()).unwrap();
        let anyValue = &self.anyValue;
        rooted!(in(cx) let mut anyValue_js = UndefinedValue());
        anyValue.to_jsval(cx, anyValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "anyValue", anyValue_js.handle()).unwrap();
        let booleanValue = &self.booleanValue;
        rooted!(in(cx) let mut booleanValue_js = UndefinedValue());
        booleanValue.to_jsval(cx, booleanValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "booleanValue", booleanValue_js.handle()).unwrap();
        let byteValue = &self.byteValue;
        rooted!(in(cx) let mut byteValue_js = UndefinedValue());
        byteValue.to_jsval(cx, byteValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "byteValue", byteValue_js.handle()).unwrap();
        let bytestringValue = &self.bytestringValue;
        rooted!(in(cx) let mut bytestringValue_js = UndefinedValue());
        bytestringValue.to_jsval(cx, bytestringValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "bytestringValue", bytestringValue_js.handle()).unwrap();
        let doubleValue = &self.doubleValue;
        rooted!(in(cx) let mut doubleValue_js = UndefinedValue());
        doubleValue.to_jsval(cx, doubleValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "doubleValue", doubleValue_js.handle()).unwrap();
        let enumValue = &self.enumValue;
        rooted!(in(cx) let mut enumValue_js = UndefinedValue());
        enumValue.to_jsval(cx, enumValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "enumValue", enumValue_js.handle()).unwrap();
        let floatValue = &self.floatValue;
        rooted!(in(cx) let mut floatValue_js = UndefinedValue());
        floatValue.to_jsval(cx, floatValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "floatValue", floatValue_js.handle()).unwrap();
        let longLongValue = &self.longLongValue;
        rooted!(in(cx) let mut longLongValue_js = UndefinedValue());
        longLongValue.to_jsval(cx, longLongValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "longLongValue", longLongValue_js.handle()).unwrap();
        let longValue = &self.longValue;
        rooted!(in(cx) let mut longValue_js = UndefinedValue());
        longValue.to_jsval(cx, longValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "longValue", longValue_js.handle()).unwrap();
        let nullableBooleanValue = &self.nullableBooleanValue;
        rooted!(in(cx) let mut nullableBooleanValue_js = UndefinedValue());
        nullableBooleanValue.to_jsval(cx, nullableBooleanValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableBooleanValue", nullableBooleanValue_js.handle()).unwrap();
        let nullableByteValue = &self.nullableByteValue;
        rooted!(in(cx) let mut nullableByteValue_js = UndefinedValue());
        nullableByteValue.to_jsval(cx, nullableByteValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableByteValue", nullableByteValue_js.handle()).unwrap();
        let nullableBytestringValue = &self.nullableBytestringValue;
        rooted!(in(cx) let mut nullableBytestringValue_js = UndefinedValue());
        nullableBytestringValue.to_jsval(cx, nullableBytestringValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableBytestringValue", nullableBytestringValue_js.handle()).unwrap();
        let nullableDoubleValue = &self.nullableDoubleValue;
        rooted!(in(cx) let mut nullableDoubleValue_js = UndefinedValue());
        nullableDoubleValue.to_jsval(cx, nullableDoubleValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableDoubleValue", nullableDoubleValue_js.handle()).unwrap();
        let nullableFloatValue = &self.nullableFloatValue;
        rooted!(in(cx) let mut nullableFloatValue_js = UndefinedValue());
        nullableFloatValue.to_jsval(cx, nullableFloatValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableFloatValue", nullableFloatValue_js.handle()).unwrap();
        let nullableLongLongValue = &self.nullableLongLongValue;
        rooted!(in(cx) let mut nullableLongLongValue_js = UndefinedValue());
        nullableLongLongValue.to_jsval(cx, nullableLongLongValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableLongLongValue", nullableLongLongValue_js.handle()).unwrap();
        let nullableLongValue = &self.nullableLongValue;
        rooted!(in(cx) let mut nullableLongValue_js = UndefinedValue());
        nullableLongValue.to_jsval(cx, nullableLongValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableLongValue", nullableLongValue_js.handle()).unwrap();
        let nullableObjectValue = &self.nullableObjectValue;
        rooted!(in(cx) let mut nullableObjectValue_js = UndefinedValue());
        nullableObjectValue.to_jsval(cx, nullableObjectValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableObjectValue", nullableObjectValue_js.handle()).unwrap();
        let nullableOctetValue = &self.nullableOctetValue;
        rooted!(in(cx) let mut nullableOctetValue_js = UndefinedValue());
        nullableOctetValue.to_jsval(cx, nullableOctetValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableOctetValue", nullableOctetValue_js.handle()).unwrap();
        let nullableShortValue = &self.nullableShortValue;
        rooted!(in(cx) let mut nullableShortValue_js = UndefinedValue());
        nullableShortValue.to_jsval(cx, nullableShortValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableShortValue", nullableShortValue_js.handle()).unwrap();
        let nullableStringValue = &self.nullableStringValue;
        rooted!(in(cx) let mut nullableStringValue_js = UndefinedValue());
        nullableStringValue.to_jsval(cx, nullableStringValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableStringValue", nullableStringValue_js.handle()).unwrap();
        let nullableUnrestrictedDoubleValue = &self.nullableUnrestrictedDoubleValue;
        rooted!(in(cx) let mut nullableUnrestrictedDoubleValue_js = UndefinedValue());
        nullableUnrestrictedDoubleValue.to_jsval(cx, nullableUnrestrictedDoubleValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableUnrestrictedDoubleValue", nullableUnrestrictedDoubleValue_js.handle()).unwrap();
        let nullableUnrestrictedFloatValue = &self.nullableUnrestrictedFloatValue;
        rooted!(in(cx) let mut nullableUnrestrictedFloatValue_js = UndefinedValue());
        nullableUnrestrictedFloatValue.to_jsval(cx, nullableUnrestrictedFloatValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableUnrestrictedFloatValue", nullableUnrestrictedFloatValue_js.handle()).unwrap();
        let nullableUnsignedLongLongValue = &self.nullableUnsignedLongLongValue;
        rooted!(in(cx) let mut nullableUnsignedLongLongValue_js = UndefinedValue());
        nullableUnsignedLongLongValue.to_jsval(cx, nullableUnsignedLongLongValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableUnsignedLongLongValue", nullableUnsignedLongLongValue_js.handle()).unwrap();
        let nullableUnsignedLongValue = &self.nullableUnsignedLongValue;
        rooted!(in(cx) let mut nullableUnsignedLongValue_js = UndefinedValue());
        nullableUnsignedLongValue.to_jsval(cx, nullableUnsignedLongValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableUnsignedLongValue", nullableUnsignedLongValue_js.handle()).unwrap();
        let nullableUnsignedShortValue = &self.nullableUnsignedShortValue;
        rooted!(in(cx) let mut nullableUnsignedShortValue_js = UndefinedValue());
        nullableUnsignedShortValue.to_jsval(cx, nullableUnsignedShortValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableUnsignedShortValue", nullableUnsignedShortValue_js.handle()).unwrap();
        let nullableUsvstringValue = &self.nullableUsvstringValue;
        rooted!(in(cx) let mut nullableUsvstringValue_js = UndefinedValue());
        nullableUsvstringValue.to_jsval(cx, nullableUsvstringValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableUsvstringValue", nullableUsvstringValue_js.handle()).unwrap();
        let octetValue = &self.octetValue;
        rooted!(in(cx) let mut octetValue_js = UndefinedValue());
        octetValue.to_jsval(cx, octetValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "octetValue", octetValue_js.handle()).unwrap();
        let shortValue = &self.shortValue;
        rooted!(in(cx) let mut shortValue_js = UndefinedValue());
        shortValue.to_jsval(cx, shortValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "shortValue", shortValue_js.handle()).unwrap();
        let stringValue = &self.stringValue;
        rooted!(in(cx) let mut stringValue_js = UndefinedValue());
        stringValue.to_jsval(cx, stringValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "stringValue", stringValue_js.handle()).unwrap();
        let unrestrictedFloatValue = &self.unrestrictedFloatValue;
        rooted!(in(cx) let mut unrestrictedFloatValue_js = UndefinedValue());
        unrestrictedFloatValue.to_jsval(cx, unrestrictedFloatValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "unrestrictedFloatValue", unrestrictedFloatValue_js.handle()).unwrap();
        let unsignedLongLongValue = &self.unsignedLongLongValue;
        rooted!(in(cx) let mut unsignedLongLongValue_js = UndefinedValue());
        unsignedLongLongValue.to_jsval(cx, unsignedLongLongValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "unsignedLongLongValue", unsignedLongLongValue_js.handle()).unwrap();
        let unsignedLongValue = &self.unsignedLongValue;
        rooted!(in(cx) let mut unsignedLongValue_js = UndefinedValue());
        unsignedLongValue.to_jsval(cx, unsignedLongValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "unsignedLongValue", unsignedLongValue_js.handle()).unwrap();
        let unsignedShortValue = &self.unsignedShortValue;
        rooted!(in(cx) let mut unsignedShortValue_js = UndefinedValue());
        unsignedShortValue.to_jsval(cx, unsignedShortValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "unsignedShortValue", unsignedShortValue_js.handle()).unwrap();
        let usvstringValue = &self.usvstringValue;
        rooted!(in(cx) let mut usvstringValue_js = UndefinedValue());
        usvstringValue.to_jsval(cx, usvstringValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "usvstringValue", usvstringValue_js.handle()).unwrap();
        rval.set(ObjectOrNullValue(obj.get()))
    }
}


#[derive(JSTraceable, PartialEq)]
#[allow_unrooted_interior]
pub struct SimpleCallback<TH: TypeHolderTrait + 'static> {
    pub parent: CallbackFunction<TH>,
}

impl<TH: TypeHolderTrait> SimpleCallback<TH> {
    pub unsafe fn new(aCx: *mut JSContext, aCallback: *mut JSObject) -> Rc<SimpleCallback<TH>> {
        let mut ret = Rc::new(SimpleCallback {
            parent: CallbackFunction::new()
        });
        // Note: callback cannot be moved after calling init.
        match Rc::get_mut(&mut ret) {
            Some(ref mut callback) => callback.parent.init(aCx, aCallback),
            None => unreachable!(),
        };
        ret
    }

    pub fn Call_<T: DomObject>(&self, thisObj: &T, value: HandleValue, aExceptionHandling: ExceptionHandling) -> Fallible<(), TH> {
        let s = CallSetup::new(self, aExceptionHandling);
        rooted!(in(s.get_context()) let mut thisObjJS = ptr::null_mut::<JSObject>());
        wrap_call_this_object(s.get_context(), thisObj, thisObjJS.handle_mut());
        if thisObjJS.is_null() {
            return Err(JSFailed);
        }
        unsafe { self.Call(s.get_context(), thisObjJS.handle(), value) }
    }

    pub fn Call__(&self, value: HandleValue, aExceptionHandling: ExceptionHandling) -> Fallible<(), TH> {
        let s = CallSetup::new(self, aExceptionHandling);
        rooted!(in(s.get_context()) let thisObjJS = ptr::null_mut::<JSObject>());
        unsafe { self.Call(s.get_context(), thisObjJS.handle(), value) }
    }

    unsafe fn Call(&self, cx: *mut JSContext, aThisObj: HandleObject, value: HandleValue) -> Fallible<(), TH> {
        rooted!(in(cx) let mut rval = UndefinedValue());
        rooted_vec!(let mut argv);
        argv.extend((0..1).map(|_| Heap::default()));

        let argc = 1;

        rooted!(in(cx) let mut argv_root = UndefinedValue());
        (value).to_jsval(cx, argv_root.handle_mut());
        {
        let arg = &mut argv[0];
        *arg = Heap::default();
        arg.set(argv_root.get());
        }

        rooted!(in(cx) let callable = ObjectValue(self.callback()));
        rooted!(in(cx) let rootedThis = aThisObj.get());
        let ok = JS_CallFunctionValue(
            cx, rootedThis.handle(), callable.handle(),
            &HandleValueArray {
                length_: argc as ::libc::size_t,
                elements_: argv.as_ptr() as *const JSVal
            }, rval.handle_mut());
        maybe_resume_unwind();
        if !ok {
            return Err(JSFailed);
        }

        Ok(())

    }
}
impl<TH: TypeHolderTrait> CallbackContainer<TH> for SimpleCallback<TH> {
    unsafe fn new(cx: *mut JSContext, callback: *mut JSObject) -> Rc<SimpleCallback<TH>> {
        SimpleCallback::new(cx, callback)
    }

    fn callback_holder(&self) -> &CallbackObject<TH> {
        self.parent.callback_holder()
    }
}

impl<TH: TypeHolderTrait> ToJSValConvertible for SimpleCallback<TH> {
    unsafe fn to_jsval(&self, cx: *mut JSContext, rval: MutableHandleValue) {
        self.callback().to_jsval(cx, rval);
    }
}

pub use self::TestBindingBinding::{TestBindingConstants, Wrap, TestBindingMethods, GetProtoObject, GetConstructorObject, DefineDOMInterface};
pub mod TestBindingBinding {
#![allow(non_camel_case_types,non_upper_case_globals,unused_imports,unused_variables,unused_assignments,unused_mut)]
use dom;
use dom::bindings;
use dom::bindings::callback::CallSetup;
use dom::bindings::callback::CallbackContainer;
use dom::bindings::callback::CallbackFunction;
use dom::bindings::callback::CallbackInterface;
use dom::bindings::callback::CallbackObject;
use dom::bindings::callback::ExceptionHandling;
use dom::bindings::callback::wrap_call_this_object;
use dom::bindings::codegen::Bindings::ElementBinding::ElementBinding;
use dom::bindings::codegen::Bindings::EventListenerBinding::EventListener;
use dom::bindings::codegen::Bindings::EventTargetBinding::EventTargetBinding;
use dom::bindings::codegen::Bindings::FunctionBinding::Function;
use dom::bindings::codegen::Bindings::NodeBinding::NodeBinding;
use dom::bindings::codegen::Bindings::TestBindingBinding::SimpleCallback;
use dom::bindings::codegen::Bindings::TestBindingBinding::TestDictionary;
use dom::bindings::codegen::Bindings::TestBindingBinding::TestDictionaryDefaults;
use dom::bindings::codegen::Bindings::TestBindingBinding::TestEnum;
use dom::bindings::codegen::Bindings::TestBindingBinding::TestEnumValues;
use dom::bindings::codegen::InterfaceObjectMap;
use dom::bindings::codegen::PrototypeList;
use dom::bindings::codegen::RegisterBindings;
use dom::bindings::codegen::UnionTypes;
use dom::bindings::constant::ConstantSpec;
use dom::bindings::constant::ConstantVal;
use dom::bindings::conversions::ConversionBehavior;
use dom::bindings::conversions::ConversionResult;
use dom::bindings::conversions::DOM_OBJECT_SLOT;
use dom::bindings::conversions::FromJSValConvertible;
use dom::bindings::conversions::IDLInterface;
use dom::bindings::conversions::StringificationBehavior;
use dom::bindings::conversions::ToJSValConvertible;
use dom::bindings::conversions::is_array_like;
use dom::bindings::conversions::jsid_to_string;
use dom::bindings::conversions::native_from_handlevalue;
use dom::bindings::conversions::native_from_object;
use dom::bindings::conversions::private_from_object;
use dom::bindings::conversions::root_from_handleobject;
use dom::bindings::conversions::root_from_handlevalue;
use dom::bindings::conversions::root_from_object;
use dom::bindings::error::Error;
use dom::bindings::error::Error::JSFailed;
use dom::bindings::error::ErrorResult;
use dom::bindings::error::Fallible;
use dom::bindings::error::throw_dom_exception;
use dom::bindings::guard::Condition;
use dom::bindings::guard::Guard;
use dom::bindings::htmlconstructor::html_constructor;
use dom::bindings::htmlconstructor::pop_current_element_queue;
use dom::bindings::htmlconstructor::push_new_element_queue;
use dom::bindings::inheritance::Castable;
use dom::bindings::interface::ConstructorClassHook;
use dom::bindings::interface::InterfaceConstructorBehavior;
use dom::bindings::interface::NonCallbackInterfaceObjectClass;
use dom::bindings::interface::create_callback_interface_object;
use dom::bindings::interface::create_global_object;
use dom::bindings::interface::create_interface_prototype_object;
use dom::bindings::interface::create_named_constructors;
use dom::bindings::interface::create_noncallback_interface_object;
use dom::bindings::interface::define_guarded_constants;
use dom::bindings::interface::define_guarded_methods;
use dom::bindings::interface::define_guarded_properties;
use dom::bindings::interface::is_exposed_in;
use dom::bindings::iterable::Iterable;
use dom::bindings::iterable::IteratorType;
use dom::bindings::mozmap::MozMap;
use dom::bindings::namespace::NamespaceObjectClass;
use dom::bindings::namespace::create_namespace_object;
use dom::bindings::num::Finite;
use dom::bindings::proxyhandler;
use dom::bindings::proxyhandler::ensure_expando_object;
use dom::bindings::proxyhandler::fill_property_descriptor;
use dom::bindings::proxyhandler::get_expando_object;
use dom::bindings::proxyhandler::get_property_descriptor;
use dom::bindings::reflector::DomObject;
use dom::bindings::reflector::MutDomObject;
use dom::bindings::root::Dom;
use dom::bindings::root::DomRoot;
use dom::bindings::root::OptionalHeapSetter;
use dom::bindings::root::RootedReference;
use dom::bindings::str::ByteString;
use dom::bindings::str::DOMString;
use dom::bindings::str::USVString;
use dom::bindings::trace::JSTraceable;
use dom::bindings::trace::RootedTraceable;
use dom::bindings::trace::RootedTraceableBox;
use dom::bindings::utils::AsVoidPtr;
use dom::bindings::utils::DOMClass;
use dom::bindings::utils::DOMJSClass;
use dom::bindings::utils::DOM_PROTO_UNFORGEABLE_HOLDER_SLOT;
use dom::bindings::utils::JSCLASS_DOM_GLOBAL;
use dom::bindings::utils::ProtoOrIfaceArray;
use dom::bindings::utils::enumerate_global;
use dom::bindings::utils::finalize_global;
use dom::bindings::utils::find_enum_value;
use dom::bindings::utils::generic_getter;
use dom::bindings::utils::generic_lenient_getter;
use dom::bindings::utils::generic_lenient_setter;
use dom::bindings::utils::generic_method;
use dom::bindings::utils::generic_setter;
use dom::bindings::utils::get_array_index_from_id;
use dom::bindings::utils::get_dictionary_property;
use dom::bindings::utils::get_property_on_prototype;
use dom::bindings::utils::get_proto_or_iface_array;
use dom::bindings::utils::has_property_on_prototype;
use dom::bindings::utils::is_platform_object;
use dom::bindings::utils::resolve_global;
use dom::bindings::utils::set_dictionary_property;
use dom::bindings::utils::trace_global;
use dom::bindings::weakref::DOM_WEAK_SLOT;
use dom::bindings::weakref::WeakBox;
use dom::bindings::weakref::WeakReferenceable;
use dom::globalscope::GlobalScope;
use dom::promise::Promise;
use dom::types::Blob;
use dom::types::Document;
use dom::types::Element;
use dom::types::Event;
use dom::types::EventTarget;
use dom::types::HTMLElement;
use dom::types::Node;
use dom::types::TestBinding;
use dom::types::URL;
use dom::windowproxy::WindowProxy;
use js;
use js::JSCLASS_GLOBAL_SLOT_COUNT;
use js::JSCLASS_IS_DOMJSCLASS;
use js::JSCLASS_IS_GLOBAL;
use js::JSCLASS_RESERVED_SLOTS_MASK;
use js::JS_CALLEE;
use js::error::throw_internal_error;
use js::error::throw_type_error;
use js::glue::AppendToAutoIdVector;
use js::glue::CallJitGetterOp;
use js::glue::CallJitMethodOp;
use js::glue::CallJitSetterOp;
use js::glue::CreateProxyHandler;
use js::glue::GetProxyPrivate;
use js::glue::ProxyTraps;
use js::glue::RUST_JSID_IS_INT;
use js::glue::RUST_JSID_IS_STRING;
use js::glue::RUST_SYMBOL_TO_JSID;
use js::glue::UnwrapObject;
use js::glue::int_to_jsid;
use js::jsapi::AutoIdVector;
use js::jsapi::CallArgs;
use js::jsapi::CurrentGlobalOrNull;
use js::jsapi::FreeOp;
use js::jsapi::GetWellKnownSymbol;
use js::jsapi::Handle as RawHandle;
use js::jsapi::HandleId as RawHandleId;
use js::jsapi::HandleObject as RawHandleObject;
use js::jsapi::HandleValue as RawHandleValue;
use js::jsapi::HandleValueArray;
use js::jsapi::Heap;
use js::jsapi::INTERNED_STRING_TO_JSID;
use js::jsapi::IsCallable;
use js::jsapi::JSAutoCompartment;
use js::jsapi::JSCLASS_RESERVED_SLOTS_SHIFT;
use js::jsapi::JSClass;
use js::jsapi::JSContext;
use js::jsapi::JSFreeOp;
use js::jsapi::JSFunctionSpec;
use js::jsapi::JSITER_HIDDEN;
use js::jsapi::JSITER_OWNONLY;
use js::jsapi::JSITER_SYMBOLS;
use js::jsapi::JSJitGetterCallArgs;
use js::jsapi::JSJitInfo;
use js::jsapi::JSJitInfo_AliasSet;
use js::jsapi::JSJitInfo_ArgType;
use js::jsapi::JSJitInfo_OpType;
use js::jsapi::JSJitMethodCallArgs;
use js::jsapi::JSJitSetterCallArgs;
use js::jsapi::JSNative;
use js::jsapi::JSNativeWrapper;
use js::jsapi::JSObject;
use js::jsapi::JSPROP_ENUMERATE;
use js::jsapi::JSPROP_PERMANENT;
use js::jsapi::JSPROP_READONLY;
use js::jsapi::JSPROP_SHARED;
use js::jsapi::JSPropertySpec;
use js::jsapi::JSString;
use js::jsapi::JSTracer;
use js::jsapi::JSType;
use js::jsapi::JSTypedMethodJitInfo;
use js::jsapi::JSValueType;
use js::jsapi::JS_AtomizeAndPinString;
use js::jsapi::JS_ForwardGetPropertyTo;
use js::jsapi::JS_GetErrorPrototype;
use js::jsapi::JS_GetGlobalForObject;
use js::jsapi::JS_GetIteratorPrototype;
use js::jsapi::JS_GetPropertyById;
use js::jsapi::JS_GetPropertyDescriptorById;
use js::jsapi::JS_GetReservedSlot;
use js::jsapi::JS_HasProperty;
use js::jsapi::JS_HasPropertyById;
use js::jsapi::JS_NewObject;
use js::jsapi::JS_SetReservedSlot;
use js::jsapi::MutableHandle as RawMutableHandle;
use js::jsapi::MutableHandleObject as RawMutableHandleObject;
use js::jsapi::MutableHandleValue as RawMutableHandleValue;
use js::jsapi::ObjectOpResult;
use js::jsapi::PropertyDescriptor;
use js::jsapi::Rooted;
use js::jsapi::RootedId;
use js::jsapi::RootedObject;
use js::jsapi::RootedString;
use js::jsapi::SymbolCode;
use js::jsapi::jsid;
use js::jsval::JSVal;
use js::jsval::NullValue;
use js::jsval::ObjectOrNullValue;
use js::jsval::ObjectValue;
use js::jsval::PrivateValue;
use js::jsval::UndefinedValue;
use js::panic::maybe_resume_unwind;
use js::panic::wrap_panic;
use js::rust::CustomAutoRooterGuard;
use js::rust::GCMethods;
use js::rust::Handle;
use js::rust::HandleId;
use js::rust::HandleObject;
use js::rust::HandleValue;
use js::rust::MutableHandle;
use js::rust::MutableHandleObject;
use js::rust::MutableHandleValue;
use js::rust::define_methods;
use js::rust::define_properties;
use js::rust::get_object_class;
use js::rust::wrappers::Call;
use js::rust::wrappers::GetPropertyKeys;
use js::rust::wrappers::JS_CallFunctionValue;
use js::rust::wrappers::JS_CopyPropertiesFrom;
use js::rust::wrappers::JS_DefineProperty;
use js::rust::wrappers::JS_DefinePropertyById2;
use js::rust::wrappers::JS_GetFunctionPrototype;
use js::rust::wrappers::JS_GetObjectPrototype;
use js::rust::wrappers::JS_GetProperty;
use js::rust::wrappers::JS_InitializePropertiesFromCompatibleNativeObject;
use js::rust::wrappers::JS_NewObjectWithGivenProto;
use js::rust::wrappers::JS_NewObjectWithoutMetadata;
use js::rust::wrappers::JS_ObjectIsDate;
use js::rust::wrappers::JS_SetImmutablePrototype;
use js::rust::wrappers::JS_SetProperty;
use js::rust::wrappers::JS_SetPrototype;
use js::rust::wrappers::JS_SplicePrototype;
use js::rust::wrappers::JS_WrapObject;
use js::rust::wrappers::JS_WrapValue;
use js::rust::wrappers::NewProxyObject;
use js::typedarray;
use libc;
use malloc_size_of::MallocSizeOfOps;
use mem::malloc_size_of_including_raw_self;
use servo_config::prefs::PREFS;
use std::borrow::ToOwned;
use std::cmp;
use std::default::Default;
use std::ffi::CString;
use std::mem;
use std::num;
use std::os;
use std::os::raw::c_void;
use std::panic;
use std::ptr;
use std::ptr::NonNull;
use std::rc;
use std::rc::Rc;
use std::str;
use typeholder::TypeHolderTrait;

unsafe extern fn get_booleanAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: bool = this.BooleanAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_booleanAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: bool = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetBooleanAttribute(arg0);

        return true;
    }), false);
}


fn booleanAttribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_booleanAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_BOOLEAN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn booleanAttribute_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_booleanAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_byteAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: i8 = this.ByteAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_byteAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: i8 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetByteAttribute(arg0);

        return true;
    }), false);
}


fn byteAttribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_byteAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn byteAttribute_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_byteAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_octetAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: u8 = this.OctetAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_octetAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: u8 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetOctetAttribute(arg0);

        return true;
    }), false);
}


fn octetAttribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_octetAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn octetAttribute_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_octetAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_shortAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: i16 = this.ShortAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_shortAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: i16 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetShortAttribute(arg0);

        return true;
    }), false);
}


fn shortAttribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_shortAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn shortAttribute_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_shortAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_unsignedShortAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: u16 = this.UnsignedShortAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_unsignedShortAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: u16 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetUnsignedShortAttribute(arg0);

        return true;
    }), false);
}


fn unsignedShortAttribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_unsignedShortAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn unsignedShortAttribute_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_unsignedShortAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_longAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: i32 = this.LongAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_longAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: i32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetLongAttribute(arg0);

        return true;
    }), false);
}


fn longAttribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_longAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn longAttribute_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_longAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_unsignedLongAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: u32 = this.UnsignedLongAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_unsignedLongAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetUnsignedLongAttribute(arg0);

        return true;
    }), false);
}


fn unsignedLongAttribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_unsignedLongAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn unsignedLongAttribute_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_unsignedLongAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_longLongAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: i64 = this.LongLongAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_longLongAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: i64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetLongLongAttribute(arg0);

        return true;
    }), false);
}


fn longLongAttribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_longLongAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn longLongAttribute_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_longLongAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_unsignedLongLongAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: u64 = this.UnsignedLongLongAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_unsignedLongLongAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: u64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetUnsignedLongLongAttribute(arg0);

        return true;
    }), false);
}


fn unsignedLongLongAttribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_unsignedLongLongAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn unsignedLongLongAttribute_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_unsignedLongLongAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_unrestrictedFloatAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f32 = this.UnrestrictedFloatAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_unrestrictedFloatAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetUnrestrictedFloatAttribute(arg0);

        return true;
    }), false);
}


fn unrestrictedFloatAttribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_unrestrictedFloatAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn unrestrictedFloatAttribute_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_unrestrictedFloatAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_floatAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Finite<f32> = this.FloatAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_floatAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Finite<f32> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetFloatAttribute(arg0);

        return true;
    }), false);
}


fn floatAttribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_floatAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn floatAttribute_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_floatAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_unrestrictedDoubleAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.UnrestrictedDoubleAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_unrestrictedDoubleAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetUnrestrictedDoubleAttribute(arg0);

        return true;
    }), false);
}


fn unrestrictedDoubleAttribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_unrestrictedDoubleAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn unrestrictedDoubleAttribute_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_unrestrictedDoubleAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_doubleAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Finite<f64> = this.DoubleAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_doubleAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Finite<f64> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetDoubleAttribute(arg0);

        return true;
    }), false);
}


fn doubleAttribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_doubleAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn doubleAttribute_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_doubleAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_stringAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DOMString = this.StringAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_stringAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetStringAttribute(arg0);

        return true;
    }), false);
}


fn stringAttribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_stringAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn stringAttribute_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_stringAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_usvstringAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: USVString = this.UsvstringAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_usvstringAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: USVString = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUsvstringAttribute(arg0);

        return true;
    }), false);
}


fn usvstringAttribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_usvstringAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn usvstringAttribute_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_usvstringAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_byteStringAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: ByteString = this.ByteStringAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_byteStringAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: ByteString = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetByteStringAttribute(arg0);

        return true;
    }), false);
}


fn byteStringAttribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_byteStringAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn byteStringAttribute_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_byteStringAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_enumAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: TestEnum = this.EnumAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_enumAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: TestEnum = match find_enum_value(cx, args.get(0), TestEnumValues::pairs) {
            Err(_) => { return false;
         },
            Ok((None, search)) => { return true; },
            Ok((Some(&value), _)) => value,
        };
        let result: () = this.SetEnumAttribute(arg0);

        return true;
    }), false);
}


fn enumAttribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_enumAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn enumAttribute_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_enumAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_interfaceAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<Blob<TH>> = this.InterfaceAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_interfaceAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DomRoot<Blob<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface Blob.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.SetInterfaceAttribute(&arg0);

        return true;
    }), false);
}


fn interfaceAttribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_interfaceAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn interfaceAttribute_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_interfaceAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_unionAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: UnionTypes::HTMLElementOrLong<TH> = this.UnionAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_unionAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: UnionTypes::HTMLElementOrLong<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUnionAttribute(arg0);

        return true;
    }), false);
}


fn unionAttribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_unionAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn unionAttribute_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_unionAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_union2Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: UnionTypes::EventOrString<TH> = this.Union2Attribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_union2Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: UnionTypes::EventOrString<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUnion2Attribute(arg0);

        return true;
    }), false);
}


fn union2Attribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_union2Attribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn union2Attribute_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_union2Attribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_union3Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: UnionTypes::EventOrUSVString<TH> = this.Union3Attribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_union3Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: UnionTypes::EventOrUSVString<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUnion3Attribute(arg0);

        return true;
    }), false);
}


fn union3Attribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_union3Attribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn union3Attribute_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_union3Attribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_union4Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: UnionTypes::StringOrUnsignedLong = this.Union4Attribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_union4Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: UnionTypes::StringOrUnsignedLong = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUnion4Attribute(arg0);

        return true;
    }), false);
}


fn union4Attribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_union4Attribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn union4Attribute_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_union4Attribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_union5Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: UnionTypes::StringOrBoolean = this.Union5Attribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_union5Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: UnionTypes::StringOrBoolean = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUnion5Attribute(arg0);

        return true;
    }), false);
}


fn union5Attribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_union5Attribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn union5Attribute_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_union5Attribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_union6Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: UnionTypes::UnsignedLongOrBoolean = this.Union6Attribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_union6Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: UnionTypes::UnsignedLongOrBoolean = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUnion6Attribute(arg0);

        return true;
    }), false);
}


fn union6Attribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_union6Attribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn union6Attribute_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_union6Attribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_union7Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: UnionTypes::BlobOrBoolean<TH> = this.Union7Attribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_union7Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: UnionTypes::BlobOrBoolean<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUnion7Attribute(arg0);

        return true;
    }), false);
}


fn union7Attribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_union7Attribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn union7Attribute_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_union7Attribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_union8Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: UnionTypes::BlobOrUnsignedLong<TH> = this.Union8Attribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_union8Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: UnionTypes::BlobOrUnsignedLong<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUnion8Attribute(arg0);

        return true;
    }), false);
}


fn union8Attribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_union8Attribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn union8Attribute_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_union8Attribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_union9Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: UnionTypes::ByteStringOrLong = this.Union9Attribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_union9Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: UnionTypes::ByteStringOrLong = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUnion9Attribute(arg0);

        return true;
    }), false);
}


fn union9Attribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_union9Attribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn union9Attribute_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_union9Attribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_arrayAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: NonNull<JSObject> = this.ArrayAttribute(cx);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn arrayAttribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_arrayAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_anyAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: JSVal = this.AnyAttribute(cx);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_anyAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: HandleValue = args.get(0);
        let result: () = this.SetAnyAttribute(cx, arg0);

        return true;
    }), false);
}


fn anyAttribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_anyAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn anyAttribute_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_anyAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_objectAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: NonNull<JSObject> = this.ObjectAttribute(cx);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_objectAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: *mut JSObject = if args.get(0).get().is_object() {
            args.get(0).get().to_object()
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.SetObjectAttribute(cx, arg0);

        return true;
    }), false);
}


fn objectAttribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_objectAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn objectAttribute_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_objectAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_booleanAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<bool> = this.GetBooleanAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_booleanAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<bool> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetBooleanAttributeNullable(arg0);

        return true;
    }), false);
}


fn booleanAttributeNullable_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_booleanAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn booleanAttributeNullable_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_booleanAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_byteAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<i8> = this.GetByteAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_byteAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<i8> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetByteAttributeNullable(arg0);

        return true;
    }), false);
}


fn byteAttributeNullable_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_byteAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn byteAttributeNullable_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_byteAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_octetAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<u8> = this.GetOctetAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_octetAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<u8> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetOctetAttributeNullable(arg0);

        return true;
    }), false);
}


fn octetAttributeNullable_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_octetAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn octetAttributeNullable_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_octetAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_shortAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<i16> = this.GetShortAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_shortAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<i16> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetShortAttributeNullable(arg0);

        return true;
    }), false);
}


fn shortAttributeNullable_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_shortAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn shortAttributeNullable_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_shortAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_unsignedShortAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<u16> = this.GetUnsignedShortAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_unsignedShortAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<u16> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetUnsignedShortAttributeNullable(arg0);

        return true;
    }), false);
}


fn unsignedShortAttributeNullable_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_unsignedShortAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn unsignedShortAttributeNullable_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_unsignedShortAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_longAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<i32> = this.GetLongAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_longAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<i32> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetLongAttributeNullable(arg0);

        return true;
    }), false);
}


fn longAttributeNullable_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_longAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn longAttributeNullable_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_longAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_unsignedLongAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<u32> = this.GetUnsignedLongAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_unsignedLongAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<u32> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetUnsignedLongAttributeNullable(arg0);

        return true;
    }), false);
}


fn unsignedLongAttributeNullable_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_unsignedLongAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn unsignedLongAttributeNullable_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_unsignedLongAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_longLongAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<i64> = this.GetLongLongAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_longLongAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<i64> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetLongLongAttributeNullable(arg0);

        return true;
    }), false);
}


fn longLongAttributeNullable_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_longLongAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn longLongAttributeNullable_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_longLongAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_unsignedLongLongAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<u64> = this.GetUnsignedLongLongAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_unsignedLongLongAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<u64> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetUnsignedLongLongAttributeNullable(arg0);

        return true;
    }), false);
}


fn unsignedLongLongAttributeNullable_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_unsignedLongLongAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn unsignedLongLongAttributeNullable_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_unsignedLongLongAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_unrestrictedFloatAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<f32> = this.GetUnrestrictedFloatAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_unrestrictedFloatAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<f32> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetUnrestrictedFloatAttributeNullable(arg0);

        return true;
    }), false);
}


fn unrestrictedFloatAttributeNullable_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_unrestrictedFloatAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn unrestrictedFloatAttributeNullable_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_unrestrictedFloatAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_floatAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Finite<f32>> = this.GetFloatAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_floatAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Finite<f32>> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetFloatAttributeNullable(arg0);

        return true;
    }), false);
}


fn floatAttributeNullable_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_floatAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn floatAttributeNullable_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_floatAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_unrestrictedDoubleAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<f64> = this.GetUnrestrictedDoubleAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_unrestrictedDoubleAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<f64> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetUnrestrictedDoubleAttributeNullable(arg0);

        return true;
    }), false);
}


fn unrestrictedDoubleAttributeNullable_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_unrestrictedDoubleAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn unrestrictedDoubleAttributeNullable_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_unrestrictedDoubleAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_doubleAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Finite<f64>> = this.GetDoubleAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_doubleAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Finite<f64>> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetDoubleAttributeNullable(arg0);

        return true;
    }), false);
}


fn doubleAttributeNullable_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_doubleAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn doubleAttributeNullable_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_doubleAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_stringAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DOMString> = this.GetStringAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_stringAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<DOMString> = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetStringAttributeNullable(arg0);

        return true;
    }), false);
}


fn stringAttributeNullable_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_stringAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn stringAttributeNullable_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_stringAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_usvstringAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<USVString> = this.GetUsvstringAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_usvstringAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<USVString> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUsvstringAttributeNullable(arg0);

        return true;
    }), false);
}


fn usvstringAttributeNullable_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_usvstringAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn usvstringAttributeNullable_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_usvstringAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_byteStringAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<ByteString> = this.GetByteStringAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_byteStringAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<ByteString> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetByteStringAttributeNullable(arg0);

        return true;
    }), false);
}


fn byteStringAttributeNullable_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_byteStringAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn byteStringAttributeNullable_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_byteStringAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_enumAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<TestEnum> = this.GetEnumAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn enumAttributeNullable_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_enumAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_interfaceAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DomRoot<Blob<TH>>> = this.GetInterfaceAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_interfaceAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<DomRoot<Blob<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface Blob.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.SetInterfaceAttributeNullable(arg0.r());

        return true;
    }), false);
}


fn interfaceAttributeNullable_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_interfaceAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn interfaceAttributeNullable_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_interfaceAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_interfaceAttributeWeak<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DomRoot<URL<TH>>> = this.GetInterfaceAttributeWeak();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_interfaceAttributeWeak<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<DomRoot<URL<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface URL.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.SetInterfaceAttributeWeak(arg0.r());

        return true;
    }), false);
}


fn interfaceAttributeWeak_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_interfaceAttributeWeak::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn interfaceAttributeWeak_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_interfaceAttributeWeak::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_objectAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<NonNull<JSObject>> = this.GetObjectAttributeNullable(cx);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_objectAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: *mut JSObject = if args.get(0).get().is_object() {
            args.get(0).get().to_object()
        } else if args.get(0).get().is_null_or_undefined() {
            ptr::null_mut()
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.SetObjectAttributeNullable(cx, arg0);

        return true;
    }), false);
}


fn objectAttributeNullable_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_objectAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn objectAttributeNullable_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_objectAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_unionAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<UnionTypes::HTMLElementOrLong<TH>> = this.GetUnionAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_unionAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<UnionTypes::HTMLElementOrLong<TH>> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUnionAttributeNullable(arg0);

        return true;
    }), false);
}


fn unionAttributeNullable_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_unionAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn unionAttributeNullable_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_unionAttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_union2AttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<UnionTypes::EventOrString<TH>> = this.GetUnion2AttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_union2AttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<UnionTypes::EventOrString<TH>> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUnion2AttributeNullable(arg0);

        return true;
    }), false);
}


fn union2AttributeNullable_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_union2AttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn union2AttributeNullable_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_union2AttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_union3AttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<UnionTypes::BlobOrBoolean<TH>> = this.GetUnion3AttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_union3AttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<UnionTypes::BlobOrBoolean<TH>> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUnion3AttributeNullable(arg0);

        return true;
    }), false);
}


fn union3AttributeNullable_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_union3AttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn union3AttributeNullable_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_union3AttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_union4AttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<UnionTypes::UnsignedLongOrBoolean> = this.GetUnion4AttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_union4AttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<UnionTypes::UnsignedLongOrBoolean> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUnion4AttributeNullable(arg0);

        return true;
    }), false);
}


fn union4AttributeNullable_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_union4AttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn union4AttributeNullable_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_union4AttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_union5AttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<UnionTypes::StringOrBoolean> = this.GetUnion5AttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_union5AttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<UnionTypes::StringOrBoolean> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUnion5AttributeNullable(arg0);

        return true;
    }), false);
}


fn union5AttributeNullable_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_union5AttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn union5AttributeNullable_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_union5AttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_union6AttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<UnionTypes::ByteStringOrLong> = this.GetUnion6AttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_union6AttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<UnionTypes::ByteStringOrLong> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUnion6AttributeNullable(arg0);

        return true;
    }), false);
}


fn union6AttributeNullable_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_union6AttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn union6AttributeNullable_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_union6AttributeNullable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_attrToBinaryRename<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DOMString = this.BinaryRenamedAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_attrToBinaryRename<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetBinaryRenamedAttribute(arg0);

        return true;
    }), false);
}


fn attrToBinaryRename_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_attrToBinaryRename::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn attrToBinaryRename_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_attrToBinaryRename::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_attr_to_binary_rename<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DOMString = this.BinaryRenamedAttribute2();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_attr_to_binary_rename<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetBinaryRenamedAttribute2(arg0);

        return true;
    }), false);
}


fn attr_to_binary_rename_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_attr_to_binary_rename::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn attr_to_binary_rename_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_attr_to_binary_rename::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_attr_to_automatically_rename<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DOMString = this.Attr_to_automatically_rename();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_attr_to_automatically_rename<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetAttr_to_automatically_rename(arg0);

        return true;
    }), false);
}


fn attr_to_automatically_rename_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_attr_to_automatically_rename::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn attr_to_automatically_rename_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_attr_to_automatically_rename::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_forwardedAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<TestBinding<TH>> = this.ForwardedAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_forwardedAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        rooted!(in(cx) let mut v = UndefinedValue());
        if !JS_GetProperty(cx, obj, b"forwardedAttribute\0" as *const u8 as *const libc::c_char, v.handle_mut()) {
            return false;
        }
        if !v.is_object() {
            throw_type_error(cx, "Value.forwardedAttribute is not an object.");
            return false;
        }
        rooted!(in(cx) let target_obj = v.to_object());
        JS_SetProperty(cx, target_obj.handle(), b"booleanAttribute\0" as *const u8 as *const libc::c_char, args.get(0))

    }), false);
}


fn forwardedAttribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_forwardedAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn forwardedAttribute_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_forwardedAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn methToBinaryRename<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.BinaryRenamedMethod();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn methToBinaryRename_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: methToBinaryRename::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveVoid<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.ReceiveVoid();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveVoid_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveVoid::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveBoolean<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: bool = this.ReceiveBoolean();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveBoolean_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveBoolean::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_BOOLEAN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveByte<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: i8 = this.ReceiveByte();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveByte_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveByte::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveOctet<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: u8 = this.ReceiveOctet();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveOctet_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveOctet::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveShort<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: i16 = this.ReceiveShort();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveShort_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveShort::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveUnsignedShort<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: u16 = this.ReceiveUnsignedShort();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveUnsignedShort_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveUnsignedShort::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: i32 = this.ReceiveLong();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveLong_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveLong::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveUnsignedLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: u32 = this.ReceiveUnsignedLong();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveUnsignedLong_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveUnsignedLong::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveLongLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: i64 = this.ReceiveLongLong();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveLongLong_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveLongLong::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveUnsignedLongLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: u64 = this.ReceiveUnsignedLongLong();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveUnsignedLongLong_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveUnsignedLongLong::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveUnrestrictedFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: f32 = this.ReceiveUnrestrictedFloat();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveUnrestrictedFloat_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveUnrestrictedFloat::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Finite<f32> = this.ReceiveFloat();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveFloat_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveFloat::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveUnrestrictedDouble<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: f64 = this.ReceiveUnrestrictedDouble();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveUnrestrictedDouble_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveUnrestrictedDouble::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveDouble<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Finite<f64> = this.ReceiveDouble();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveDouble_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveDouble::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveString<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: DOMString = this.ReceiveString();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveString_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveString::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveUsvstring<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: USVString = this.ReceiveUsvstring();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveUsvstring_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveUsvstring::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveByteString<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: ByteString = this.ReceiveByteString();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveByteString_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveByteString::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveEnum<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: TestEnum = this.ReceiveEnum();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveEnum_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveEnum::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: DomRoot<Blob<TH>> = this.ReceiveInterface();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveInterface_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveInterface::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveAny<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: JSVal = this.ReceiveAny(cx);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveAny_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveAny::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveObject<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: NonNull<JSObject> = this.ReceiveObject(cx);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveObject_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveObject::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveUnion<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: UnionTypes::HTMLElementOrLong<TH> = this.ReceiveUnion();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveUnion_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveUnion::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveUnion2<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: UnionTypes::EventOrString<TH> = this.ReceiveUnion2();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveUnion2_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveUnion2::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveUnion3<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: UnionTypes::StringOrLongSequence = this.ReceiveUnion3();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveUnion3_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveUnion3::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveUnion4<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: UnionTypes::StringOrStringSequence = this.ReceiveUnion4();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveUnion4_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveUnion4::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveUnion5<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: UnionTypes::BlobOrBlobSequence<TH> = this.ReceiveUnion5();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveUnion5_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveUnion5::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveUnion6<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: UnionTypes::StringOrUnsignedLong = this.ReceiveUnion6();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveUnion6_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveUnion6::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveUnion7<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: UnionTypes::StringOrBoolean = this.ReceiveUnion7();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveUnion7_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveUnion7::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveUnion8<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: UnionTypes::UnsignedLongOrBoolean = this.ReceiveUnion8();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveUnion8_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveUnion8::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveUnion9<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: UnionTypes::HTMLElementOrUnsignedLongOrStringOrBoolean<TH> = this.ReceiveUnion9();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveUnion9_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveUnion9::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveUnion10<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: UnionTypes::ByteStringOrLong = this.ReceiveUnion10();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveUnion10_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveUnion10::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveUnion11<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: UnionTypes::ByteStringSequenceOrLongOrString = this.ReceiveUnion11();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveUnion11_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveUnion11::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveSequence<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Vec<i32> = this.ReceiveSequence();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveSequence_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveSequence::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveInterfaceSequence<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Vec<DomRoot<Blob<TH>>> = this.ReceiveInterfaceSequence();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveInterfaceSequence_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveInterfaceSequence::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveNullableByte<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<i8> = this.ReceiveNullableByte();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveNullableByte_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveNullableByte::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveNullableBoolean<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<bool> = this.ReceiveNullableBoolean();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveNullableBoolean_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveNullableBoolean::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveNullableOctet<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<u8> = this.ReceiveNullableOctet();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveNullableOctet_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveNullableOctet::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveNullableShort<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<i16> = this.ReceiveNullableShort();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveNullableShort_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveNullableShort::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveNullableUnsignedShort<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<u16> = this.ReceiveNullableUnsignedShort();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveNullableUnsignedShort_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveNullableUnsignedShort::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveNullableLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<i32> = this.ReceiveNullableLong();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveNullableLong_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveNullableLong::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveNullableUnsignedLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<u32> = this.ReceiveNullableUnsignedLong();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveNullableUnsignedLong_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveNullableUnsignedLong::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveNullableLongLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<i64> = this.ReceiveNullableLongLong();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveNullableLongLong_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveNullableLongLong::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveNullableUnsignedLongLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<u64> = this.ReceiveNullableUnsignedLongLong();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveNullableUnsignedLongLong_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveNullableUnsignedLongLong::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveNullableUnrestrictedFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<f32> = this.ReceiveNullableUnrestrictedFloat();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveNullableUnrestrictedFloat_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveNullableUnrestrictedFloat::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveNullableFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<Finite<f32>> = this.ReceiveNullableFloat();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveNullableFloat_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveNullableFloat::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveNullableUnrestrictedDouble<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<f64> = this.ReceiveNullableUnrestrictedDouble();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveNullableUnrestrictedDouble_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveNullableUnrestrictedDouble::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveNullableDouble<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<Finite<f64>> = this.ReceiveNullableDouble();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveNullableDouble_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveNullableDouble::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveNullableString<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<DOMString> = this.ReceiveNullableString();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveNullableString_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveNullableString::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveNullableUsvstring<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<USVString> = this.ReceiveNullableUsvstring();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveNullableUsvstring_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveNullableUsvstring::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveNullableByteString<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<ByteString> = this.ReceiveNullableByteString();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveNullableByteString_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveNullableByteString::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveNullableEnum<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<TestEnum> = this.ReceiveNullableEnum();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveNullableEnum_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveNullableEnum::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveNullableInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<DomRoot<Blob<TH>>> = this.ReceiveNullableInterface();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveNullableInterface_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveNullableInterface::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveNullableObject<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<NonNull<JSObject>> = this.ReceiveNullableObject(cx);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveNullableObject_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveNullableObject::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveNullableUnion<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<UnionTypes::HTMLElementOrLong<TH>> = this.ReceiveNullableUnion();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveNullableUnion_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveNullableUnion::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveNullableUnion2<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<UnionTypes::EventOrString<TH>> = this.ReceiveNullableUnion2();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveNullableUnion2_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveNullableUnion2::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveNullableUnion3<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<UnionTypes::StringOrLongSequence> = this.ReceiveNullableUnion3();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveNullableUnion3_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveNullableUnion3::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveNullableUnion4<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<UnionTypes::LongSequenceOrBoolean> = this.ReceiveNullableUnion4();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveNullableUnion4_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveNullableUnion4::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveNullableUnion5<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<UnionTypes::UnsignedLongOrBoolean> = this.ReceiveNullableUnion5();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveNullableUnion5_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveNullableUnion5::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveNullableUnion6<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<UnionTypes::ByteStringOrLong> = this.ReceiveNullableUnion6();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveNullableUnion6_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveNullableUnion6::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveNullableSequence<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<Vec<i32>> = this.ReceiveNullableSequence();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveNullableSequence_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveNullableSequence::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveTestDictionaryWithSuccessOnKeyword<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: RootedTraceableBox<TestDictionary<TH>> = this.ReceiveTestDictionaryWithSuccessOnKeyword();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveTestDictionaryWithSuccessOnKeyword_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveTestDictionaryWithSuccessOnKeyword::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn dictMatchesPassedValues<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.dictMatchesPassedValues\".");
            return false;
        }
        let arg0: RootedTraceableBox<dom::bindings::codegen::Bindings::TestBindingBinding::TestDictionary<TH>> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(dictionary)) => dictionary,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: bool = this.DictMatchesPassedValues(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn dictMatchesPassedValues_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: dictMatchesPassedValues::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_BOOLEAN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveUnionIdentity<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.receiveUnionIdentity\".");
            return false;
        }
        let arg0: UnionTypes::StringOrObject = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: UnionTypes::StringOrObject = this.ReceiveUnionIdentity(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveUnionIdentity_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveUnionIdentity::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passBoolean<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passBoolean\".");
            return false;
        }
        let arg0: bool = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassBoolean(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passBoolean_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passBoolean::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passByte<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passByte\".");
            return false;
        }
        let arg0: i8 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassByte(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passByte_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passByte::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOctet<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passOctet\".");
            return false;
        }
        let arg0: u8 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassOctet(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOctet_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOctet::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passShort<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passShort\".");
            return false;
        }
        let arg0: i16 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassShort(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passShort_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passShort::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passUnsignedShort<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnsignedShort\".");
            return false;
        }
        let arg0: u16 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassUnsignedShort(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passUnsignedShort_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passUnsignedShort::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passLong\".");
            return false;
        }
        let arg0: i32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passLong_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passLong::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passUnsignedLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnsignedLong\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassUnsignedLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passUnsignedLong_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passUnsignedLong::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passLongLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passLongLong\".");
            return false;
        }
        let arg0: i64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassLongLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passLongLong_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passLongLong::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passUnsignedLongLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnsignedLongLong\".");
            return false;
        }
        let arg0: u64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassUnsignedLongLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passUnsignedLongLong_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passUnsignedLongLong::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passUnrestrictedFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnrestrictedFloat\".");
            return false;
        }
        let arg0: f32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassUnrestrictedFloat(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passUnrestrictedFloat_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passUnrestrictedFloat::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passFloat\".");
            return false;
        }
        let arg0: Finite<f32> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassFloat(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passFloat_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passFloat::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passUnrestrictedDouble<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnrestrictedDouble\".");
            return false;
        }
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassUnrestrictedDouble(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passUnrestrictedDouble_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passUnrestrictedDouble::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passDouble<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passDouble\".");
            return false;
        }
        let arg0: Finite<f64> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassDouble(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passDouble_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passDouble::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passString<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passString\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassString(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passString_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passString::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passUsvstring<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUsvstring\".");
            return false;
        }
        let arg0: USVString = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassUsvstring(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passUsvstring_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passUsvstring::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passByteString<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passByteString\".");
            return false;
        }
        let arg0: ByteString = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassByteString(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passByteString_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passByteString::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passEnum<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passEnum\".");
            return false;
        }
        let arg0: TestEnum = match find_enum_value(cx, args.get(0), TestEnumValues::pairs) {
            Err(_) => { return false;
         },
            Ok((None, search)) => { throw_type_error(cx, &format!("'{}' is not a valid enum value for enumeration 'TestEnum'.", search)); return false;
         },
            Ok((Some(&value), _)) => value,
        };
        let result: () = this.PassEnum(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passEnum_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passEnum::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passInterface\".");
            return false;
        }
        let arg0: DomRoot<Blob<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface Blob.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.PassInterface(&arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passInterface_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passInterface::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passTypedArray<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passTypedArray\".");
            return false;
        }
        let arg0: typedarray::Int8Array = if args.get(0).get().is_object() {
            match typedarray::Int8Array::from(args.get(0).get().to_object()) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value is not a typed array.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        auto_root!(in(cx) let arg0 = arg0);
        let result: () = this.PassTypedArray(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passTypedArray_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passTypedArray::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passTypedArray2<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passTypedArray2\".");
            return false;
        }
        let arg0: typedarray::ArrayBuffer = if args.get(0).get().is_object() {
            match typedarray::ArrayBuffer::from(args.get(0).get().to_object()) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value is not a typed array.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        auto_root!(in(cx) let arg0 = arg0);
        let result: () = this.PassTypedArray2(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passTypedArray2_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passTypedArray2::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passTypedArray3<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passTypedArray3\".");
            return false;
        }
        let arg0: typedarray::ArrayBufferView = if args.get(0).get().is_object() {
            match typedarray::ArrayBufferView::from(args.get(0).get().to_object()) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value is not a typed array.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        auto_root!(in(cx) let arg0 = arg0);
        let result: () = this.PassTypedArray3(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passTypedArray3_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passTypedArray3::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passUnion<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnion\".");
            return false;
        }
        let arg0: UnionTypes::HTMLElementOrLong<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassUnion(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passUnion_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passUnion::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passUnion2<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnion2\".");
            return false;
        }
        let arg0: UnionTypes::EventOrString<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassUnion2(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passUnion2_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passUnion2::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passUnion3<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnion3\".");
            return false;
        }
        let arg0: UnionTypes::BlobOrString<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassUnion3(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passUnion3_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passUnion3::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passUnion4<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnion4\".");
            return false;
        }
        let arg0: UnionTypes::StringOrStringSequence = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassUnion4(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passUnion4_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passUnion4::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passUnion5<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnion5\".");
            return false;
        }
        let arg0: UnionTypes::StringOrBoolean = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassUnion5(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passUnion5_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passUnion5::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passUnion6<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnion6\".");
            return false;
        }
        let arg0: UnionTypes::UnsignedLongOrBoolean = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassUnion6(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passUnion6_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passUnion6::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passUnion7<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnion7\".");
            return false;
        }
        let arg0: UnionTypes::StringSequenceOrUnsignedLong = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassUnion7(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passUnion7_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passUnion7::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passUnion8<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnion8\".");
            return false;
        }
        let arg0: UnionTypes::ByteStringSequenceOrLong = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassUnion8(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passUnion8_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passUnion8::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passUnion9<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnion9\".");
            return false;
        }
        let arg0: UnionTypes::TestDictionaryOrLong<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassUnion9(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passUnion9_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passUnion9::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passUnion10<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnion10\".");
            return false;
        }
        let arg0: UnionTypes::StringOrObject = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassUnion10(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passUnion10_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passUnion10::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passUnion11<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnion11\".");
            return false;
        }
        let arg0: UnionTypes::ArrayBufferOrArrayBufferView = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassUnion11(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passUnion11_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passUnion11::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passUnionWithTypedef<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnionWithTypedef\".");
            return false;
        }
        let arg0: UnionTypes::DocumentOrTestTypedef<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassUnionWithTypedef(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passUnionWithTypedef_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passUnionWithTypedef::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passUnionWithTypedef2<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnionWithTypedef2\".");
            return false;
        }
        let arg0: UnionTypes::LongSequenceOrTestTypedef<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassUnionWithTypedef2(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passUnionWithTypedef2_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passUnionWithTypedef2::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passAny<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passAny\".");
            return false;
        }
        let arg0: HandleValue = args.get(0);
        let result: () = this.PassAny(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passAny_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passAny::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passObject<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passObject\".");
            return false;
        }
        let arg0: *mut JSObject = if args.get(0).get().is_object() {
            args.get(0).get().to_object()
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.PassObject(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passObject_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passObject::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passCallbackFunction<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passCallbackFunction\".");
            return false;
        }
        let arg0: Rc<Function<TH>> = if args.get(0).get().is_object() {
            if IsCallable(args.get(0).get().to_object()) {
                Function::new(cx, args.get(0).get().to_object())
            } else {
                throw_type_error(cx, "Value is not callable.");
                return false;

            }
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.PassCallbackFunction(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passCallbackFunction_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passCallbackFunction::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passCallbackInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passCallbackInterface\".");
            return false;
        }
        let arg0: Rc<dom::bindings::codegen::Bindings::EventListenerBinding::EventListener<TH>> = dom::bindings::codegen::Bindings::EventListenerBinding::EventListener::new(cx, args.get(0).get().to_object());
        let result: () = this.PassCallbackInterface(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passCallbackInterface_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passCallbackInterface::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passSequence<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passSequence\".");
            return false;
        }
        let arg0: Vec<i32> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassSequence(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passSequence_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passSequence::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passAnySequence<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passAnySequence\".");
            return false;
        }
        let arg0: Vec<JSVal> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        auto_root!(in(cx) let arg0 = arg0);
        let result: () = this.PassAnySequence(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passAnySequence_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passAnySequence::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn anySequencePassthrough<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.anySequencePassthrough\".");
            return false;
        }
        let arg0: Vec<JSVal> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        auto_root!(in(cx) let arg0 = arg0);
        let result: Vec<JSVal> = this.AnySequencePassthrough(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn anySequencePassthrough_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: anySequencePassthrough::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passObjectSequence<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passObjectSequence\".");
            return false;
        }
        let arg0: Vec<*mut JSObject> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        auto_root!(in(cx) let arg0 = arg0);
        let result: () = this.PassObjectSequence(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passObjectSequence_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passObjectSequence::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passStringSequence<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passStringSequence\".");
            return false;
        }
        let arg0: Vec<DOMString> = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassStringSequence(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passStringSequence_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passStringSequence::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passInterfaceSequence<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passInterfaceSequence\".");
            return false;
        }
        let arg0: Vec<DomRoot<Blob<TH>>> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassInterfaceSequence(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passInterfaceSequence_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passInterfaceSequence::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOverloaded<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        let argcount = cmp::min(argc, 1);
        match argcount {
            1 => {
                if args.get(0).get().is_object() {
                    loop {
                    let arg0: typedarray::ArrayBuffer = match typedarray::ArrayBuffer::from(args.get(0).get().to_object()) {
                        Ok(val) => val,
                        Err(()) => {
                            break;
                        }
                    }
                    ;
                    auto_root!(in(cx) let arg0 = arg0);
                    let result: () = this.PassOverloaded(arg0);

                    (result).to_jsval(cx, args.rval());
                    return true;
                    }
                }
                let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
                    Ok(ConversionResult::Success(strval)) => strval,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                let result: () = this.PassOverloaded_(arg0);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            _ => {
                throw_type_error(cx, "Not enough arguments to \"TestBinding.passOverloaded\".");
                return false;
            }
        }
    }), false);
}


fn passOverloaded_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOverloaded::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passNullableBoolean<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableBoolean\".");
            return false;
        }
        let arg0: Option<bool> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassNullableBoolean(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passNullableBoolean_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passNullableBoolean::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passNullableByte<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableByte\".");
            return false;
        }
        let arg0: Option<i8> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassNullableByte(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passNullableByte_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passNullableByte::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passNullableOctet<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableOctet\".");
            return false;
        }
        let arg0: Option<u8> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassNullableOctet(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passNullableOctet_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passNullableOctet::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passNullableShort<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableShort\".");
            return false;
        }
        let arg0: Option<i16> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassNullableShort(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passNullableShort_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passNullableShort::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passNullableUnsignedShort<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableUnsignedShort\".");
            return false;
        }
        let arg0: Option<u16> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassNullableUnsignedShort(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passNullableUnsignedShort_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passNullableUnsignedShort::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passNullableLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableLong\".");
            return false;
        }
        let arg0: Option<i32> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassNullableLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passNullableLong_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passNullableLong::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passNullableUnsignedLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableUnsignedLong\".");
            return false;
        }
        let arg0: Option<u32> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassNullableUnsignedLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passNullableUnsignedLong_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passNullableUnsignedLong::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passNullableLongLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableLongLong\".");
            return false;
        }
        let arg0: Option<i64> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassNullableLongLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passNullableLongLong_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passNullableLongLong::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passNullableUnsignedLongLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableUnsignedLongLong\".");
            return false;
        }
        let arg0: Option<u64> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassNullableUnsignedLongLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passNullableUnsignedLongLong_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passNullableUnsignedLongLong::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passNullableUnrestrictedFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableUnrestrictedFloat\".");
            return false;
        }
        let arg0: Option<f32> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassNullableUnrestrictedFloat(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passNullableUnrestrictedFloat_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passNullableUnrestrictedFloat::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passNullableFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableFloat\".");
            return false;
        }
        let arg0: Option<Finite<f32>> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassNullableFloat(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passNullableFloat_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passNullableFloat::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passNullableUnrestrictedDouble<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableUnrestrictedDouble\".");
            return false;
        }
        let arg0: Option<f64> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassNullableUnrestrictedDouble(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passNullableUnrestrictedDouble_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passNullableUnrestrictedDouble::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passNullableDouble<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableDouble\".");
            return false;
        }
        let arg0: Option<Finite<f64>> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassNullableDouble(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passNullableDouble_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passNullableDouble::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passNullableString<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableString\".");
            return false;
        }
        let arg0: Option<DOMString> = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassNullableString(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passNullableString_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passNullableString::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passNullableUsvstring<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableUsvstring\".");
            return false;
        }
        let arg0: Option<USVString> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassNullableUsvstring(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passNullableUsvstring_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passNullableUsvstring::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passNullableByteString<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableByteString\".");
            return false;
        }
        let arg0: Option<ByteString> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassNullableByteString(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passNullableByteString_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passNullableByteString::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passNullableInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableInterface\".");
            return false;
        }
        let arg0: Option<DomRoot<Blob<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface Blob.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.PassNullableInterface(arg0.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passNullableInterface_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passNullableInterface::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passNullableObject<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableObject\".");
            return false;
        }
        let arg0: *mut JSObject = if args.get(0).get().is_object() {
            args.get(0).get().to_object()
        } else if args.get(0).get().is_null_or_undefined() {
            ptr::null_mut()
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.PassNullableObject(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passNullableObject_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passNullableObject::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passNullableTypedArray<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableTypedArray\".");
            return false;
        }
        let arg0: Option<typedarray::Int8Array> = if args.get(0).get().is_object() {
            Some(match typedarray::Int8Array::from(args.get(0).get().to_object()) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value is not a typed array.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        auto_root!(in(cx) let arg0 = arg0);
        let result: () = this.PassNullableTypedArray(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passNullableTypedArray_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passNullableTypedArray::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passNullableUnion<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableUnion\".");
            return false;
        }
        let arg0: Option<UnionTypes::HTMLElementOrLong<TH>> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassNullableUnion(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passNullableUnion_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passNullableUnion::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passNullableUnion2<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableUnion2\".");
            return false;
        }
        let arg0: Option<UnionTypes::EventOrString<TH>> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassNullableUnion2(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passNullableUnion2_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passNullableUnion2::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passNullableUnion3<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableUnion3\".");
            return false;
        }
        let arg0: Option<UnionTypes::StringOrLongSequence> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassNullableUnion3(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passNullableUnion3_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passNullableUnion3::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passNullableUnion4<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableUnion4\".");
            return false;
        }
        let arg0: Option<UnionTypes::LongSequenceOrBoolean> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassNullableUnion4(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passNullableUnion4_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passNullableUnion4::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passNullableUnion5<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableUnion5\".");
            return false;
        }
        let arg0: Option<UnionTypes::UnsignedLongOrBoolean> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassNullableUnion5(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passNullableUnion5_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passNullableUnion5::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passNullableUnion6<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableUnion6\".");
            return false;
        }
        let arg0: Option<UnionTypes::ByteStringOrLong> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassNullableUnion6(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passNullableUnion6_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passNullableUnion6::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passNullableCallbackFunction<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableCallbackFunction\".");
            return false;
        }
        let arg0: Option<Rc<Function<TH>>> = if args.get(0).get().is_object() {
            if IsCallable(args.get(0).get().to_object()) {
                Some(Function::new(cx, args.get(0).get().to_object()))
            } else {
                throw_type_error(cx, "Value is not callable.");
                return false;

            }
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.PassNullableCallbackFunction(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passNullableCallbackFunction_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passNullableCallbackFunction::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passNullableCallbackInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableCallbackInterface\".");
            return false;
        }
        let arg0: Option<Rc<dom::bindings::codegen::Bindings::EventListenerBinding::EventListener<TH>>> = if args.get(0).get().is_object() {
            Some(dom::bindings::codegen::Bindings::EventListenerBinding::EventListener::new(cx, args.get(0).get().to_object()))
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.PassNullableCallbackInterface(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passNullableCallbackInterface_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passNullableCallbackInterface::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passNullableSequence<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableSequence\".");
            return false;
        }
        let arg0: Option<Vec<i32> > = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassNullableSequence(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passNullableSequence_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passNullableSequence::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalBoolean<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<bool> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalBoolean(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalBoolean_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalBoolean::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalByte<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<i8> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalByte(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalByte_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalByte::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalOctet<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<u8> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalOctet(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalOctet_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalOctet::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalShort<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<i16> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalShort(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalShort_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalShort::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalUnsignedShort<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<u16> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalUnsignedShort(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalUnsignedShort_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalUnsignedShort::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<i32> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalLong_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalLong::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalUnsignedLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<u32> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalUnsignedLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalUnsignedLong_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalUnsignedLong::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalLongLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<i64> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalLongLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalLongLong_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalLongLong::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalUnsignedLongLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<u64> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalUnsignedLongLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalUnsignedLongLong_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalUnsignedLongLong::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalUnrestrictedFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<f32> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalUnrestrictedFloat(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalUnrestrictedFloat_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalUnrestrictedFloat::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Finite<f32>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalFloat(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalFloat_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalFloat::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalUnrestrictedDouble<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<f64> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalUnrestrictedDouble(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalUnrestrictedDouble_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalUnrestrictedDouble::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalDouble<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Finite<f64>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalDouble(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalDouble_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalDouble::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalString<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<DOMString> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalString(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalString_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalString::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalUsvstring<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<USVString> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalUsvstring(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalUsvstring_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalUsvstring::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalByteString<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<ByteString> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalByteString(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalByteString_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalByteString::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalEnum<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<TestEnum> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match find_enum_value(cx, args.get(0), TestEnumValues::pairs) {
                Err(_) => { return false;
             },
                Ok((None, search)) => { throw_type_error(cx, &format!("'{}' is not a valid enum value for enumeration 'TestEnum'.", search)); return false;
             },
                Ok((Some(&value), _)) => value,
            })
        };
        let result: () = this.PassOptionalEnum(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalEnum_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalEnum::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<DomRoot<Blob<TH>>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(if args.get(0).get().is_object() {
                match root_from_handlevalue(args.get(0)) {
                    Ok(val) => val,
                    Err(()) => {
                        throw_type_error(cx, "value does not implement interface Blob.");
                        return false;

                    }
                }

            } else {
                throw_type_error(cx, "Value is not an object.");
                return false;

            })
        };
        let result: () = this.PassOptionalInterface(arg0.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalInterface_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalInterface::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalUnion<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<UnionTypes::HTMLElementOrLong<TH>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalUnion(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalUnion_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalUnion::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalUnion2<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<UnionTypes::EventOrString<TH>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalUnion2(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalUnion2_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalUnion2::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalUnion3<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<UnionTypes::StringOrLongSequence> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalUnion3(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalUnion3_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalUnion3::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalUnion4<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<UnionTypes::LongSequenceOrBoolean> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalUnion4(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalUnion4_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalUnion4::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalUnion5<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<UnionTypes::UnsignedLongOrBoolean> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalUnion5(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalUnion5_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalUnion5::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalUnion6<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<UnionTypes::ByteStringOrLong> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalUnion6(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalUnion6_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalUnion6::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalAny<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: HandleValue = if args.get(0).is_undefined() {
            HandleValue::undefined()
        } else {
            args.get(0)
        };
        let result: () = this.PassOptionalAny(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalAny_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalAny::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalObject<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<*mut JSObject> = if args.get(0).is_undefined() {
            None
        } else {
            Some(if args.get(0).get().is_object() {
                args.get(0).get().to_object()
            } else {
                throw_type_error(cx, "Value is not an object.");
                return false;

            })
        };
        let result: () = this.PassOptionalObject(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalObject_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalObject::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalCallbackFunction<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Rc<Function<TH>>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(if args.get(0).get().is_object() {
                if IsCallable(args.get(0).get().to_object()) {
                    Function::new(cx, args.get(0).get().to_object())
                } else {
                    throw_type_error(cx, "Value is not callable.");
                    return false;

                }
            } else {
                throw_type_error(cx, "Value is not an object.");
                return false;

            })
        };
        let result: () = this.PassOptionalCallbackFunction(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalCallbackFunction_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalCallbackFunction::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalCallbackInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Rc<dom::bindings::codegen::Bindings::EventListenerBinding::EventListener<TH>>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(dom::bindings::codegen::Bindings::EventListenerBinding::EventListener::new(cx, args.get(0).get().to_object()))
        };
        let result: () = this.PassOptionalCallbackInterface(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalCallbackInterface_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalCallbackInterface::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalSequence<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Vec<i32>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalSequence(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalSequence_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalSequence::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableBoolean<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<bool>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalNullableBoolean(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableBoolean_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableBoolean::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableByte<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<i8>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalNullableByte(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableByte_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableByte::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableOctet<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<u8>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalNullableOctet(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableOctet_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableOctet::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableShort<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<i16>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalNullableShort(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableShort_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableShort::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableUnsignedShort<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<u16>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalNullableUnsignedShort(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableUnsignedShort_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableUnsignedShort::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<i32>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalNullableLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableLong_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableLong::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableUnsignedLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<u32>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalNullableUnsignedLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableUnsignedLong_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableUnsignedLong::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableLongLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<i64>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalNullableLongLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableLongLong_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableLongLong::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableUnsignedLongLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<u64>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalNullableUnsignedLongLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableUnsignedLongLong_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableUnsignedLongLong::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableUnrestrictedFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<f32>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalNullableUnrestrictedFloat(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableUnrestrictedFloat_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableUnrestrictedFloat::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<Finite<f32>>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalNullableFloat(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableFloat_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableFloat::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableUnrestrictedDouble<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<f64>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalNullableUnrestrictedDouble(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableUnrestrictedDouble_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableUnrestrictedDouble::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableDouble<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<Finite<f64>>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalNullableDouble(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableDouble_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableDouble::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableString<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<DOMString>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalNullableString(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableString_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableString::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableUsvstring<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<USVString>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalNullableUsvstring(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableUsvstring_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableUsvstring::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableByteString<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<ByteString>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalNullableByteString(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableByteString_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableByteString::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<DomRoot<Blob<TH>>>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(if args.get(0).get().is_object() {
                Some(match root_from_handlevalue(args.get(0)) {
                    Ok(val) => val,
                    Err(()) => {
                        throw_type_error(cx, "value does not implement interface Blob.");
                        return false;

                    }
                }
                )
            } else if args.get(0).get().is_null_or_undefined() {
                None
            } else {
                throw_type_error(cx, "Value is not an object.");
                return false;

            })
        };
        let result: () = this.PassOptionalNullableInterface(arg0.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableInterface_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableInterface::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableObject<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<*mut JSObject> = if args.get(0).is_undefined() {
            None
        } else {
            Some(if args.get(0).get().is_object() {
                args.get(0).get().to_object()
            } else if args.get(0).get().is_null_or_undefined() {
                ptr::null_mut()
            } else {
                throw_type_error(cx, "Value is not an object.");
                return false;

            })
        };
        let result: () = this.PassOptionalNullableObject(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableObject_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableObject::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableUnion<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<UnionTypes::HTMLElementOrLong<TH>>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalNullableUnion(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableUnion_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableUnion::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableUnion2<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<UnionTypes::EventOrString<TH>>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalNullableUnion2(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableUnion2_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableUnion2::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableUnion3<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<UnionTypes::StringOrLongSequence>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalNullableUnion3(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableUnion3_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableUnion3::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableUnion4<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<UnionTypes::LongSequenceOrBoolean>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalNullableUnion4(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableUnion4_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableUnion4::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableUnion5<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<UnionTypes::UnsignedLongOrBoolean>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalNullableUnion5(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableUnion5_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableUnion5::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableUnion6<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<UnionTypes::ByteStringOrLong>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalNullableUnion6(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableUnion6_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableUnion6::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableCallbackFunction<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<Rc<Function<TH>>>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(if args.get(0).get().is_object() {
                if IsCallable(args.get(0).get().to_object()) {
                    Some(Function::new(cx, args.get(0).get().to_object()))
                } else {
                    throw_type_error(cx, "Value is not callable.");
                    return false;

                }
            } else if args.get(0).get().is_null_or_undefined() {
                None
            } else {
                throw_type_error(cx, "Value is not an object.");
                return false;

            })
        };
        let result: () = this.PassOptionalNullableCallbackFunction(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableCallbackFunction_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableCallbackFunction::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableCallbackInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<Rc<dom::bindings::codegen::Bindings::EventListenerBinding::EventListener<TH>>>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(if args.get(0).get().is_object() {
                Some(dom::bindings::codegen::Bindings::EventListenerBinding::EventListener::new(cx, args.get(0).get().to_object()))
            } else if args.get(0).get().is_null_or_undefined() {
                None
            } else {
                throw_type_error(cx, "Value is not an object.");
                return false;

            })
        };
        let result: () = this.PassOptionalNullableCallbackInterface(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableCallbackInterface_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableCallbackInterface::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableSequence<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<Vec<i32> >> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalNullableSequence(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableSequence_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableSequence::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalBooleanWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: bool = if args.get(0).is_undefined() {
            false
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalBooleanWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalBooleanWithDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalBooleanWithDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalByteWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: i8 = if args.get(0).is_undefined() {
            0
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalByteWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalByteWithDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalByteWithDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalOctetWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: u8 = if args.get(0).is_undefined() {
            19
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalOctetWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalOctetWithDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalOctetWithDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalShortWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: i16 = if args.get(0).is_undefined() {
            5
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalShortWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalShortWithDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalShortWithDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalUnsignedShortWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: u16 = if args.get(0).is_undefined() {
            2
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalUnsignedShortWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalUnsignedShortWithDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalUnsignedShortWithDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalLongWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: i32 = if args.get(0).is_undefined() {
            7
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalLongWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalLongWithDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalLongWithDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalUnsignedLongWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: u32 = if args.get(0).is_undefined() {
            6
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalUnsignedLongWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalUnsignedLongWithDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalUnsignedLongWithDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalLongLongWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: i64 = if args.get(0).is_undefined() {
            -12
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalLongLongWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalLongLongWithDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalLongLongWithDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalUnsignedLongLongWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: u64 = if args.get(0).is_undefined() {
            17
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalUnsignedLongLongWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalUnsignedLongLongWithDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalUnsignedLongLongWithDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalBytestringWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: ByteString = if args.get(0).is_undefined() {
            ByteString::new(b"x".to_vec())
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        let result: () = this.PassOptionalBytestringWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalBytestringWithDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalBytestringWithDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalStringWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: DOMString = if args.get(0).is_undefined() {
            DOMString::from("x")
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        let result: () = this.PassOptionalStringWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalStringWithDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalStringWithDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalUsvstringWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: USVString = if args.get(0).is_undefined() {
            USVString("x".to_owned())
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        let result: () = this.PassOptionalUsvstringWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalUsvstringWithDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalUsvstringWithDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalEnumWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: TestEnum = if args.get(0).is_undefined() {
            TestEnum::Foo
        } else {
            match find_enum_value(cx, args.get(0), TestEnumValues::pairs) {
                Err(_) => { return false;
             },
                Ok((None, search)) => { throw_type_error(cx, &format!("'{}' is not a valid enum value for enumeration 'TestEnum'.", search)); return false;
             },
                Ok((Some(&value), _)) => value,
            }
        };
        let result: () = this.PassOptionalEnumWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalEnumWithDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalEnumWithDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableBooleanWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<bool> = if args.get(0).is_undefined() {
            None
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableBooleanWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableBooleanWithDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableBooleanWithDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableByteWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<i8> = if args.get(0).is_undefined() {
            None
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableByteWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableByteWithDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableByteWithDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableOctetWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<u8> = if args.get(0).is_undefined() {
            None
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableOctetWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableOctetWithDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableOctetWithDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableShortWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<i16> = if args.get(0).is_undefined() {
            None
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableShortWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableShortWithDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableShortWithDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableUnsignedShortWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<u16> = if args.get(0).is_undefined() {
            None
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableUnsignedShortWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableUnsignedShortWithDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableUnsignedShortWithDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableLongWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<i32> = if args.get(0).is_undefined() {
            None
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableLongWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableLongWithDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableLongWithDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableUnsignedLongWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<u32> = if args.get(0).is_undefined() {
            None
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableUnsignedLongWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableUnsignedLongWithDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableUnsignedLongWithDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableLongLongWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<i64> = if args.get(0).is_undefined() {
            None
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableLongLongWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableLongLongWithDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableLongLongWithDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableUnsignedLongLongWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<u64> = if args.get(0).is_undefined() {
            None
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableUnsignedLongLongWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableUnsignedLongLongWithDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableUnsignedLongLongWithDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableStringWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<DOMString> = if args.get(0).is_undefined() {
            None
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        let result: () = this.PassOptionalNullableStringWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableStringWithDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableStringWithDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableUsvstringWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<USVString> = if args.get(0).is_undefined() {
            None
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        let result: () = this.PassOptionalNullableUsvstringWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableUsvstringWithDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableUsvstringWithDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableByteStringWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<ByteString> = if args.get(0).is_undefined() {
            None
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        let result: () = this.PassOptionalNullableByteStringWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableByteStringWithDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableByteStringWithDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableInterfaceWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<DomRoot<Blob<TH>>> = if args.get(0).is_undefined() {
            None
        } else {
            if args.get(0).get().is_object() {
                Some(match root_from_handlevalue(args.get(0)) {
                    Ok(val) => val,
                    Err(()) => {
                        throw_type_error(cx, "value does not implement interface Blob.");
                        return false;

                    }
                }
                )
            } else if args.get(0).get().is_null_or_undefined() {
                None
            } else {
                throw_type_error(cx, "Value is not an object.");
                return false;

            }
        };
        let result: () = this.PassOptionalNullableInterfaceWithDefault(arg0.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableInterfaceWithDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableInterfaceWithDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableObjectWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: *mut JSObject = if args.get(0).is_undefined() {
            ptr::null_mut()
        } else {
            if args.get(0).get().is_object() {
                args.get(0).get().to_object()
            } else if args.get(0).get().is_null_or_undefined() {
                ptr::null_mut()
            } else {
                throw_type_error(cx, "Value is not an object.");
                return false;

            }
        };
        let result: () = this.PassOptionalNullableObjectWithDefault(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableObjectWithDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableObjectWithDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableUnionWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<UnionTypes::HTMLElementOrLong<TH>> = if args.get(0).is_undefined() {
            None
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        let result: () = this.PassOptionalNullableUnionWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableUnionWithDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableUnionWithDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableUnion2WithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<UnionTypes::EventOrString<TH>> = if args.get(0).is_undefined() {
            None
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        let result: () = this.PassOptionalNullableUnion2WithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableUnion2WithDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableUnion2WithDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableCallbackInterfaceWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Rc<dom::bindings::codegen::Bindings::EventListenerBinding::EventListener<TH>>> = if args.get(0).is_undefined() {
            None
        } else {
            if args.get(0).get().is_object() {
                Some(dom::bindings::codegen::Bindings::EventListenerBinding::EventListener::new(cx, args.get(0).get().to_object()))
            } else if args.get(0).get().is_null_or_undefined() {
                None
            } else {
                throw_type_error(cx, "Value is not an object.");
                return false;

            }
        };
        let result: () = this.PassOptionalNullableCallbackInterfaceWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableCallbackInterfaceWithDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableCallbackInterfaceWithDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalAnyWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: HandleValue = if args.get(0).is_undefined() {
            HandleValue::null()
        } else {
            args.get(0)
        };
        let result: () = this.PassOptionalAnyWithDefault(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalAnyWithDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalAnyWithDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableBooleanWithNonNullDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<bool> = if args.get(0).is_undefined() {
            Some(false)
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableBooleanWithNonNullDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableBooleanWithNonNullDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableBooleanWithNonNullDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableByteWithNonNullDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<i8> = if args.get(0).is_undefined() {
            Some(7)
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableByteWithNonNullDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableByteWithNonNullDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableByteWithNonNullDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableOctetWithNonNullDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<u8> = if args.get(0).is_undefined() {
            Some(7)
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableOctetWithNonNullDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableOctetWithNonNullDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableOctetWithNonNullDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableShortWithNonNullDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<i16> = if args.get(0).is_undefined() {
            Some(7)
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableShortWithNonNullDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableShortWithNonNullDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableShortWithNonNullDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableUnsignedShortWithNonNullDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<u16> = if args.get(0).is_undefined() {
            Some(7)
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableUnsignedShortWithNonNullDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableUnsignedShortWithNonNullDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableUnsignedShortWithNonNullDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableLongWithNonNullDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<i32> = if args.get(0).is_undefined() {
            Some(7)
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableLongWithNonNullDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableLongWithNonNullDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableLongWithNonNullDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableUnsignedLongWithNonNullDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<u32> = if args.get(0).is_undefined() {
            Some(7)
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableUnsignedLongWithNonNullDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableUnsignedLongWithNonNullDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableUnsignedLongWithNonNullDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableLongLongWithNonNullDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<i64> = if args.get(0).is_undefined() {
            Some(7)
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableLongLongWithNonNullDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableLongLongWithNonNullDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableLongLongWithNonNullDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableUnsignedLongLongWithNonNullDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<u64> = if args.get(0).is_undefined() {
            Some(7)
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableUnsignedLongLongWithNonNullDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableUnsignedLongLongWithNonNullDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableUnsignedLongLongWithNonNullDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableStringWithNonNullDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<DOMString> = if args.get(0).is_undefined() {
            Some(DOMString::from("x"))
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        let result: () = this.PassOptionalNullableStringWithNonNullDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableStringWithNonNullDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableStringWithNonNullDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableUsvstringWithNonNullDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<USVString> = if args.get(0).is_undefined() {
            Some(USVString("x".to_owned()))
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        let result: () = this.PassOptionalNullableUsvstringWithNonNullDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableUsvstringWithNonNullDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableUsvstringWithNonNullDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalOverloaded<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        let argcount = cmp::min(argc, 3);
        match argcount {
            1 => {
                if args.get(0).get().is_object() {
                    loop {
                    let arg0: DomRoot<TestBinding<TH>> = match root_from_handlevalue(args.get(0)) {
                        Ok(val) => val,
                        Err(()) => {
                            break;
                        }
                    }
                    ;
                    let arg1: u32 = if args.get(1).is_undefined() {
                        0
                    } else {
                        match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return false;

                            }
                            _ => { return false;
                         }
                        }
                    };
                    let arg2: u32 = if args.get(2).is_undefined() {
                        0
                    } else {
                        match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return false;

                            }
                            _ => { return false;
                         }
                        }
                    };
                    let result: DomRoot<TestBinding<TH>> = this.PassOptionalOverloaded(&arg0, arg1, arg2);

                    (result).to_jsval(cx, args.rval());
                    return true;
                    }
                    loop {
                    let arg0: DomRoot<Blob<TH>> = match root_from_handlevalue(args.get(0)) {
                        Ok(val) => val,
                        Err(()) => {
                            break;
                        }
                    }
                    ;
                    let arg1: u32 = if args.get(1).is_undefined() {
                        0
                    } else {
                        match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return false;

                            }
                            _ => { return false;
                         }
                        }
                    };
                    let result: () = this.PassOptionalOverloaded_(&arg0, arg1);

                    (result).to_jsval(cx, args.rval());
                    return true;
                    }
                }
                throw_internal_error(cx, "Could not convert JavaScript argument");
                return false;
            }
            2 => {
                if args.get(0).get().is_object() {
                    loop {
                    let arg0: DomRoot<TestBinding<TH>> = match root_from_handlevalue(args.get(0)) {
                        Ok(val) => val,
                        Err(()) => {
                            break;
                        }
                    }
                    ;
                    let arg1: u32 = if args.get(1).is_undefined() {
                        0
                    } else {
                        match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return false;

                            }
                            _ => { return false;
                         }
                        }
                    };
                    let arg2: u32 = if args.get(2).is_undefined() {
                        0
                    } else {
                        match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return false;

                            }
                            _ => { return false;
                         }
                        }
                    };
                    let result: DomRoot<TestBinding<TH>> = this.PassOptionalOverloaded(&arg0, arg1, arg2);

                    (result).to_jsval(cx, args.rval());
                    return true;
                    }
                    loop {
                    let arg0: DomRoot<Blob<TH>> = match root_from_handlevalue(args.get(0)) {
                        Ok(val) => val,
                        Err(()) => {
                            break;
                        }
                    }
                    ;
                    let arg1: u32 = if args.get(1).is_undefined() {
                        0
                    } else {
                        match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return false;

                            }
                            _ => { return false;
                         }
                        }
                    };
                    let result: () = this.PassOptionalOverloaded_(&arg0, arg1);

                    (result).to_jsval(cx, args.rval());
                    return true;
                    }
                }
                throw_internal_error(cx, "Could not convert JavaScript argument");
                return false;
            }
            3 => {
                let arg0: DomRoot<TestBinding<TH>> = if args.get(0).get().is_object() {
                    match root_from_handlevalue(args.get(0)) {
                        Ok(val) => val,
                        Err(()) => {
                            throw_type_error(cx, "value does not implement interface TestBinding.");
                            return false;

                        }
                    }

                } else {
                    throw_type_error(cx, "Value is not an object.");
                    return false;

                };
                let arg1: u32 = if args.get(1).is_undefined() {
                    0
                } else {
                    match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                        Ok(ConversionResult::Success(v)) => v,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     }
                    }
                };
                let arg2: u32 = if args.get(2).is_undefined() {
                    0
                } else {
                    match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
                        Ok(ConversionResult::Success(v)) => v,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     }
                    }
                };
                let result: DomRoot<TestBinding<TH>> = this.PassOptionalOverloaded(&arg0, arg1, arg2);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            _ => {
                throw_type_error(cx, "Not enough arguments to \"TestBinding.passOptionalOverloaded\".");
                return false;
            }
        }
    }), false);
}


fn passOptionalOverloaded_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalOverloaded::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passVariadicBoolean<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: bool = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicBoolean(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passVariadicBoolean_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passVariadicBoolean::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passVariadicBooleanAndDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: bool = if args.get(0).is_undefined() {
            true
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let mut arg1 = vec![];
        if argc > 1 {
            arg1.reserve(argc as usize - 1);
            for variadicArg in 1..argc {
                let slot: bool = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                arg1.push(slot);
            }
        }
        let result: () = this.PassVariadicBooleanAndDefault(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passVariadicBooleanAndDefault_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passVariadicBooleanAndDefault::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passVariadicByte<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: i8 = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicByte(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passVariadicByte_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passVariadicByte::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passVariadicOctet<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: u8 = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicOctet(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passVariadicOctet_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passVariadicOctet::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passVariadicShort<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: i16 = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicShort(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passVariadicShort_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passVariadicShort::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passVariadicUnsignedShort<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: u16 = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicUnsignedShort(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passVariadicUnsignedShort_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passVariadicUnsignedShort::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passVariadicLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: i32 = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passVariadicLong_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passVariadicLong::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passVariadicUnsignedLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: u32 = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicUnsignedLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passVariadicUnsignedLong_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passVariadicUnsignedLong::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passVariadicLongLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: i64 = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicLongLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passVariadicLongLong_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passVariadicLongLong::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passVariadicUnsignedLongLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: u64 = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicUnsignedLongLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passVariadicUnsignedLongLong_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passVariadicUnsignedLongLong::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passVariadicUnrestrictedFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: f32 = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicUnrestrictedFloat(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passVariadicUnrestrictedFloat_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passVariadicUnrestrictedFloat::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passVariadicFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: Finite<f32> = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicFloat(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passVariadicFloat_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passVariadicFloat::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passVariadicUnrestrictedDouble<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: f64 = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicUnrestrictedDouble(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passVariadicUnrestrictedDouble_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passVariadicUnrestrictedDouble::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passVariadicDouble<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: Finite<f64> = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicDouble(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passVariadicDouble_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passVariadicDouble::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passVariadicString<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), StringificationBehavior::Default) {
                    Ok(ConversionResult::Success(strval)) => strval,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicString(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passVariadicString_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passVariadicString::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passVariadicUsvstring<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: USVString = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(strval)) => strval,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicUsvstring(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passVariadicUsvstring_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passVariadicUsvstring::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passVariadicByteString<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: ByteString = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(strval)) => strval,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicByteString(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passVariadicByteString_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passVariadicByteString::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passVariadicEnum<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: TestEnum = match find_enum_value(cx, args.get(variadicArg), TestEnumValues::pairs) {
                    Err(_) => { return false;
                 },
                    Ok((None, search)) => { throw_type_error(cx, &format!("'{}' is not a valid enum value for enumeration 'TestEnum'.", search)); return false;
                 },
                    Ok((Some(&value), _)) => value,
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicEnum(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passVariadicEnum_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passVariadicEnum::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passVariadicInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        rooted_vec!(let mut arg0);
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: *const Blob<TH> = if args.get(variadicArg).get().is_object() {
                    match native_from_handlevalue(args.get(variadicArg)) {
                        Ok(val) => val,
                        Err(()) => {
                            throw_type_error(cx, "value does not implement interface Blob.");
                            return false;

                        }
                    }

                } else {
                    throw_type_error(cx, "Value is not an object.");
                    return false;

                };
                arg0.push(Dom::from_ref(&*slot));
            }
        }
        let result: () = this.PassVariadicInterface(arg0.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passVariadicInterface_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passVariadicInterface::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passVariadicUnion<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: UnionTypes::HTMLElementOrLong<TH> = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(value)) => value,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicUnion(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passVariadicUnion_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passVariadicUnion::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passVariadicUnion2<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: UnionTypes::EventOrString<TH> = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(value)) => value,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicUnion2(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passVariadicUnion2_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passVariadicUnion2::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passVariadicUnion3<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: UnionTypes::BlobOrString<TH> = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(value)) => value,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicUnion3(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passVariadicUnion3_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passVariadicUnion3::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passVariadicUnion4<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: UnionTypes::BlobOrBoolean<TH> = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(value)) => value,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicUnion4(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passVariadicUnion4_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passVariadicUnion4::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passVariadicUnion5<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: UnionTypes::StringOrUnsignedLong = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(value)) => value,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicUnion5(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passVariadicUnion5_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passVariadicUnion5::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passVariadicUnion6<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: UnionTypes::UnsignedLongOrBoolean = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(value)) => value,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicUnion6(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passVariadicUnion6_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passVariadicUnion6::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passVariadicUnion7<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: UnionTypes::ByteStringOrLong = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(value)) => value,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicUnion7(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passVariadicUnion7_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passVariadicUnion7::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passVariadicAny<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: HandleValue = args.get(variadicArg);
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicAny(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passVariadicAny_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passVariadicAny::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passVariadicObject<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: *mut JSObject = if args.get(variadicArg).get().is_object() {
                    args.get(variadicArg).get().to_object()
                } else {
                    throw_type_error(cx, "Value is not an object.");
                    return false;

                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicObject(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passVariadicObject_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passVariadicObject::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passSequenceSequence<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passSequenceSequence\".");
            return false;
        }
        let arg0: Vec<Vec<i32>> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassSequenceSequence(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passSequenceSequence_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passSequenceSequence::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn returnSequenceSequence<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Vec<Vec<i32>> = this.ReturnSequenceSequence();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn returnSequenceSequence_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: returnSequenceSequence::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passUnionSequenceSequence<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnionSequenceSequence\".");
            return false;
        }
        let arg0: UnionTypes::LongOrLongSequenceSequence = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassUnionSequenceSequence(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passUnionSequenceSequence_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passUnionSequenceSequence::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passMozMap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passMozMap\".");
            return false;
        }
        let arg0: MozMap<i32> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassMozMap(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passMozMap_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passMozMap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passNullableMozMap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableMozMap\".");
            return false;
        }
        let arg0: Option<MozMap<i32> > = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassNullableMozMap(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passNullableMozMap_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passNullableMozMap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passMozMapOfNullableInts<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passMozMapOfNullableInts\".");
            return false;
        }
        let arg0: MozMap<Option<i32>> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassMozMapOfNullableInts(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passMozMapOfNullableInts_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passMozMapOfNullableInts::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalMozMapOfNullableInts<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<MozMap<Option<i32>>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalMozMapOfNullableInts(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalMozMapOfNullableInts_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalMozMapOfNullableInts::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableMozMapOfNullableInts<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<MozMap<Option<i32>> >> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalNullableMozMapOfNullableInts(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableMozMapOfNullableInts_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableMozMapOfNullableInts::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passCastableObjectMozMap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passCastableObjectMozMap\".");
            return false;
        }
        let arg0: MozMap<DomRoot<TestBinding<TH>>> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassCastableObjectMozMap(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passCastableObjectMozMap_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passCastableObjectMozMap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passNullableCastableObjectMozMap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableCastableObjectMozMap\".");
            return false;
        }
        let arg0: MozMap<Option<DomRoot<TestBinding<TH>>>> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassNullableCastableObjectMozMap(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passNullableCastableObjectMozMap_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passNullableCastableObjectMozMap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passCastableObjectNullableMozMap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passCastableObjectNullableMozMap\".");
            return false;
        }
        let arg0: Option<MozMap<DomRoot<TestBinding<TH>>> > = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassCastableObjectNullableMozMap(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passCastableObjectNullableMozMap_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passCastableObjectNullableMozMap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passNullableCastableObjectNullableMozMap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableCastableObjectNullableMozMap\".");
            return false;
        }
        let arg0: Option<MozMap<Option<DomRoot<TestBinding<TH>>>> > = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassNullableCastableObjectNullableMozMap(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passNullableCastableObjectNullableMozMap_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passNullableCastableObjectNullableMozMap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalMozMap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<MozMap<i32>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalMozMap(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalMozMap_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalMozMap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableMozMap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<MozMap<i32> >> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalNullableMozMap(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableMozMap_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableMozMap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalNullableMozMapWithDefaultValue<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<MozMap<i32> > = if args.get(0).is_undefined() {
            None
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        let result: () = this.PassOptionalNullableMozMapWithDefaultValue(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalNullableMozMapWithDefaultValue_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalNullableMozMapWithDefaultValue::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passOptionalObjectMozMap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<MozMap<DomRoot<TestBinding<TH>>>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalObjectMozMap(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passOptionalObjectMozMap_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passOptionalObjectMozMap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passStringMozMap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passStringMozMap\".");
            return false;
        }
        let arg0: MozMap<DOMString> = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassStringMozMap(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passStringMozMap_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passStringMozMap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passByteStringMozMap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passByteStringMozMap\".");
            return false;
        }
        let arg0: MozMap<ByteString> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassByteStringMozMap(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passByteStringMozMap_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passByteStringMozMap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passMozMapOfMozMaps<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passMozMapOfMozMaps\".");
            return false;
        }
        let arg0: MozMap<MozMap<i32>> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassMozMapOfMozMaps(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passMozMapOfMozMaps_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passMozMapOfMozMaps::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passMozMapUnion<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passMozMapUnion\".");
            return false;
        }
        let arg0: UnionTypes::LongOrStringByteStringRecord = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassMozMapUnion(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passMozMapUnion_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passMozMapUnion::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passMozMapUnion2<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passMozMapUnion2\".");
            return false;
        }
        let arg0: UnionTypes::TestBindingOrStringByteStringRecord<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassMozMapUnion2(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passMozMapUnion2_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passMozMapUnion2::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn passMozMapUnion3<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passMozMapUnion3\".");
            return false;
        }
        let arg0: UnionTypes::TestBindingOrByteStringSequenceSequenceOrStringByteStringRecord<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassMozMapUnion3(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn passMozMapUnion3_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: passMozMapUnion3::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveMozMap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: MozMap<i32> = this.ReceiveMozMap();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveMozMap_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveMozMap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveNullableMozMap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<MozMap<i32>> = this.ReceiveNullableMozMap();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveNullableMozMap_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveNullableMozMap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveMozMapOfNullableInts<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: MozMap<Option<i32>> = this.ReceiveMozMapOfNullableInts();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveMozMapOfNullableInts_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveMozMapOfNullableInts::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveNullableMozMapOfNullableInts<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<MozMap<Option<i32>>> = this.ReceiveNullableMozMapOfNullableInts();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveNullableMozMapOfNullableInts_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveNullableMozMapOfNullableInts::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveMozMapOfMozMaps<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: MozMap<MozMap<i32>> = this.ReceiveMozMapOfMozMaps();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveMozMapOfMozMaps_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveMozMapOfMozMaps::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn receiveAnyMozMap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: MozMap<JSVal> = this.ReceiveAnyMozMap();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn receiveAnyMozMap_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: receiveAnyMozMap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_booleanAttributeStatic<TH: TypeHolderTrait>
(cx: *mut JSContext, argc: libc::c_uint, vp: *mut JSVal) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let global = GlobalScope::from_object(JS_CALLEE(cx, vp).to_object());
        let args = CallArgs::from_vp(vp, argc);
        let result: bool = TestBinding::BooleanAttributeStatic(&global);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_booleanAttributeStatic<TH: TypeHolderTrait>
(cx: *mut JSContext, argc: libc::c_uint, vp: *mut JSVal) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let global = GlobalScope::from_object(JS_CALLEE(cx, vp).to_object());
        let args = CallArgs::from_vp(vp, argc);
        if argc == 0 {
            throw_type_error(cx, "Not enough arguments to booleanAttributeStatic setter.");
            return false;
        }let arg0: bool = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = TestBinding::SetBooleanAttributeStatic(&global, arg0);

        return true;
    }), false);
}

unsafe extern fn receiveVoidStatic<TH: TypeHolderTrait>
(cx: *mut JSContext, argc: libc::c_uint, vp: *mut JSVal) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let global = GlobalScope::from_object(JS_CALLEE(cx, vp).to_object());
        let args = CallArgs::from_vp(vp, argc);
        let result: () = TestBinding::ReceiveVoidStatic(&global);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn BooleanMozPreference<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.BooleanMozPreference\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: bool = this.BooleanMozPreference(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn BooleanMozPreference_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: BooleanMozPreference::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_BOOLEAN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn StringMozPreference<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.StringMozPreference\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: DOMString = this.StringMozPreference(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn StringMozPreference_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: StringMozPreference::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_prefControlledAttributeDisabled<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: bool = this.PrefControlledAttributeDisabled();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn prefControlledAttributeDisabled_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_prefControlledAttributeDisabled::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_BOOLEAN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_prefControlledStaticAttributeDisabled<TH: TypeHolderTrait>
(cx: *mut JSContext, argc: libc::c_uint, vp: *mut JSVal) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let global = GlobalScope::from_object(JS_CALLEE(cx, vp).to_object());
        let args = CallArgs::from_vp(vp, argc);
        let result: bool = TestBinding::PrefControlledStaticAttributeDisabled(&global);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn prefControlledMethodDisabled<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.PrefControlledMethodDisabled();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn prefControlledMethodDisabled_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: prefControlledMethodDisabled::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn prefControlledStaticMethodDisabled<TH: TypeHolderTrait>
(cx: *mut JSContext, argc: libc::c_uint, vp: *mut JSVal) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let global = GlobalScope::from_object(JS_CALLEE(cx, vp).to_object());
        let args = CallArgs::from_vp(vp, argc);
        let result: () = TestBinding::PrefControlledStaticMethodDisabled(&global);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn advanceClock<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.advanceClock\".");
            return false;
        }
        let arg0: i32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: bool = if args.get(1).is_undefined() {
            true
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.AdvanceClock(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn advanceClock_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: advanceClock::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_prefControlledAttributeEnabled<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: bool = this.PrefControlledAttributeEnabled();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn prefControlledAttributeEnabled_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_prefControlledAttributeEnabled::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_BOOLEAN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_prefControlledStaticAttributeEnabled<TH: TypeHolderTrait>
(cx: *mut JSContext, argc: libc::c_uint, vp: *mut JSVal) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let global = GlobalScope::from_object(JS_CALLEE(cx, vp).to_object());
        let args = CallArgs::from_vp(vp, argc);
        let result: bool = TestBinding::PrefControlledStaticAttributeEnabled(&global);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn prefControlledMethodEnabled<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.PrefControlledMethodEnabled();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn prefControlledMethodEnabled_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: prefControlledMethodEnabled::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn prefControlledStaticMethodEnabled<TH: TypeHolderTrait>
(cx: *mut JSContext, argc: libc::c_uint, vp: *mut JSVal) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let global = GlobalScope::from_object(JS_CALLEE(cx, vp).to_object());
        let args = CallArgs::from_vp(vp, argc);
        let result: () = TestBinding::PrefControlledStaticMethodEnabled(&global);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn get_funcControlledAttributeDisabled<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: bool = this.FuncControlledAttributeDisabled();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn funcControlledAttributeDisabled_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_funcControlledAttributeDisabled::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_BOOLEAN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_funcControlledStaticAttributeDisabled<TH: TypeHolderTrait>
(cx: *mut JSContext, argc: libc::c_uint, vp: *mut JSVal) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let global = GlobalScope::from_object(JS_CALLEE(cx, vp).to_object());
        let args = CallArgs::from_vp(vp, argc);
        let result: bool = TestBinding::FuncControlledStaticAttributeDisabled(&global);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn funcControlledMethodDisabled<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.FuncControlledMethodDisabled();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn funcControlledMethodDisabled_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: funcControlledMethodDisabled::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn funcControlledStaticMethodDisabled<TH: TypeHolderTrait>
(cx: *mut JSContext, argc: libc::c_uint, vp: *mut JSVal) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let global = GlobalScope::from_object(JS_CALLEE(cx, vp).to_object());
        let args = CallArgs::from_vp(vp, argc);
        let result: () = TestBinding::FuncControlledStaticMethodDisabled(&global);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn get_funcControlledAttributeEnabled<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: bool = this.FuncControlledAttributeEnabled();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn funcControlledAttributeEnabled_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_funcControlledAttributeEnabled::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_BOOLEAN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_funcControlledStaticAttributeEnabled<TH: TypeHolderTrait>
(cx: *mut JSContext, argc: libc::c_uint, vp: *mut JSVal) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let global = GlobalScope::from_object(JS_CALLEE(cx, vp).to_object());
        let args = CallArgs::from_vp(vp, argc);
        let result: bool = TestBinding::FuncControlledStaticAttributeEnabled(&global);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn funcControlledMethodEnabled<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.FuncControlledMethodEnabled();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn funcControlledMethodEnabled_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: funcControlledMethodEnabled::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn funcControlledStaticMethodEnabled<TH: TypeHolderTrait>
(cx: *mut JSContext, argc: libc::c_uint, vp: *mut JSVal) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let global = GlobalScope::from_object(JS_CALLEE(cx, vp).to_object());
        let args = CallArgs::from_vp(vp, argc);
        let result: () = TestBinding::FuncControlledStaticMethodEnabled(&global);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn returnResolvedPromise<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.returnResolvedPromise\".");
            return false;
        }
        let arg0: HandleValue = args.get(0);
        let result: Result<Rc<Promise<TH>>, Error<TH>> = this.ReturnResolvedPromise(cx, arg0);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn returnResolvedPromise_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: returnResolvedPromise::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn returnRejectedPromise<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.returnRejectedPromise\".");
            return false;
        }
        let arg0: HandleValue = args.get(0);
        let result: Result<Rc<Promise<TH>>, Error<TH>> = this.ReturnRejectedPromise(cx, arg0);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn returnRejectedPromise_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: returnRejectedPromise::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_promiseAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Rc<Promise<TH>> = this.PromiseAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn promiseAttribute_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_promiseAttribute::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn acceptPromise<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.acceptPromise\".");
            return false;
        }
        let arg0: Rc<Promise<TH>> = { // Scope for our JSAutoCompartment.

            rooted!(in(cx) let globalObj = CurrentGlobalOrNull(cx));
            let promiseGlobal = GlobalScope::from_object_maybe_wrapped(globalObj.handle().get());

            rooted!(in(cx) let mut valueToResolve = args.get(0).get());
            if !JS_WrapValue(cx, valueToResolve.handle_mut()) {
            return false;
            }
            match Promise::new_resolved(&promiseGlobal, cx, valueToResolve.handle()) {
                Ok(value) => value,
                Err(error) => {
                throw_dom_exception(cx, &promiseGlobal, error);
                return false;
                }
            }
        }
        ;
        let result: () = this.AcceptPromise(&arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn acceptPromise_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: acceptPromise::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn promiseNativeHandler<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.promiseNativeHandler\".");
            return false;
        }
        let arg0: Option<Rc<SimpleCallback<TH>>> = if args.get(0).get().is_object() {
            if IsCallable(args.get(0).get().to_object()) {
                Some(SimpleCallback::new(cx, args.get(0).get().to_object()))
            } else {
                throw_type_error(cx, "Value is not callable.");
                return false;

            }
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: Option<Rc<SimpleCallback<TH>>> = if args.get(1).get().is_object() {
            if IsCallable(args.get(1).get().to_object()) {
                Some(SimpleCallback::new(cx, args.get(1).get().to_object()))
            } else {
                throw_type_error(cx, "Value is not callable.");
                return false;

            }
        } else if args.get(1).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: Rc<Promise<TH>> = this.PromiseNativeHandler(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn promiseNativeHandler_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: promiseNativeHandler::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn promiseResolveNative<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.promiseResolveNative\".");
            return false;
        }
        let arg0: Rc<Promise<TH>> = { // Scope for our JSAutoCompartment.

            rooted!(in(cx) let globalObj = CurrentGlobalOrNull(cx));
            let promiseGlobal = GlobalScope::from_object_maybe_wrapped(globalObj.handle().get());

            rooted!(in(cx) let mut valueToResolve = args.get(0).get());
            if !JS_WrapValue(cx, valueToResolve.handle_mut()) {
            return false;
            }
            match Promise::new_resolved(&promiseGlobal, cx, valueToResolve.handle()) {
                Ok(value) => value,
                Err(error) => {
                throw_dom_exception(cx, &promiseGlobal, error);
                return false;
                }
            }
        }
        ;
        let arg1: HandleValue = args.get(1);
        let result: () = this.PromiseResolveNative(cx, &arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn promiseResolveNative_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: promiseResolveNative::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn promiseRejectNative<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.promiseRejectNative\".");
            return false;
        }
        let arg0: Rc<Promise<TH>> = { // Scope for our JSAutoCompartment.

            rooted!(in(cx) let globalObj = CurrentGlobalOrNull(cx));
            let promiseGlobal = GlobalScope::from_object_maybe_wrapped(globalObj.handle().get());

            rooted!(in(cx) let mut valueToResolve = args.get(0).get());
            if !JS_WrapValue(cx, valueToResolve.handle_mut()) {
            return false;
            }
            match Promise::new_resolved(&promiseGlobal, cx, valueToResolve.handle()) {
                Ok(value) => value,
                Err(error) => {
                throw_dom_exception(cx, &promiseGlobal, error);
                return false;
                }
            }
        }
        ;
        let arg1: HandleValue = args.get(1);
        let result: () = this.PromiseRejectNative(cx, &arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn promiseRejectNative_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: promiseRejectNative::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn promiseRejectWithTypeError<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.promiseRejectWithTypeError\".");
            return false;
        }
        let arg0: Rc<Promise<TH>> = { // Scope for our JSAutoCompartment.

            rooted!(in(cx) let globalObj = CurrentGlobalOrNull(cx));
            let promiseGlobal = GlobalScope::from_object_maybe_wrapped(globalObj.handle().get());

            rooted!(in(cx) let mut valueToResolve = args.get(0).get());
            if !JS_WrapValue(cx, valueToResolve.handle_mut()) {
            return false;
            }
            match Promise::new_resolved(&promiseGlobal, cx, valueToResolve.handle()) {
                Ok(value) => value,
                Err(error) => {
                throw_dom_exception(cx, &promiseGlobal, error);
                return false;
                }
            }
        }
        ;
        let arg1: USVString = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PromiseRejectWithTypeError(&arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn promiseRejectWithTypeError_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: promiseRejectWithTypeError::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn resolvePromiseDelayed<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 3 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.resolvePromiseDelayed\".");
            return false;
        }
        let arg0: Rc<Promise<TH>> = { // Scope for our JSAutoCompartment.

            rooted!(in(cx) let globalObj = CurrentGlobalOrNull(cx));
            let promiseGlobal = GlobalScope::from_object_maybe_wrapped(globalObj.handle().get());

            rooted!(in(cx) let mut valueToResolve = args.get(0).get());
            if !JS_WrapValue(cx, valueToResolve.handle_mut()) {
            return false;
            }
            match Promise::new_resolved(&promiseGlobal, cx, valueToResolve.handle()) {
                Ok(value) => value,
                Err(error) => {
                throw_dom_exception(cx, &promiseGlobal, error);
                return false;
                }
            }
        }
        ;
        let arg1: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(1), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let arg2: u64 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.ResolvePromiseDelayed(&arg0, arg1, arg2);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn resolvePromiseDelayed_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: resolvePromiseDelayed::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn panic<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.Panic();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn panic_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: panic::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn entryGlobal<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: DomRoot<GlobalScope<TH>> = this.EntryGlobal();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn entryGlobal_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: entryGlobal::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn incumbentGlobal<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: DomRoot<GlobalScope<TH>> = this.IncumbentGlobal();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn incumbentGlobal_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: incumbentGlobal::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn crashHard<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.CrashHard();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn crashHard_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: crashHard::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn _finalize<TH: TypeHolderTrait>
(_fop: *mut JSFreeOp, obj: *mut JSObject) {
    return wrap_panic(panic::AssertUnwindSafe(|| {

        let this = native_from_object::<TestBinding<TH>>(obj).unwrap();
            if !this.is_null() {
                // The pointer can be null if the object is the unforgeable holder of that interface.
                let _ = Box::from_raw(this as *mut TestBinding<TH>);
            }
            debug!("TestBinding<TH> finalize: {:p}", this);
    }), ());
}

unsafe extern fn _trace<TH: TypeHolderTrait>
(trc: *mut JSTracer, obj: *mut JSObject) {
    return wrap_panic(panic::AssertUnwindSafe(|| {

        let this = native_from_object::<TestBinding<TH>>(obj).unwrap();
        if this.is_null() { return; } // GC during obj creation
        (*this).trace(trc);
    }), ());
}

pub mod TestBindingConstants {
    pub const constantInt64: i64 = -1;
    pub const constantUint64: u64 = 1;
    pub const constantFloat32: f32 = 1.0;
    pub const constantFloat64: f64 = 1.0;
    pub const constantUnrestrictedFloat32: f32 = 1.0;
    pub const constantUnrestrictedFloat64: f64 = 1.0;
    pub const prefControlledConstDisabled: u16 = 0;
    pub const prefControlledConstEnabled: u16 = 0;
    pub const funcControlledConstDisabled: u16 = 0;
    pub const funcControlledConstEnabled: u16 = 0;
} // mod TestBindingConstants
fn CLASS_OPS<TH: TypeHolderTrait>() -> js::jsapi::JSClassOps { js::jsapi::JSClassOps {
    addProperty: None,
    delProperty: None,
    getProperty: None,
    setProperty: None,
    enumerate: None,
    resolve: None,
    mayResolve: None,
    finalize: Some(_finalize::<TH>),
    call: None,
    hasInstance: None,
    construct: None,
    trace: Some(_trace::<TH>),
}}

fn Class<TH: TypeHolderTrait>() -> DOMJSClass { DOMJSClass {
    base: js::jsapi::JSClass {
        name: b"TestBinding\0" as *const u8 as *const libc::c_char,
        flags: JSCLASS_IS_DOMJSCLASS | 0 |
               (((1) & JSCLASS_RESERVED_SLOTS_MASK) << JSCLASS_RESERVED_SLOTS_SHIFT)
               /* JSCLASS_HAS_RESERVED_SLOTS(1) */,
        cOps: &CLASS_OPS::<TH>(),
        reserved: [0 as *mut _; 3],
    },
    dom_class: DOMClass {
    interface_chain: [ PrototypeList::ID::TestBinding, PrototypeList::ID::Last, PrototypeList::ID::Last, PrototypeList::ID::Last, PrototypeList::ID::Last, PrototypeList::ID::Last ],
    type_id: ::dom::bindings::codegen::InheritTypes::TopTypeId { testbinding: (::dom::bindings::codegen::InheritTypes::TestBindingTypeId::TestBinding) },
    global: InterfaceObjectMap::Globals::EMPTY,
    malloc_size_of: malloc_size_of_including_raw_self::<TestBinding<TH>> as unsafe fn(&mut _, _) -> _,
}
}}

#[inline]
fn malloc_size<TH: TypeHolderTrait>(ops: &mut MallocSizeOfOps, obj: *const c_void) -> usize {
    malloc_size_of_including_raw_self::<TestBinding<TH>>(ops, obj)
}

pub unsafe fn Wrap<TH: TypeHolderTrait>
(cx: *mut JSContext, scope: &GlobalScope<TH>, object: Box<TestBinding<TH>>) -> DomRoot<TestBinding<TH>> {
    let scope = scope.reflector().get_jsobject();
    assert!(!scope.get().is_null());
    assert!(((*get_object_class(scope.get())).flags & JSCLASS_IS_GLOBAL) != 0);

    rooted!(in(cx) let mut proto = ptr::null_mut::<JSObject>());
    let _ac = JSAutoCompartment::new(cx, scope.get());
    GetProtoObject(cx, scope, proto.handle_mut());
    assert!(!proto.is_null());

    let raw = Box::into_raw(object);
    let _rt = RootedTraceable::new(&*raw);
    rooted!(in(cx) let obj = JS_NewObjectWithGivenProto(
        cx, &Class::<TH>().base as *const JSClass, proto.handle()));
    assert!(!obj.is_null());

    JS_SetReservedSlot(obj.get(), DOM_OBJECT_SLOT,
                       PrivateValue(raw as *const libc::c_void));


    (*raw).init_reflector(obj.get());

    DomRoot::from_ref(&*raw)
}

impl<TH: TypeHolderTrait> IDLInterface for TestBinding<TH> {
    #[inline]
    fn derives(class: &'static DOMClass) -> bool {
        class.interface_chain[0] == PrototypeList::ID::TestBinding
    }
}

impl<TH: TypeHolderTrait> PartialEq for TestBinding<TH> {
    fn eq(&self, other: &TestBinding<TH>) -> bool {
        self as *const TestBinding<TH> == &*other
    }
}

pub trait TestBindingMethods<TH: TypeHolderTrait> {
    fn BooleanAttribute(&self) -> bool;
    fn SetBooleanAttribute(&self, value: bool) -> ();
    fn ByteAttribute(&self) -> i8;
    fn SetByteAttribute(&self, value: i8) -> ();
    fn OctetAttribute(&self) -> u8;
    fn SetOctetAttribute(&self, value: u8) -> ();
    fn ShortAttribute(&self) -> i16;
    fn SetShortAttribute(&self, value: i16) -> ();
    fn UnsignedShortAttribute(&self) -> u16;
    fn SetUnsignedShortAttribute(&self, value: u16) -> ();
    fn LongAttribute(&self) -> i32;
    fn SetLongAttribute(&self, value: i32) -> ();
    fn UnsignedLongAttribute(&self) -> u32;
    fn SetUnsignedLongAttribute(&self, value: u32) -> ();
    fn LongLongAttribute(&self) -> i64;
    fn SetLongLongAttribute(&self, value: i64) -> ();
    fn UnsignedLongLongAttribute(&self) -> u64;
    fn SetUnsignedLongLongAttribute(&self, value: u64) -> ();
    fn UnrestrictedFloatAttribute(&self) -> f32;
    fn SetUnrestrictedFloatAttribute(&self, value: f32) -> ();
    fn FloatAttribute(&self) -> Finite<f32>;
    fn SetFloatAttribute(&self, value: Finite<f32>) -> ();
    fn UnrestrictedDoubleAttribute(&self) -> f64;
    fn SetUnrestrictedDoubleAttribute(&self, value: f64) -> ();
    fn DoubleAttribute(&self) -> Finite<f64>;
    fn SetDoubleAttribute(&self, value: Finite<f64>) -> ();
    fn StringAttribute(&self) -> DOMString;
    fn SetStringAttribute(&self, value: DOMString) -> ();
    fn UsvstringAttribute(&self) -> USVString;
    fn SetUsvstringAttribute(&self, value: USVString) -> ();
    fn ByteStringAttribute(&self) -> ByteString;
    fn SetByteStringAttribute(&self, value: ByteString) -> ();
    fn EnumAttribute(&self) -> TestEnum;
    fn SetEnumAttribute(&self, value: TestEnum) -> ();
    fn InterfaceAttribute(&self) -> DomRoot<Blob<TH>>;
    fn SetInterfaceAttribute(&self, value: &Blob<TH>) -> ();
    fn UnionAttribute(&self) -> UnionTypes::HTMLElementOrLong<TH>;
    fn SetUnionAttribute(&self, value: UnionTypes::HTMLElementOrLong<TH>) -> ();
    fn Union2Attribute(&self) -> UnionTypes::EventOrString<TH>;
    fn SetUnion2Attribute(&self, value: UnionTypes::EventOrString<TH>) -> ();
    fn Union3Attribute(&self) -> UnionTypes::EventOrUSVString<TH>;
    fn SetUnion3Attribute(&self, value: UnionTypes::EventOrUSVString<TH>) -> ();
    fn Union4Attribute(&self) -> UnionTypes::StringOrUnsignedLong;
    fn SetUnion4Attribute(&self, value: UnionTypes::StringOrUnsignedLong) -> ();
    fn Union5Attribute(&self) -> UnionTypes::StringOrBoolean;
    fn SetUnion5Attribute(&self, value: UnionTypes::StringOrBoolean) -> ();
    fn Union6Attribute(&self) -> UnionTypes::UnsignedLongOrBoolean;
    fn SetUnion6Attribute(&self, value: UnionTypes::UnsignedLongOrBoolean) -> ();
    fn Union7Attribute(&self) -> UnionTypes::BlobOrBoolean<TH>;
    fn SetUnion7Attribute(&self, value: UnionTypes::BlobOrBoolean<TH>) -> ();
    fn Union8Attribute(&self) -> UnionTypes::BlobOrUnsignedLong<TH>;
    fn SetUnion8Attribute(&self, value: UnionTypes::BlobOrUnsignedLong<TH>) -> ();
    fn Union9Attribute(&self) -> UnionTypes::ByteStringOrLong;
    fn SetUnion9Attribute(&self, value: UnionTypes::ByteStringOrLong) -> ();
    unsafe fn ArrayAttribute(&self, cx: *mut JSContext) -> NonNull<JSObject>;
    unsafe fn AnyAttribute(&self, cx: *mut JSContext) -> JSVal;
    unsafe fn SetAnyAttribute(&self, cx: *mut JSContext, value: HandleValue) -> ();
    unsafe fn ObjectAttribute(&self, cx: *mut JSContext) -> NonNull<JSObject>;
    unsafe fn SetObjectAttribute(&self, cx: *mut JSContext, value: *mut JSObject) -> ();
    fn GetBooleanAttributeNullable(&self) -> Option<bool>;
    fn SetBooleanAttributeNullable(&self, value: Option<bool>) -> ();
    fn GetByteAttributeNullable(&self) -> Option<i8>;
    fn SetByteAttributeNullable(&self, value: Option<i8>) -> ();
    fn GetOctetAttributeNullable(&self) -> Option<u8>;
    fn SetOctetAttributeNullable(&self, value: Option<u8>) -> ();
    fn GetShortAttributeNullable(&self) -> Option<i16>;
    fn SetShortAttributeNullable(&self, value: Option<i16>) -> ();
    fn GetUnsignedShortAttributeNullable(&self) -> Option<u16>;
    fn SetUnsignedShortAttributeNullable(&self, value: Option<u16>) -> ();
    fn GetLongAttributeNullable(&self) -> Option<i32>;
    fn SetLongAttributeNullable(&self, value: Option<i32>) -> ();
    fn GetUnsignedLongAttributeNullable(&self) -> Option<u32>;
    fn SetUnsignedLongAttributeNullable(&self, value: Option<u32>) -> ();
    fn GetLongLongAttributeNullable(&self) -> Option<i64>;
    fn SetLongLongAttributeNullable(&self, value: Option<i64>) -> ();
    fn GetUnsignedLongLongAttributeNullable(&self) -> Option<u64>;
    fn SetUnsignedLongLongAttributeNullable(&self, value: Option<u64>) -> ();
    fn GetUnrestrictedFloatAttributeNullable(&self) -> Option<f32>;
    fn SetUnrestrictedFloatAttributeNullable(&self, value: Option<f32>) -> ();
    fn GetFloatAttributeNullable(&self) -> Option<Finite<f32>>;
    fn SetFloatAttributeNullable(&self, value: Option<Finite<f32>>) -> ();
    fn GetUnrestrictedDoubleAttributeNullable(&self) -> Option<f64>;
    fn SetUnrestrictedDoubleAttributeNullable(&self, value: Option<f64>) -> ();
    fn GetDoubleAttributeNullable(&self) -> Option<Finite<f64>>;
    fn SetDoubleAttributeNullable(&self, value: Option<Finite<f64>>) -> ();
    fn GetStringAttributeNullable(&self) -> Option<DOMString>;
    fn SetStringAttributeNullable(&self, value: Option<DOMString>) -> ();
    fn GetUsvstringAttributeNullable(&self) -> Option<USVString>;
    fn SetUsvstringAttributeNullable(&self, value: Option<USVString>) -> ();
    fn GetByteStringAttributeNullable(&self) -> Option<ByteString>;
    fn SetByteStringAttributeNullable(&self, value: Option<ByteString>) -> ();
    fn GetEnumAttributeNullable(&self) -> Option<TestEnum>;
    fn GetInterfaceAttributeNullable(&self) -> Option<DomRoot<Blob<TH>>>;
    fn SetInterfaceAttributeNullable(&self, value: Option<&Blob<TH>>) -> ();
    fn GetInterfaceAttributeWeak(&self) -> Option<DomRoot<URL<TH>>>;
    fn SetInterfaceAttributeWeak(&self, value: Option<&URL<TH>>) -> ();
    unsafe fn GetObjectAttributeNullable(&self, cx: *mut JSContext) -> Option<NonNull<JSObject>>;
    unsafe fn SetObjectAttributeNullable(&self, cx: *mut JSContext, value: *mut JSObject) -> ();
    fn GetUnionAttributeNullable(&self) -> Option<UnionTypes::HTMLElementOrLong<TH>>;
    fn SetUnionAttributeNullable(&self, value: Option<UnionTypes::HTMLElementOrLong<TH>>) -> ();
    fn GetUnion2AttributeNullable(&self) -> Option<UnionTypes::EventOrString<TH>>;
    fn SetUnion2AttributeNullable(&self, value: Option<UnionTypes::EventOrString<TH>>) -> ();
    fn GetUnion3AttributeNullable(&self) -> Option<UnionTypes::BlobOrBoolean<TH>>;
    fn SetUnion3AttributeNullable(&self, value: Option<UnionTypes::BlobOrBoolean<TH>>) -> ();
    fn GetUnion4AttributeNullable(&self) -> Option<UnionTypes::UnsignedLongOrBoolean>;
    fn SetUnion4AttributeNullable(&self, value: Option<UnionTypes::UnsignedLongOrBoolean>) -> ();
    fn GetUnion5AttributeNullable(&self) -> Option<UnionTypes::StringOrBoolean>;
    fn SetUnion5AttributeNullable(&self, value: Option<UnionTypes::StringOrBoolean>) -> ();
    fn GetUnion6AttributeNullable(&self) -> Option<UnionTypes::ByteStringOrLong>;
    fn SetUnion6AttributeNullable(&self, value: Option<UnionTypes::ByteStringOrLong>) -> ();
    fn BinaryRenamedAttribute(&self) -> DOMString;
    fn SetBinaryRenamedAttribute(&self, value: DOMString) -> ();
    fn BinaryRenamedAttribute2(&self) -> DOMString;
    fn SetBinaryRenamedAttribute2(&self, value: DOMString) -> ();
    fn Attr_to_automatically_rename(&self) -> DOMString;
    fn SetAttr_to_automatically_rename(&self, value: DOMString) -> ();
    fn ForwardedAttribute(&self) -> DomRoot<TestBinding<TH>>;
    fn BinaryRenamedMethod(&self) -> ();
    fn ReceiveVoid(&self) -> ();
    fn ReceiveBoolean(&self) -> bool;
    fn ReceiveByte(&self) -> i8;
    fn ReceiveOctet(&self) -> u8;
    fn ReceiveShort(&self) -> i16;
    fn ReceiveUnsignedShort(&self) -> u16;
    fn ReceiveLong(&self) -> i32;
    fn ReceiveUnsignedLong(&self) -> u32;
    fn ReceiveLongLong(&self) -> i64;
    fn ReceiveUnsignedLongLong(&self) -> u64;
    fn ReceiveUnrestrictedFloat(&self) -> f32;
    fn ReceiveFloat(&self) -> Finite<f32>;
    fn ReceiveUnrestrictedDouble(&self) -> f64;
    fn ReceiveDouble(&self) -> Finite<f64>;
    fn ReceiveString(&self) -> DOMString;
    fn ReceiveUsvstring(&self) -> USVString;
    fn ReceiveByteString(&self) -> ByteString;
    fn ReceiveEnum(&self) -> TestEnum;
    fn ReceiveInterface(&self) -> DomRoot<Blob<TH>>;
    unsafe fn ReceiveAny(&self, cx: *mut JSContext) -> JSVal;
    unsafe fn ReceiveObject(&self, cx: *mut JSContext) -> NonNull<JSObject>;
    fn ReceiveUnion(&self) -> UnionTypes::HTMLElementOrLong<TH>;
    fn ReceiveUnion2(&self) -> UnionTypes::EventOrString<TH>;
    fn ReceiveUnion3(&self) -> UnionTypes::StringOrLongSequence;
    fn ReceiveUnion4(&self) -> UnionTypes::StringOrStringSequence;
    fn ReceiveUnion5(&self) -> UnionTypes::BlobOrBlobSequence<TH>;
    fn ReceiveUnion6(&self) -> UnionTypes::StringOrUnsignedLong;
    fn ReceiveUnion7(&self) -> UnionTypes::StringOrBoolean;
    fn ReceiveUnion8(&self) -> UnionTypes::UnsignedLongOrBoolean;
    fn ReceiveUnion9(&self) -> UnionTypes::HTMLElementOrUnsignedLongOrStringOrBoolean<TH>;
    fn ReceiveUnion10(&self) -> UnionTypes::ByteStringOrLong;
    fn ReceiveUnion11(&self) -> UnionTypes::ByteStringSequenceOrLongOrString;
    fn ReceiveSequence(&self) -> Vec<i32>;
    fn ReceiveInterfaceSequence(&self) -> Vec<DomRoot<Blob<TH>>>;
    fn ReceiveNullableByte(&self) -> Option<i8>;
    fn ReceiveNullableBoolean(&self) -> Option<bool>;
    fn ReceiveNullableOctet(&self) -> Option<u8>;
    fn ReceiveNullableShort(&self) -> Option<i16>;
    fn ReceiveNullableUnsignedShort(&self) -> Option<u16>;
    fn ReceiveNullableLong(&self) -> Option<i32>;
    fn ReceiveNullableUnsignedLong(&self) -> Option<u32>;
    fn ReceiveNullableLongLong(&self) -> Option<i64>;
    fn ReceiveNullableUnsignedLongLong(&self) -> Option<u64>;
    fn ReceiveNullableUnrestrictedFloat(&self) -> Option<f32>;
    fn ReceiveNullableFloat(&self) -> Option<Finite<f32>>;
    fn ReceiveNullableUnrestrictedDouble(&self) -> Option<f64>;
    fn ReceiveNullableDouble(&self) -> Option<Finite<f64>>;
    fn ReceiveNullableString(&self) -> Option<DOMString>;
    fn ReceiveNullableUsvstring(&self) -> Option<USVString>;
    fn ReceiveNullableByteString(&self) -> Option<ByteString>;
    fn ReceiveNullableEnum(&self) -> Option<TestEnum>;
    fn ReceiveNullableInterface(&self) -> Option<DomRoot<Blob<TH>>>;
    unsafe fn ReceiveNullableObject(&self, cx: *mut JSContext) -> Option<NonNull<JSObject>>;
    fn ReceiveNullableUnion(&self) -> Option<UnionTypes::HTMLElementOrLong<TH>>;
    fn ReceiveNullableUnion2(&self) -> Option<UnionTypes::EventOrString<TH>>;
    fn ReceiveNullableUnion3(&self) -> Option<UnionTypes::StringOrLongSequence>;
    fn ReceiveNullableUnion4(&self) -> Option<UnionTypes::LongSequenceOrBoolean>;
    fn ReceiveNullableUnion5(&self) -> Option<UnionTypes::UnsignedLongOrBoolean>;
    fn ReceiveNullableUnion6(&self) -> Option<UnionTypes::ByteStringOrLong>;
    fn ReceiveNullableSequence(&self) -> Option<Vec<i32>>;
    fn ReceiveTestDictionaryWithSuccessOnKeyword(&self) -> RootedTraceableBox<TestDictionary<TH>>;
    fn DictMatchesPassedValues(&self, arg: RootedTraceableBox<dom::bindings::codegen::Bindings::TestBindingBinding::TestDictionary<TH>>) -> bool;
    unsafe fn ReceiveUnionIdentity(&self, cx: *mut JSContext, arg: UnionTypes::StringOrObject) -> UnionTypes::StringOrObject;
    fn PassBoolean(&self, arg: bool) -> ();
    fn PassByte(&self, arg: i8) -> ();
    fn PassOctet(&self, arg: u8) -> ();
    fn PassShort(&self, arg: i16) -> ();
    fn PassUnsignedShort(&self, arg: u16) -> ();
    fn PassLong(&self, arg: i32) -> ();
    fn PassUnsignedLong(&self, arg: u32) -> ();
    fn PassLongLong(&self, arg: i64) -> ();
    fn PassUnsignedLongLong(&self, arg: u64) -> ();
    fn PassUnrestrictedFloat(&self, arg: f32) -> ();
    fn PassFloat(&self, arg: Finite<f32>) -> ();
    fn PassUnrestrictedDouble(&self, arg: f64) -> ();
    fn PassDouble(&self, arg: Finite<f64>) -> ();
    fn PassString(&self, arg: DOMString) -> ();
    fn PassUsvstring(&self, arg: USVString) -> ();
    fn PassByteString(&self, arg: ByteString) -> ();
    fn PassEnum(&self, arg: TestEnum) -> ();
    fn PassInterface(&self, arg: &Blob<TH>) -> ();
    fn PassTypedArray(&self, arg: CustomAutoRooterGuard<typedarray::Int8Array>) -> ();
    fn PassTypedArray2(&self, arg: CustomAutoRooterGuard<typedarray::ArrayBuffer>) -> ();
    fn PassTypedArray3(&self, arg: CustomAutoRooterGuard<typedarray::ArrayBufferView>) -> ();
    fn PassUnion(&self, arg: UnionTypes::HTMLElementOrLong<TH>) -> ();
    fn PassUnion2(&self, data: UnionTypes::EventOrString<TH>) -> ();
    fn PassUnion3(&self, data: UnionTypes::BlobOrString<TH>) -> ();
    fn PassUnion4(&self, seq: UnionTypes::StringOrStringSequence) -> ();
    fn PassUnion5(&self, data: UnionTypes::StringOrBoolean) -> ();
    fn PassUnion6(&self, bool: UnionTypes::UnsignedLongOrBoolean) -> ();
    fn PassUnion7(&self, arg: UnionTypes::StringSequenceOrUnsignedLong) -> ();
    fn PassUnion8(&self, arg: UnionTypes::ByteStringSequenceOrLong) -> ();
    fn PassUnion9(&self, arg: UnionTypes::TestDictionaryOrLong<TH>) -> ();
    unsafe fn PassUnion10(&self, cx: *mut JSContext, arg: UnionTypes::StringOrObject) -> ();
    fn PassUnion11(&self, arg: UnionTypes::ArrayBufferOrArrayBufferView) -> ();
    fn PassUnionWithTypedef(&self, arg: UnionTypes::DocumentOrTestTypedef<TH>) -> ();
    fn PassUnionWithTypedef2(&self, arg: UnionTypes::LongSequenceOrTestTypedef<TH>) -> ();
    unsafe fn PassAny(&self, cx: *mut JSContext, arg: HandleValue) -> ();
    unsafe fn PassObject(&self, cx: *mut JSContext, arg: *mut JSObject) -> ();
    fn PassCallbackFunction(&self, fun: Rc<Function<TH>>) -> ();
    fn PassCallbackInterface(&self, listener: Rc<dom::bindings::codegen::Bindings::EventListenerBinding::EventListener<TH>>) -> ();
    fn PassSequence(&self, seq: Vec<i32>) -> ();
    unsafe fn PassAnySequence(&self, cx: *mut JSContext, seq: CustomAutoRooterGuard<Vec<JSVal>>) -> ();
    unsafe fn AnySequencePassthrough(&self, cx: *mut JSContext, seq: CustomAutoRooterGuard<Vec<JSVal>>) -> Vec<JSVal>;
    unsafe fn PassObjectSequence(&self, cx: *mut JSContext, seq: CustomAutoRooterGuard<Vec<*mut JSObject>>) -> ();
    fn PassStringSequence(&self, seq: Vec<DOMString>) -> ();
    fn PassInterfaceSequence(&self, seq: Vec<DomRoot<Blob<TH>>>) -> ();
    fn PassOverloaded(&self, arg: CustomAutoRooterGuard<typedarray::ArrayBuffer>) -> ();
    fn PassOverloaded_(&self, arg: DOMString) -> ();
    fn PassNullableBoolean(&self, arg: Option<bool>) -> ();
    fn PassNullableByte(&self, arg: Option<i8>) -> ();
    fn PassNullableOctet(&self, arg: Option<u8>) -> ();
    fn PassNullableShort(&self, arg: Option<i16>) -> ();
    fn PassNullableUnsignedShort(&self, arg: Option<u16>) -> ();
    fn PassNullableLong(&self, arg: Option<i32>) -> ();
    fn PassNullableUnsignedLong(&self, arg: Option<u32>) -> ();
    fn PassNullableLongLong(&self, arg: Option<i64>) -> ();
    fn PassNullableUnsignedLongLong(&self, arg: Option<u64>) -> ();
    fn PassNullableUnrestrictedFloat(&self, arg: Option<f32>) -> ();
    fn PassNullableFloat(&self, arg: Option<Finite<f32>>) -> ();
    fn PassNullableUnrestrictedDouble(&self, arg: Option<f64>) -> ();
    fn PassNullableDouble(&self, arg: Option<Finite<f64>>) -> ();
    fn PassNullableString(&self, arg: Option<DOMString>) -> ();
    fn PassNullableUsvstring(&self, arg: Option<USVString>) -> ();
    fn PassNullableByteString(&self, arg: Option<ByteString>) -> ();
    fn PassNullableInterface(&self, arg: Option<&Blob<TH>>) -> ();
    unsafe fn PassNullableObject(&self, cx: *mut JSContext, arg: *mut JSObject) -> ();
    fn PassNullableTypedArray(&self, arg: CustomAutoRooterGuard<Option<typedarray::Int8Array>>) -> ();
    fn PassNullableUnion(&self, arg: Option<UnionTypes::HTMLElementOrLong<TH>>) -> ();
    fn PassNullableUnion2(&self, data: Option<UnionTypes::EventOrString<TH>>) -> ();
    fn PassNullableUnion3(&self, data: Option<UnionTypes::StringOrLongSequence>) -> ();
    fn PassNullableUnion4(&self, bool: Option<UnionTypes::LongSequenceOrBoolean>) -> ();
    fn PassNullableUnion5(&self, arg: Option<UnionTypes::UnsignedLongOrBoolean>) -> ();
    fn PassNullableUnion6(&self, arg: Option<UnionTypes::ByteStringOrLong>) -> ();
    fn PassNullableCallbackFunction(&self, fun: Option<Rc<Function<TH>>>) -> ();
    fn PassNullableCallbackInterface(&self, listener: Option<Rc<dom::bindings::codegen::Bindings::EventListenerBinding::EventListener<TH>>>) -> ();
    fn PassNullableSequence(&self, seq: Option<Vec<i32> >) -> ();
    fn PassOptionalBoolean(&self, arg: Option<bool>) -> ();
    fn PassOptionalByte(&self, arg: Option<i8>) -> ();
    fn PassOptionalOctet(&self, arg: Option<u8>) -> ();
    fn PassOptionalShort(&self, arg: Option<i16>) -> ();
    fn PassOptionalUnsignedShort(&self, arg: Option<u16>) -> ();
    fn PassOptionalLong(&self, arg: Option<i32>) -> ();
    fn PassOptionalUnsignedLong(&self, arg: Option<u32>) -> ();
    fn PassOptionalLongLong(&self, arg: Option<i64>) -> ();
    fn PassOptionalUnsignedLongLong(&self, arg: Option<u64>) -> ();
    fn PassOptionalUnrestrictedFloat(&self, arg: Option<f32>) -> ();
    fn PassOptionalFloat(&self, arg: Option<Finite<f32>>) -> ();
    fn PassOptionalUnrestrictedDouble(&self, arg: Option<f64>) -> ();
    fn PassOptionalDouble(&self, arg: Option<Finite<f64>>) -> ();
    fn PassOptionalString(&self, arg: Option<DOMString>) -> ();
    fn PassOptionalUsvstring(&self, arg: Option<USVString>) -> ();
    fn PassOptionalByteString(&self, arg: Option<ByteString>) -> ();
    fn PassOptionalEnum(&self, arg: Option<TestEnum>) -> ();
    fn PassOptionalInterface(&self, arg: Option<&Blob<TH>>) -> ();
    fn PassOptionalUnion(&self, arg: Option<UnionTypes::HTMLElementOrLong<TH>>) -> ();
    fn PassOptionalUnion2(&self, data: Option<UnionTypes::EventOrString<TH>>) -> ();
    fn PassOptionalUnion3(&self, arg: Option<UnionTypes::StringOrLongSequence>) -> ();
    fn PassOptionalUnion4(&self, data: Option<UnionTypes::LongSequenceOrBoolean>) -> ();
    fn PassOptionalUnion5(&self, bool: Option<UnionTypes::UnsignedLongOrBoolean>) -> ();
    fn PassOptionalUnion6(&self, arg: Option<UnionTypes::ByteStringOrLong>) -> ();
    unsafe fn PassOptionalAny(&self, cx: *mut JSContext, arg: HandleValue) -> ();
    unsafe fn PassOptionalObject(&self, cx: *mut JSContext, arg: Option<*mut JSObject>) -> ();
    fn PassOptionalCallbackFunction(&self, fun: Option<Rc<Function<TH>>>) -> ();
    fn PassOptionalCallbackInterface(&self, listener: Option<Rc<dom::bindings::codegen::Bindings::EventListenerBinding::EventListener<TH>>>) -> ();
    fn PassOptionalSequence(&self, seq: Option<Vec<i32>>) -> ();
    fn PassOptionalNullableBoolean(&self, arg: Option<Option<bool>>) -> ();
    fn PassOptionalNullableByte(&self, arg: Option<Option<i8>>) -> ();
    fn PassOptionalNullableOctet(&self, arg: Option<Option<u8>>) -> ();
    fn PassOptionalNullableShort(&self, arg: Option<Option<i16>>) -> ();
    fn PassOptionalNullableUnsignedShort(&self, arg: Option<Option<u16>>) -> ();
    fn PassOptionalNullableLong(&self, arg: Option<Option<i32>>) -> ();
    fn PassOptionalNullableUnsignedLong(&self, arg: Option<Option<u32>>) -> ();
    fn PassOptionalNullableLongLong(&self, arg: Option<Option<i64>>) -> ();
    fn PassOptionalNullableUnsignedLongLong(&self, arg: Option<Option<u64>>) -> ();
    fn PassOptionalNullableUnrestrictedFloat(&self, arg: Option<Option<f32>>) -> ();
    fn PassOptionalNullableFloat(&self, arg: Option<Option<Finite<f32>>>) -> ();
    fn PassOptionalNullableUnrestrictedDouble(&self, arg: Option<Option<f64>>) -> ();
    fn PassOptionalNullableDouble(&self, arg: Option<Option<Finite<f64>>>) -> ();
    fn PassOptionalNullableString(&self, arg: Option<Option<DOMString>>) -> ();
    fn PassOptionalNullableUsvstring(&self, arg: Option<Option<USVString>>) -> ();
    fn PassOptionalNullableByteString(&self, arg: Option<Option<ByteString>>) -> ();
    fn PassOptionalNullableInterface(&self, arg: Option<Option<&Blob<TH>>>) -> ();
    unsafe fn PassOptionalNullableObject(&self, cx: *mut JSContext, arg: Option<*mut JSObject>) -> ();
    fn PassOptionalNullableUnion(&self, arg: Option<Option<UnionTypes::HTMLElementOrLong<TH>>>) -> ();
    fn PassOptionalNullableUnion2(&self, data: Option<Option<UnionTypes::EventOrString<TH>>>) -> ();
    fn PassOptionalNullableUnion3(&self, arg: Option<Option<UnionTypes::StringOrLongSequence>>) -> ();
    fn PassOptionalNullableUnion4(&self, data: Option<Option<UnionTypes::LongSequenceOrBoolean>>) -> ();
    fn PassOptionalNullableUnion5(&self, bool: Option<Option<UnionTypes::UnsignedLongOrBoolean>>) -> ();
    fn PassOptionalNullableUnion6(&self, arg: Option<Option<UnionTypes::ByteStringOrLong>>) -> ();
    fn PassOptionalNullableCallbackFunction(&self, fun: Option<Option<Rc<Function<TH>>>>) -> ();
    fn PassOptionalNullableCallbackInterface(&self, listener: Option<Option<Rc<dom::bindings::codegen::Bindings::EventListenerBinding::EventListener<TH>>>>) -> ();
    fn PassOptionalNullableSequence(&self, seq: Option<Option<Vec<i32> >>) -> ();
    fn PassOptionalBooleanWithDefault(&self, arg: bool) -> ();
    fn PassOptionalByteWithDefault(&self, arg: i8) -> ();
    fn PassOptionalOctetWithDefault(&self, arg: u8) -> ();
    fn PassOptionalShortWithDefault(&self, arg: i16) -> ();
    fn PassOptionalUnsignedShortWithDefault(&self, arg: u16) -> ();
    fn PassOptionalLongWithDefault(&self, arg: i32) -> ();
    fn PassOptionalUnsignedLongWithDefault(&self, arg: u32) -> ();
    fn PassOptionalLongLongWithDefault(&self, arg: i64) -> ();
    fn PassOptionalUnsignedLongLongWithDefault(&self, arg: u64) -> ();
    fn PassOptionalBytestringWithDefault(&self, arg: ByteString) -> ();
    fn PassOptionalStringWithDefault(&self, arg: DOMString) -> ();
    fn PassOptionalUsvstringWithDefault(&self, arg: USVString) -> ();
    fn PassOptionalEnumWithDefault(&self, arg: TestEnum) -> ();
    fn PassOptionalNullableBooleanWithDefault(&self, arg: Option<bool>) -> ();
    fn PassOptionalNullableByteWithDefault(&self, arg: Option<i8>) -> ();
    fn PassOptionalNullableOctetWithDefault(&self, arg: Option<u8>) -> ();
    fn PassOptionalNullableShortWithDefault(&self, arg: Option<i16>) -> ();
    fn PassOptionalNullableUnsignedShortWithDefault(&self, arg: Option<u16>) -> ();
    fn PassOptionalNullableLongWithDefault(&self, arg: Option<i32>) -> ();
    fn PassOptionalNullableUnsignedLongWithDefault(&self, arg: Option<u32>) -> ();
    fn PassOptionalNullableLongLongWithDefault(&self, arg: Option<i64>) -> ();
    fn PassOptionalNullableUnsignedLongLongWithDefault(&self, arg: Option<u64>) -> ();
    fn PassOptionalNullableStringWithDefault(&self, arg: Option<DOMString>) -> ();
    fn PassOptionalNullableUsvstringWithDefault(&self, arg: Option<USVString>) -> ();
    fn PassOptionalNullableByteStringWithDefault(&self, arg: Option<ByteString>) -> ();
    fn PassOptionalNullableInterfaceWithDefault(&self, arg: Option<&Blob<TH>>) -> ();
    unsafe fn PassOptionalNullableObjectWithDefault(&self, cx: *mut JSContext, arg: *mut JSObject) -> ();
    fn PassOptionalNullableUnionWithDefault(&self, arg: Option<UnionTypes::HTMLElementOrLong<TH>>) -> ();
    fn PassOptionalNullableUnion2WithDefault(&self, data: Option<UnionTypes::EventOrString<TH>>) -> ();
    fn PassOptionalNullableCallbackInterfaceWithDefault(&self, listener: Option<Rc<dom::bindings::codegen::Bindings::EventListenerBinding::EventListener<TH>>>) -> ();
    unsafe fn PassOptionalAnyWithDefault(&self, cx: *mut JSContext, arg: HandleValue) -> ();
    fn PassOptionalNullableBooleanWithNonNullDefault(&self, arg: Option<bool>) -> ();
    fn PassOptionalNullableByteWithNonNullDefault(&self, arg: Option<i8>) -> ();
    fn PassOptionalNullableOctetWithNonNullDefault(&self, arg: Option<u8>) -> ();
    fn PassOptionalNullableShortWithNonNullDefault(&self, arg: Option<i16>) -> ();
    fn PassOptionalNullableUnsignedShortWithNonNullDefault(&self, arg: Option<u16>) -> ();
    fn PassOptionalNullableLongWithNonNullDefault(&self, arg: Option<i32>) -> ();
    fn PassOptionalNullableUnsignedLongWithNonNullDefault(&self, arg: Option<u32>) -> ();
    fn PassOptionalNullableLongLongWithNonNullDefault(&self, arg: Option<i64>) -> ();
    fn PassOptionalNullableUnsignedLongLongWithNonNullDefault(&self, arg: Option<u64>) -> ();
    fn PassOptionalNullableStringWithNonNullDefault(&self, arg: Option<DOMString>) -> ();
    fn PassOptionalNullableUsvstringWithNonNullDefault(&self, arg: Option<USVString>) -> ();
    fn PassOptionalOverloaded(&self, arg0: &TestBinding<TH>, arg1: u32, arg2: u32) -> DomRoot<TestBinding<TH>>;
    fn PassOptionalOverloaded_(&self, arg0: &Blob<TH>, arg1: u32) -> ();
    fn PassVariadicBoolean(&self, args: Vec<bool>) -> ();
    fn PassVariadicBooleanAndDefault(&self, arg: bool, args: Vec<bool>) -> ();
    fn PassVariadicByte(&self, args: Vec<i8>) -> ();
    fn PassVariadicOctet(&self, args: Vec<u8>) -> ();
    fn PassVariadicShort(&self, args: Vec<i16>) -> ();
    fn PassVariadicUnsignedShort(&self, args: Vec<u16>) -> ();
    fn PassVariadicLong(&self, args: Vec<i32>) -> ();
    fn PassVariadicUnsignedLong(&self, args: Vec<u32>) -> ();
    fn PassVariadicLongLong(&self, args: Vec<i64>) -> ();
    fn PassVariadicUnsignedLongLong(&self, args: Vec<u64>) -> ();
    fn PassVariadicUnrestrictedFloat(&self, args: Vec<f32>) -> ();
    fn PassVariadicFloat(&self, args: Vec<Finite<f32>>) -> ();
    fn PassVariadicUnrestrictedDouble(&self, args: Vec<f64>) -> ();
    fn PassVariadicDouble(&self, args: Vec<Finite<f64>>) -> ();
    fn PassVariadicString(&self, args: Vec<DOMString>) -> ();
    fn PassVariadicUsvstring(&self, args: Vec<USVString>) -> ();
    fn PassVariadicByteString(&self, args: Vec<ByteString>) -> ();
    fn PassVariadicEnum(&self, args: Vec<TestEnum>) -> ();
    fn PassVariadicInterface(&self, args: &[&Blob<TH>]) -> ();
    fn PassVariadicUnion(&self, args: Vec<UnionTypes::HTMLElementOrLong<TH>>) -> ();
    fn PassVariadicUnion2(&self, args: Vec<UnionTypes::EventOrString<TH>>) -> ();
    fn PassVariadicUnion3(&self, args: Vec<UnionTypes::BlobOrString<TH>>) -> ();
    fn PassVariadicUnion4(&self, args: Vec<UnionTypes::BlobOrBoolean<TH>>) -> ();
    fn PassVariadicUnion5(&self, args: Vec<UnionTypes::StringOrUnsignedLong>) -> ();
    fn PassVariadicUnion6(&self, args: Vec<UnionTypes::UnsignedLongOrBoolean>) -> ();
    fn PassVariadicUnion7(&self, args: Vec<UnionTypes::ByteStringOrLong>) -> ();
    unsafe fn PassVariadicAny(&self, cx: *mut JSContext, args: Vec<HandleValue>) -> ();
    unsafe fn PassVariadicObject(&self, cx: *mut JSContext, args: Vec<*mut JSObject>) -> ();
    fn PassSequenceSequence(&self, seq: Vec<Vec<i32>>) -> ();
    fn ReturnSequenceSequence(&self) -> Vec<Vec<i32>>;
    fn PassUnionSequenceSequence(&self, seq: UnionTypes::LongOrLongSequenceSequence) -> ();
    fn PassMozMap(&self, arg: MozMap<i32>) -> ();
    fn PassNullableMozMap(&self, arg: Option<MozMap<i32> >) -> ();
    fn PassMozMapOfNullableInts(&self, arg: MozMap<Option<i32>>) -> ();
    fn PassOptionalMozMapOfNullableInts(&self, arg: Option<MozMap<Option<i32>>>) -> ();
    fn PassOptionalNullableMozMapOfNullableInts(&self, arg: Option<Option<MozMap<Option<i32>> >>) -> ();
    fn PassCastableObjectMozMap(&self, arg: MozMap<DomRoot<TestBinding<TH>>>) -> ();
    fn PassNullableCastableObjectMozMap(&self, arg: MozMap<Option<DomRoot<TestBinding<TH>>>>) -> ();
    fn PassCastableObjectNullableMozMap(&self, arg: Option<MozMap<DomRoot<TestBinding<TH>>> >) -> ();
    fn PassNullableCastableObjectNullableMozMap(&self, arg: Option<MozMap<Option<DomRoot<TestBinding<TH>>>> >) -> ();
    fn PassOptionalMozMap(&self, arg: Option<MozMap<i32>>) -> ();
    fn PassOptionalNullableMozMap(&self, arg: Option<Option<MozMap<i32> >>) -> ();
    fn PassOptionalNullableMozMapWithDefaultValue(&self, arg: Option<MozMap<i32> >) -> ();
    fn PassOptionalObjectMozMap(&self, arg: Option<MozMap<DomRoot<TestBinding<TH>>>>) -> ();
    fn PassStringMozMap(&self, arg: MozMap<DOMString>) -> ();
    fn PassByteStringMozMap(&self, arg: MozMap<ByteString>) -> ();
    fn PassMozMapOfMozMaps(&self, arg: MozMap<MozMap<i32>>) -> ();
    fn PassMozMapUnion(&self, init: UnionTypes::LongOrStringByteStringRecord) -> ();
    fn PassMozMapUnion2(&self, init: UnionTypes::TestBindingOrStringByteStringRecord<TH>) -> ();
    fn PassMozMapUnion3(&self, init: UnionTypes::TestBindingOrByteStringSequenceSequenceOrStringByteStringRecord<TH>) -> ();
    fn ReceiveMozMap(&self) -> MozMap<i32>;
    fn ReceiveNullableMozMap(&self) -> Option<MozMap<i32>>;
    fn ReceiveMozMapOfNullableInts(&self) -> MozMap<Option<i32>>;
    fn ReceiveNullableMozMapOfNullableInts(&self) -> Option<MozMap<Option<i32>>>;
    fn ReceiveMozMapOfMozMaps(&self) -> MozMap<MozMap<i32>>;
    fn ReceiveAnyMozMap(&self) -> MozMap<JSVal>;
    fn BooleanMozPreference(&self, pref_name: DOMString) -> bool;
    fn StringMozPreference(&self, pref_name: DOMString) -> DOMString;
    fn PrefControlledAttributeDisabled(&self) -> bool;
    fn PrefControlledMethodDisabled(&self) -> ();
    fn AdvanceClock(&self, millis: i32, forceLayoutTick: bool) -> ();
    fn PrefControlledAttributeEnabled(&self) -> bool;
    fn PrefControlledMethodEnabled(&self) -> ();
    fn FuncControlledAttributeDisabled(&self) -> bool;
    fn FuncControlledMethodDisabled(&self) -> ();
    fn FuncControlledAttributeEnabled(&self) -> bool;
    fn FuncControlledMethodEnabled(&self) -> ();
    unsafe fn ReturnResolvedPromise(&self, cx: *mut JSContext, value: HandleValue) -> Fallible<Rc<Promise<TH>>, TH>;
    unsafe fn ReturnRejectedPromise(&self, cx: *mut JSContext, value: HandleValue) -> Fallible<Rc<Promise<TH>>, TH>;
    fn PromiseAttribute(&self) -> Rc<Promise<TH>>;
    fn AcceptPromise(&self, string: &Promise<TH>) -> ();
    fn PromiseNativeHandler(&self, resolve: Option<Rc<SimpleCallback<TH>>>, reject: Option<Rc<SimpleCallback<TH>>>) -> Rc<Promise<TH>>;
    unsafe fn PromiseResolveNative(&self, cx: *mut JSContext, p: &Promise<TH>, value: HandleValue) -> ();
    unsafe fn PromiseRejectNative(&self, cx: *mut JSContext, p: &Promise<TH>, value: HandleValue) -> ();
    fn PromiseRejectWithTypeError(&self, p: &Promise<TH>, message: USVString) -> ();
    fn ResolvePromiseDelayed(&self, p: &Promise<TH>, value: DOMString, ms: u64) -> ();
    fn Panic(&self) -> ();
    fn EntryGlobal(&self) -> DomRoot<GlobalScope<TH>>;
    fn IncumbentGlobal(&self) -> DomRoot<GlobalScope<TH>>;
    fn CrashHard(&self) -> ();
}
fn sStaticMethods_specs<TH: TypeHolderTrait>() -> &'static [&'static[JSFunctionSpec]] { &[
&[
    JSFunctionSpec {
        name: b"receiveVoidStatic\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(receiveVoidStatic::<TH>), info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]
,
&[
    JSFunctionSpec {
        name: b"prefControlledStaticMethodDisabled\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(prefControlledStaticMethodDisabled::<TH>), info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]
,
&[
    JSFunctionSpec {
        name: b"prefControlledStaticMethodEnabled\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(prefControlledStaticMethodEnabled::<TH>), info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]
,
&[
    JSFunctionSpec {
        name: b"funcControlledStaticMethodDisabled\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(funcControlledStaticMethodDisabled::<TH>), info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]
,
&[
    JSFunctionSpec {
        name: b"funcControlledStaticMethodEnabled\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(funcControlledStaticMethodEnabled::<TH>), info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]

]}
fn sStaticMethods<TH: TypeHolderTrait>() -> &'static [Guard<&'static [JSFunctionSpec]>] { &[
    Guard::new(Condition::Satisfied, sStaticMethods_specs::<TH>()[0]),
    Guard::new(Condition::Pref("dom.testbinding.prefcontrolled.enabled"), sStaticMethods_specs::<TH>()[1]),
    Guard::new(Condition::Pref("dom.testbinding.prefcontrolled2.enabled"), sStaticMethods_specs::<TH>()[2]),
    Guard::new(Condition::Func(TestBinding::<TH>::condition_satisfied), sStaticMethods_specs::<TH>()[3]),
    Guard::new(Condition::Func(TestBinding::<TH>::condition_satisfied), sStaticMethods_specs::<TH>()[4])
]}
fn sStaticAttributes_specs<TH: TypeHolderTrait>() -> &'static [&'static[JSPropertySpec]] { &[
&[
    JSPropertySpec {
        name: b"booleanAttributeStatic\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(get_booleanAttributeStatic::<TH>), info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: Some(set_booleanAttributeStatic::<TH>), info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]
,
&[
    JSPropertySpec {
        name: b"prefControlledStaticAttributeDisabled\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(get_prefControlledStaticAttributeDisabled::<TH>), info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]
,
&[
    JSPropertySpec {
        name: b"prefControlledStaticAttributeEnabled\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(get_prefControlledStaticAttributeEnabled::<TH>), info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]
,
&[
    JSPropertySpec {
        name: b"funcControlledStaticAttributeDisabled\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(get_funcControlledStaticAttributeDisabled::<TH>), info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]
,
&[
    JSPropertySpec {
        name: b"funcControlledStaticAttributeEnabled\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(get_funcControlledStaticAttributeEnabled::<TH>), info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]

]}
fn sStaticAttributes<TH: TypeHolderTrait>() -> &'static [Guard<&'static [JSPropertySpec]>] { &[
    Guard::new(Condition::Satisfied, sStaticAttributes_specs::<TH>()[0]),
    Guard::new(Condition::Pref("dom.testbinding.prefcontrolled.enabled"), sStaticAttributes_specs::<TH>()[1]),
    Guard::new(Condition::Pref("dom.testbinding.prefcontrolled2.enabled"), sStaticAttributes_specs::<TH>()[2]),
    Guard::new(Condition::Func(TestBinding::<TH>::condition_satisfied), sStaticAttributes_specs::<TH>()[3]),
    Guard::new(Condition::Func(TestBinding::<TH>::condition_satisfied), sStaticAttributes_specs::<TH>()[4])
]}
fn sMethods_specs<TH: TypeHolderTrait>() -> &'static [&'static[JSFunctionSpec]] { &[
&[
    JSFunctionSpec {
        name: b"methToBinaryRename\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &methToBinaryRename_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveVoid\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveVoid_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveBoolean\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveBoolean_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveByte\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveByte_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveOctet\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveOctet_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveShort\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveShort_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnsignedShort\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnsignedShort_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveLong_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnsignedLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnsignedLong_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveLongLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveLongLong_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnsignedLongLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnsignedLongLong_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnrestrictedFloat\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnrestrictedFloat_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveFloat\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveFloat_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnrestrictedDouble\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnrestrictedDouble_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveDouble\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveDouble_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveString\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveString_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUsvstring\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUsvstring_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveByteString\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveByteString_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveEnum\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveEnum_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveInterface\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveInterface_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveAny\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveAny_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveObject\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveObject_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnion\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnion_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnion2\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnion2_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnion3\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnion3_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnion4\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnion4_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnion5\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnion5_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnion6\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnion6_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnion7\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnion7_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnion8\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnion8_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnion9\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnion9_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnion10\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnion10_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnion11\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnion11_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveSequence\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveSequence_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveInterfaceSequence\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveInterfaceSequence_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableByte\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableByte_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableBoolean\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableBoolean_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableOctet\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableOctet_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableShort\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableShort_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableUnsignedShort\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableUnsignedShort_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableLong_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableUnsignedLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableUnsignedLong_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableLongLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableLongLong_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableUnsignedLongLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableUnsignedLongLong_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableUnrestrictedFloat\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableUnrestrictedFloat_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableFloat\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableFloat_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableUnrestrictedDouble\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableUnrestrictedDouble_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableDouble\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableDouble_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableString\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableString_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableUsvstring\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableUsvstring_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableByteString\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableByteString_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableEnum\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableEnum_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableInterface\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableInterface_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableObject\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableObject_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableUnion\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableUnion_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableUnion2\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableUnion2_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableUnion3\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableUnion3_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableUnion4\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableUnion4_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableUnion5\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableUnion5_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableUnion6\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableUnion6_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableSequence\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableSequence_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveTestDictionaryWithSuccessOnKeyword\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveTestDictionaryWithSuccessOnKeyword_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"dictMatchesPassedValues\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &dictMatchesPassedValues_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnionIdentity\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnionIdentity_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passBoolean\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passBoolean_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passByte\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passByte_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOctet\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOctet_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passShort\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passShort_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnsignedShort\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnsignedShort_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passLong_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnsignedLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnsignedLong_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passLongLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passLongLong_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnsignedLongLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnsignedLongLong_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnrestrictedFloat\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnrestrictedFloat_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passFloat\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passFloat_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnrestrictedDouble\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnrestrictedDouble_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passDouble\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passDouble_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passString\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passString_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUsvstring\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUsvstring_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passByteString\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passByteString_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passEnum\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passEnum_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passInterface\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passInterface_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passTypedArray\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passTypedArray_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passTypedArray2\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passTypedArray2_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passTypedArray3\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passTypedArray3_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnion\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnion_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnion2\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnion2_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnion3\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnion3_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnion4\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnion4_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnion5\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnion5_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnion6\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnion6_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnion7\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnion7_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnion8\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnion8_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnion9\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnion9_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnion10\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnion10_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnion11\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnion11_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnionWithTypedef\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnionWithTypedef_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnionWithTypedef2\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnionWithTypedef2_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passAny\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passAny_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passObject\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passObject_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passCallbackFunction\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passCallbackFunction_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passCallbackInterface\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passCallbackInterface_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passSequence\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passSequence_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passAnySequence\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passAnySequence_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"anySequencePassthrough\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &anySequencePassthrough_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passObjectSequence\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passObjectSequence_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passStringSequence\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passStringSequence_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passInterfaceSequence\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passInterfaceSequence_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOverloaded\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOverloaded_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableBoolean\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableBoolean_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableByte\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableByte_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableOctet\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableOctet_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableShort\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableShort_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableUnsignedShort\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableUnsignedShort_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableLong_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableUnsignedLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableUnsignedLong_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableLongLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableLongLong_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableUnsignedLongLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableUnsignedLongLong_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableUnrestrictedFloat\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableUnrestrictedFloat_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableFloat\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableFloat_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableUnrestrictedDouble\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableUnrestrictedDouble_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableDouble\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableDouble_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableString\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableString_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableUsvstring\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableUsvstring_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableByteString\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableByteString_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableInterface\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableInterface_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableObject\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableObject_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableTypedArray\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableTypedArray_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableUnion\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableUnion_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableUnion2\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableUnion2_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableUnion3\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableUnion3_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableUnion4\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableUnion4_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableUnion5\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableUnion5_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableUnion6\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableUnion6_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableCallbackFunction\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableCallbackFunction_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableCallbackInterface\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableCallbackInterface_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableSequence\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableSequence_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalBoolean\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalBoolean_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalByte\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalByte_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalOctet\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalOctet_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalShort\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalShort_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUnsignedShort\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUnsignedShort_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalLong_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUnsignedLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUnsignedLong_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalLongLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalLongLong_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUnsignedLongLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUnsignedLongLong_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUnrestrictedFloat\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUnrestrictedFloat_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalFloat\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalFloat_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUnrestrictedDouble\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUnrestrictedDouble_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalDouble\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalDouble_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalString\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalString_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUsvstring\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUsvstring_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalByteString\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalByteString_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalEnum\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalEnum_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalInterface\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalInterface_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUnion\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUnion_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUnion2\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUnion2_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUnion3\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUnion3_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUnion4\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUnion4_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUnion5\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUnion5_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUnion6\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUnion6_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalAny\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalAny_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalObject\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalObject_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalCallbackFunction\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalCallbackFunction_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalCallbackInterface\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalCallbackInterface_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalSequence\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalSequence_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableBoolean\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableBoolean_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableByte\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableByte_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableOctet\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableOctet_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableShort\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableShort_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnsignedShort\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnsignedShort_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableLong_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnsignedLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnsignedLong_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableLongLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableLongLong_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnsignedLongLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnsignedLongLong_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnrestrictedFloat\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnrestrictedFloat_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableFloat\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableFloat_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnrestrictedDouble\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnrestrictedDouble_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableDouble\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableDouble_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableString\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableString_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUsvstring\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUsvstring_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableByteString\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableByteString_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableInterface\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableInterface_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableObject\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableObject_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnion\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnion_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnion2\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnion2_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnion3\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnion3_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnion4\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnion4_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnion5\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnion5_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnion6\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnion6_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableCallbackFunction\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableCallbackFunction_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableCallbackInterface\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableCallbackInterface_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableSequence\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableSequence_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalBooleanWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalBooleanWithDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalByteWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalByteWithDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalOctetWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalOctetWithDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalShortWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalShortWithDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUnsignedShortWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUnsignedShortWithDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalLongWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalLongWithDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUnsignedLongWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUnsignedLongWithDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalLongLongWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalLongLongWithDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUnsignedLongLongWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUnsignedLongLongWithDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalBytestringWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalBytestringWithDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalStringWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalStringWithDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUsvstringWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUsvstringWithDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalEnumWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalEnumWithDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableBooleanWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableBooleanWithDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableByteWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableByteWithDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableOctetWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableOctetWithDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableShortWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableShortWithDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnsignedShortWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnsignedShortWithDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableLongWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableLongWithDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnsignedLongWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnsignedLongWithDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableLongLongWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableLongLongWithDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnsignedLongLongWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnsignedLongLongWithDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableStringWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableStringWithDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUsvstringWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUsvstringWithDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableByteStringWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableByteStringWithDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableInterfaceWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableInterfaceWithDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableObjectWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableObjectWithDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnionWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnionWithDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnion2WithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnion2WithDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableCallbackInterfaceWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableCallbackInterfaceWithDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalAnyWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalAnyWithDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableBooleanWithNonNullDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableBooleanWithNonNullDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableByteWithNonNullDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableByteWithNonNullDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableOctetWithNonNullDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableOctetWithNonNullDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableShortWithNonNullDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableShortWithNonNullDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnsignedShortWithNonNullDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnsignedShortWithNonNullDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableLongWithNonNullDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableLongWithNonNullDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnsignedLongWithNonNullDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnsignedLongWithNonNullDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableLongLongWithNonNullDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableLongLongWithNonNullDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnsignedLongLongWithNonNullDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnsignedLongLongWithNonNullDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableStringWithNonNullDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableStringWithNonNullDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUsvstringWithNonNullDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUsvstringWithNonNullDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalOverloaded\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalOverloaded_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicBoolean\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicBoolean_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicBooleanAndDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicBooleanAndDefault_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicByte\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicByte_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicOctet\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicOctet_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicShort\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicShort_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicUnsignedShort\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicUnsignedShort_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicLong_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicUnsignedLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicUnsignedLong_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicLongLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicLongLong_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicUnsignedLongLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicUnsignedLongLong_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicUnrestrictedFloat\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicUnrestrictedFloat_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicFloat\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicFloat_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicUnrestrictedDouble\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicUnrestrictedDouble_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicDouble\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicDouble_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicString\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicString_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicUsvstring\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicUsvstring_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicByteString\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicByteString_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicEnum\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicEnum_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicInterface\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicInterface_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicUnion\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicUnion_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicUnion2\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicUnion2_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicUnion3\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicUnion3_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicUnion4\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicUnion4_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicUnion5\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicUnion5_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicUnion6\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicUnion6_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicUnion7\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicUnion7_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicAny\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicAny_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicObject\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicObject_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passSequenceSequence\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passSequenceSequence_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"returnSequenceSequence\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &returnSequenceSequence_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnionSequenceSequence\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnionSequenceSequence_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passMozMap\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passMozMap_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableMozMap\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableMozMap_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passMozMapOfNullableInts\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passMozMapOfNullableInts_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalMozMapOfNullableInts\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalMozMapOfNullableInts_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableMozMapOfNullableInts\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableMozMapOfNullableInts_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passCastableObjectMozMap\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passCastableObjectMozMap_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableCastableObjectMozMap\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableCastableObjectMozMap_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passCastableObjectNullableMozMap\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passCastableObjectNullableMozMap_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableCastableObjectNullableMozMap\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableCastableObjectNullableMozMap_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalMozMap\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalMozMap_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableMozMap\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableMozMap_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableMozMapWithDefaultValue\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableMozMapWithDefaultValue_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalObjectMozMap\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalObjectMozMap_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passStringMozMap\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passStringMozMap_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passByteStringMozMap\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passByteStringMozMap_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passMozMapOfMozMaps\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passMozMapOfMozMaps_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passMozMapUnion\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passMozMapUnion_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passMozMapUnion2\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passMozMapUnion2_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passMozMapUnion3\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passMozMapUnion3_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveMozMap\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveMozMap_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableMozMap\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableMozMap_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveMozMapOfNullableInts\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveMozMapOfNullableInts_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableMozMapOfNullableInts\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableMozMapOfNullableInts_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveMozMapOfMozMaps\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveMozMapOfMozMaps_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveAnyMozMap\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveAnyMozMap_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"BooleanMozPreference\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &BooleanMozPreference_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"StringMozPreference\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &StringMozPreference_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]
,
&[
    JSFunctionSpec {
        name: b"prefControlledMethodDisabled\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &prefControlledMethodDisabled_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]
,
&[
    JSFunctionSpec {
        name: b"advanceClock\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &advanceClock_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]
,
&[
    JSFunctionSpec {
        name: b"prefControlledMethodEnabled\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &prefControlledMethodEnabled_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]
,
&[
    JSFunctionSpec {
        name: b"funcControlledMethodDisabled\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &funcControlledMethodDisabled_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]
,
&[
    JSFunctionSpec {
        name: b"funcControlledMethodEnabled\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &funcControlledMethodEnabled_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]
,
&[
    JSFunctionSpec {
        name: b"returnResolvedPromise\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &returnResolvedPromise_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"returnRejectedPromise\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &returnRejectedPromise_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"acceptPromise\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &acceptPromise_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"promiseNativeHandler\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &promiseNativeHandler_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"promiseResolveNative\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &promiseResolveNative_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"promiseRejectNative\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &promiseRejectNative_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"promiseRejectWithTypeError\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &promiseRejectWithTypeError_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"resolvePromiseDelayed\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &resolvePromiseDelayed_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 3,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"panic\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &panic_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"entryGlobal\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &entryGlobal_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"incumbentGlobal\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &incumbentGlobal_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]
,
&[
    JSFunctionSpec {
        name: b"crashHard\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &crashHard_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]

]}
fn sMethods<TH: TypeHolderTrait>() -> &'static [Guard<&'static [JSFunctionSpec]>] { &[
    Guard::new(Condition::Satisfied, sMethods_specs::<TH>()[0]),
    Guard::new(Condition::Pref("dom.testbinding.prefcontrolled.enabled"), sMethods_specs::<TH>()[1]),
    Guard::new(Condition::Pref("layout.animations.test.enabled"), sMethods_specs::<TH>()[2]),
    Guard::new(Condition::Pref("dom.testbinding.prefcontrolled2.enabled"), sMethods_specs::<TH>()[3]),
    Guard::new(Condition::Func(TestBinding::<TH>::condition_satisfied), sMethods_specs::<TH>()[4]),
    Guard::new(Condition::Func(TestBinding::<TH>::condition_satisfied), sMethods_specs::<TH>()[5]),
    Guard::new(Condition::Satisfied, sMethods_specs::<TH>()[6]),
    Guard::new(Condition::Pref("dom.testable_crash.enabled"), sMethods_specs::<TH>()[7])
]}
fn sAttributes_specs<TH: TypeHolderTrait>() -> &'static [&'static[JSPropertySpec]] { &[
&[
    JSPropertySpec {
        name: b"booleanAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &booleanAttribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &booleanAttribute_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"byteAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &byteAttribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &byteAttribute_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"octetAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &octetAttribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &octetAttribute_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"shortAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &shortAttribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &shortAttribute_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"unsignedShortAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &unsignedShortAttribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &unsignedShortAttribute_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"longAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &longAttribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &longAttribute_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"unsignedLongAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &unsignedLongAttribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &unsignedLongAttribute_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"longLongAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &longLongAttribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &longLongAttribute_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"unsignedLongLongAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &unsignedLongLongAttribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &unsignedLongLongAttribute_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"unrestrictedFloatAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &unrestrictedFloatAttribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &unrestrictedFloatAttribute_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"floatAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &floatAttribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &floatAttribute_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"unrestrictedDoubleAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &unrestrictedDoubleAttribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &unrestrictedDoubleAttribute_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"doubleAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &doubleAttribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &doubleAttribute_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"stringAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &stringAttribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &stringAttribute_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"usvstringAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &usvstringAttribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &usvstringAttribute_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"byteStringAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &byteStringAttribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &byteStringAttribute_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"enumAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &enumAttribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &enumAttribute_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"interfaceAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &interfaceAttribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &interfaceAttribute_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"unionAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &unionAttribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &unionAttribute_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"union2Attribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &union2Attribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &union2Attribute_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"union3Attribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &union3Attribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &union3Attribute_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"union4Attribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &union4Attribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &union4Attribute_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"union5Attribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &union5Attribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &union5Attribute_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"union6Attribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &union6Attribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &union6Attribute_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"union7Attribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &union7Attribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &union7Attribute_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"union8Attribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &union8Attribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &union8Attribute_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"union9Attribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &union9Attribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &union9Attribute_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"arrayAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &arrayAttribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"anyAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &anyAttribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &anyAttribute_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"objectAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &objectAttribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &objectAttribute_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"booleanAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &booleanAttributeNullable_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &booleanAttributeNullable_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"byteAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &byteAttributeNullable_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &byteAttributeNullable_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"octetAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &octetAttributeNullable_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &octetAttributeNullable_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"shortAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &shortAttributeNullable_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &shortAttributeNullable_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"unsignedShortAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &unsignedShortAttributeNullable_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &unsignedShortAttributeNullable_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"longAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &longAttributeNullable_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &longAttributeNullable_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"unsignedLongAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &unsignedLongAttributeNullable_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &unsignedLongAttributeNullable_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"longLongAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &longLongAttributeNullable_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &longLongAttributeNullable_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"unsignedLongLongAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &unsignedLongLongAttributeNullable_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &unsignedLongLongAttributeNullable_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"unrestrictedFloatAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &unrestrictedFloatAttributeNullable_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &unrestrictedFloatAttributeNullable_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"floatAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &floatAttributeNullable_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &floatAttributeNullable_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"unrestrictedDoubleAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &unrestrictedDoubleAttributeNullable_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &unrestrictedDoubleAttributeNullable_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"doubleAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &doubleAttributeNullable_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &doubleAttributeNullable_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"stringAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &stringAttributeNullable_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &stringAttributeNullable_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"usvstringAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &usvstringAttributeNullable_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &usvstringAttributeNullable_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"byteStringAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &byteStringAttributeNullable_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &byteStringAttributeNullable_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"enumAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &enumAttributeNullable_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"interfaceAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &interfaceAttributeNullable_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &interfaceAttributeNullable_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"interfaceAttributeWeak\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &interfaceAttributeWeak_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &interfaceAttributeWeak_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"objectAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &objectAttributeNullable_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &objectAttributeNullable_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"unionAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &unionAttributeNullable_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &unionAttributeNullable_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"union2AttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &union2AttributeNullable_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &union2AttributeNullable_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"union3AttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &union3AttributeNullable_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &union3AttributeNullable_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"union4AttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &union4AttributeNullable_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &union4AttributeNullable_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"union5AttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &union5AttributeNullable_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &union5AttributeNullable_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"union6AttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &union6AttributeNullable_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &union6AttributeNullable_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"attrToBinaryRename\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &attrToBinaryRename_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &attrToBinaryRename_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"attr-to-binary-rename\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &attr_to_binary_rename_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &attr_to_binary_rename_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"attr-to-automatically-rename\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &attr_to_automatically_rename_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &attr_to_automatically_rename_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"forwardedAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &forwardedAttribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &forwardedAttribute_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]
,
&[
    JSPropertySpec {
        name: b"prefControlledAttributeDisabled\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &prefControlledAttributeDisabled_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]
,
&[
    JSPropertySpec {
        name: b"prefControlledAttributeEnabled\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &prefControlledAttributeEnabled_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]
,
&[
    JSPropertySpec {
        name: b"funcControlledAttributeDisabled\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &funcControlledAttributeDisabled_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]
,
&[
    JSPropertySpec {
        name: b"funcControlledAttributeEnabled\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &funcControlledAttributeEnabled_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]
,
&[
    JSPropertySpec {
        name: b"promiseAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &promiseAttribute_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]

]}
fn sAttributes<TH: TypeHolderTrait>() -> &'static [Guard<&'static [JSPropertySpec]>] { &[
    Guard::new(Condition::Satisfied, sAttributes_specs::<TH>()[0]),
    Guard::new(Condition::Pref("dom.testbinding.prefcontrolled.enabled"), sAttributes_specs::<TH>()[1]),
    Guard::new(Condition::Pref("dom.testbinding.prefcontrolled2.enabled"), sAttributes_specs::<TH>()[2]),
    Guard::new(Condition::Func(TestBinding::<TH>::condition_satisfied), sAttributes_specs::<TH>()[3]),
    Guard::new(Condition::Func(TestBinding::<TH>::condition_satisfied), sAttributes_specs::<TH>()[4]),
    Guard::new(Condition::Satisfied, sAttributes_specs::<TH>()[5])
]}
const sConstants_specs: &'static [&'static[ConstantSpec]] = &[
&[
    ConstantSpec { name: b"constantInt64\0", value: ConstantVal::DoubleVal(-1 as f64) },
    ConstantSpec { name: b"constantUint64\0", value: ConstantVal::DoubleVal(1 as f64) },
    ConstantSpec { name: b"constantFloat32\0", value: ConstantVal::DoubleVal(1.0 as f64) },
    ConstantSpec { name: b"constantFloat64\0", value: ConstantVal::DoubleVal(1.0 as f64) },
    ConstantSpec { name: b"constantUnrestrictedFloat32\0", value: ConstantVal::DoubleVal(1.0 as f64) },
    ConstantSpec { name: b"constantUnrestrictedFloat64\0", value: ConstantVal::DoubleVal(1.0 as f64) }]
,
&[
    ConstantSpec { name: b"prefControlledConstDisabled\0", value: ConstantVal::IntVal(0) }]
,
&[
    ConstantSpec { name: b"prefControlledConstEnabled\0", value: ConstantVal::IntVal(0) }]
,
&[
    ConstantSpec { name: b"funcControlledConstDisabled\0", value: ConstantVal::IntVal(0) }]
,
&[
    ConstantSpec { name: b"funcControlledConstEnabled\0", value: ConstantVal::IntVal(0) }]

];
fn sConstants<TH: TypeHolderTrait>() -> &'static [Guard<&'static [ConstantSpec]>] { &[
    Guard::new(Condition::Satisfied, sConstants_specs[0]),
    Guard::new(Condition::Pref("dom.testbinding.prefcontrolled.enabled"), sConstants_specs[1]),
    Guard::new(Condition::Pref("dom.testbinding.prefcontrolled2.enabled"), sConstants_specs[2]),
    Guard::new(Condition::Func(TestBinding::<TH>::condition_satisfied), sConstants_specs[3]),
    Guard::new(Condition::Func(TestBinding::<TH>::condition_satisfied), sConstants_specs[4])
]}

pub unsafe fn GetProtoObject<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject, mut rval: MutableHandleObject) {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    assert!(((*get_object_class(global.get())).flags & JSCLASS_DOM_GLOBAL) != 0);

    /* Check to see whether the interface objects are already installed */
    let proto_or_iface_array = get_proto_or_iface_array(global.get());
    rval.set((*proto_or_iface_array)[PrototypeList::ID::TestBinding as usize]);
    if !rval.get().is_null() {
        return;
    }

    CreateInterfaceObjects(cx, global, proto_or_iface_array);
    rval.set((*proto_or_iface_array)[PrototypeList::ID::TestBinding as usize]);
    assert!(!rval.get().is_null());

}

static PrototypeClass: JSClass = JSClass {
    name: b"TestBindingPrototype\0" as *const u8 as *const libc::c_char,
    flags:
        // JSCLASS_HAS_RESERVED_SLOTS(0)
        (0 & JSCLASS_RESERVED_SLOTS_MASK) << JSCLASS_RESERVED_SLOTS_SHIFT,
    cOps: 0 as *const _,
    reserved: [0 as *mut os::raw::c_void; 3]
};

unsafe extern fn _constructor<TH: TypeHolderTrait>
(cx: *mut JSContext, argc: u32, vp: *mut JSVal) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let global = GlobalScope::from_object(JS_CALLEE(cx, vp).to_object());
        let args = CallArgs::from_vp(vp, argc);

        let argcount = cmp::min(argc, 1);
        match argcount {
            0 => {
                let result: Result<DomRoot<TestBinding<TH>>, Error<TH>> = TestBinding::Constructor(&global);
                let result = match result {
                    Ok(result) => result,
                    Err(e) => {
                        throw_dom_exception(cx, global.upcast::<GlobalScope<TH>>(), e);
                        return false;
                    },
                };

                (result).to_jsval(cx, args.rval());
                return true;
            }
            1 => {
                if args.get(0).get().is_object() && is_array_like(cx, args.get(0)) {
                    let arg0: Vec<f64> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                        Ok(ConversionResult::Success(value)) => value,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     },
                    };
                    let result: Result<DomRoot<TestBinding<TH>>, Error<TH>> = TestBinding::Constructor_(&global, arg0);
                    let result = match result {
                        Ok(result) => result,
                        Err(e) => {
                            throw_dom_exception(cx, global.upcast::<GlobalScope<TH>>(), e);
                            return false;
                        },
                    };

                    (result).to_jsval(cx, args.rval());
                    return true;
                }
                let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let result: Result<DomRoot<TestBinding<TH>>, Error<TH>> = TestBinding::Constructor__(&global, arg0);
                let result = match result {
                    Ok(result) => result,
                    Err(e) => {
                        throw_dom_exception(cx, global.upcast::<GlobalScope<TH>>(), e);
                        return false;
                    },
                };

                (result).to_jsval(cx, args.rval());
                return true;
            }
            _ => {
                throw_type_error(cx, "Not enough arguments to \"TestBinding.constructor\".");
                return false;
            }
        }
    }), false);
}

fn INTERFACE_OBJECT_CLASS<TH: TypeHolderTrait>() -> NonCallbackInterfaceObjectClass {
 
    NonCallbackInterfaceObjectClass::new(
        &InterfaceConstructorBehavior::call(_constructor::<TH>),
        b"function TestBinding() {\n    [native code]\n}",
        PrototypeList::ID::TestBinding,
        0) 
}

pub unsafe fn GetConstructorObject<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject, mut rval: MutableHandleObject) {
    /* Get the interface object for this class.  This will create the object as
       needed. */
    assert!(((*get_object_class(global.get())).flags & JSCLASS_DOM_GLOBAL) != 0);

    /* Check to see whether the interface objects are already installed */
    let proto_or_iface_array = get_proto_or_iface_array(global.get());
    rval.set((*proto_or_iface_array)[PrototypeList::Constructor::TestBinding as usize]);
    if !rval.get().is_null() {
        return;
    }

    CreateInterfaceObjects(cx, global, proto_or_iface_array);
    rval.set((*proto_or_iface_array)[PrototypeList::Constructor::TestBinding as usize]);
    assert!(!rval.get().is_null());

}

pub unsafe fn DefineDOMInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject) {
    assert!(!global.get().is_null());

    if !ConstructorEnabled(cx, global) {
        return;
    }

    rooted!(in(cx) let mut proto = ptr::null_mut::<JSObject>());
    GetProtoObject(cx, global, proto.handle_mut());
    assert!(!proto.is_null());
}

unsafe fn ConstructorEnabled<TH: TypeHolderTrait>
(aCx: *mut JSContext, aObj: HandleObject) -> bool {
    is_exposed_in(aObj, InterfaceObjectMap::Globals::DEDICATED_WORKER_GLOBAL_SCOPE | InterfaceObjectMap::Globals::SERVICE_WORKER_GLOBAL_SCOPE | InterfaceObjectMap::Globals::WINDOW) &&
    PREFS.get("dom.testbinding.enabled").as_boolean().unwrap_or(false)
}

unsafe fn CreateInterfaceObjects<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject, cache: *mut ProtoOrIfaceArray) {
    rooted!(in(cx) let mut prototype_proto = ptr::null_mut::<JSObject>());
    prototype_proto.set(JS_GetObjectPrototype(cx, global));
    assert!(!prototype_proto.is_null());

    rooted!(in(cx) let mut prototype = ptr::null_mut::<JSObject>());
    create_interface_prototype_object(cx,
                                      prototype_proto.handle().into(),
                                      &PrototypeClass,
                                      sMethods::<TH>(),
                                      sAttributes::<TH>(),
                                      sConstants::<TH>(),
                                      &[],
                                      prototype.handle_mut().into());
    assert!(!prototype.is_null());
    assert!((*cache)[PrototypeList::ID::TestBinding as usize].is_null());
    (*cache)[PrototypeList::ID::TestBinding as usize] = prototype.get();
    <*mut JSObject>::post_barrier((*cache).as_mut_ptr().offset(PrototypeList::ID::TestBinding as isize),
                                  ptr::null_mut(),
                                  prototype.get());


    rooted!(in(cx) let interface_proto = JS_GetFunctionPrototype(cx, global));
    assert!(!interface_proto.is_null());

    rooted!(in(cx) let mut interface = ptr::null_mut::<JSObject>());
    create_noncallback_interface_object(cx,
                                        global.into(),
                                        interface_proto.handle(),
                                        &INTERFACE_OBJECT_CLASS::<TH>(),
                                        sStaticMethods::<TH>(),
                                        sStaticAttributes::<TH>(),
                                        sConstants::<TH>(),
                                        prototype.handle(),
                                        b"TestBinding\0",
                                        0,
                                        interface.handle_mut());
    assert!(!interface.is_null());
    assert!((*cache)[PrototypeList::Constructor::TestBinding as usize].is_null());
    (*cache)[PrototypeList::Constructor::TestBinding as usize] = interface.get();
    <*mut JSObject>::post_barrier((*cache).as_mut_ptr().offset(PrototypeList::Constructor::TestBinding as isize),
                                  ptr::null_mut(),
                                  interface.get());

}
} // mod TestBindingBinding


