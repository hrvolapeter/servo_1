/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */

#![allow(non_camel_case_types,non_upper_case_globals,unused_imports,unused_variables,unused_assignments,unused_mut)]
use dom;
use dom::bindings;
use dom::bindings::callback::CallSetup;
use dom::bindings::callback::CallbackContainer;
use dom::bindings::callback::CallbackFunction;
use dom::bindings::callback::CallbackInterface;
use dom::bindings::callback::CallbackObject;
use dom::bindings::callback::ExceptionHandling;
use dom::bindings::callback::wrap_call_this_object;
use dom::bindings::codegen::Bindings::NodeBinding::NodeBinding;
use dom::bindings::codegen::InterfaceObjectMap;
use dom::bindings::codegen::PrototypeList;
use dom::bindings::codegen::RegisterBindings;
use dom::bindings::codegen::UnionTypes;
use dom::bindings::constant::ConstantSpec;
use dom::bindings::constant::ConstantVal;
use dom::bindings::conversions::ConversionBehavior;
use dom::bindings::conversions::ConversionResult;
use dom::bindings::conversions::DOM_OBJECT_SLOT;
use dom::bindings::conversions::FromJSValConvertible;
use dom::bindings::conversions::IDLInterface;
use dom::bindings::conversions::StringificationBehavior;
use dom::bindings::conversions::ToJSValConvertible;
use dom::bindings::conversions::is_array_like;
use dom::bindings::conversions::jsid_to_string;
use dom::bindings::conversions::native_from_handlevalue;
use dom::bindings::conversions::native_from_object;
use dom::bindings::conversions::private_from_object;
use dom::bindings::conversions::root_from_handleobject;
use dom::bindings::conversions::root_from_handlevalue;
use dom::bindings::conversions::root_from_object;
use dom::bindings::error::Error;
use dom::bindings::error::Error::JSFailed;
use dom::bindings::error::ErrorResult;
use dom::bindings::error::Fallible;
use dom::bindings::error::throw_dom_exception;
use dom::bindings::guard::Condition;
use dom::bindings::guard::Guard;
use dom::bindings::htmlconstructor::html_constructor;
use dom::bindings::htmlconstructor::pop_current_element_queue;
use dom::bindings::htmlconstructor::push_new_element_queue;
use dom::bindings::inheritance::Castable;
use dom::bindings::interface::ConstructorClassHook;
use dom::bindings::interface::InterfaceConstructorBehavior;
use dom::bindings::interface::NonCallbackInterfaceObjectClass;
use dom::bindings::interface::create_callback_interface_object;
use dom::bindings::interface::create_global_object;
use dom::bindings::interface::create_interface_prototype_object;
use dom::bindings::interface::create_named_constructors;
use dom::bindings::interface::create_noncallback_interface_object;
use dom::bindings::interface::define_guarded_constants;
use dom::bindings::interface::define_guarded_methods;
use dom::bindings::interface::define_guarded_properties;
use dom::bindings::interface::is_exposed_in;
use dom::bindings::iterable::Iterable;
use dom::bindings::iterable::IteratorType;
use dom::bindings::mozmap::MozMap;
use dom::bindings::namespace::NamespaceObjectClass;
use dom::bindings::namespace::create_namespace_object;
use dom::bindings::num::Finite;
use dom::bindings::proxyhandler;
use dom::bindings::proxyhandler::ensure_expando_object;
use dom::bindings::proxyhandler::fill_property_descriptor;
use dom::bindings::proxyhandler::get_expando_object;
use dom::bindings::proxyhandler::get_property_descriptor;
use dom::bindings::reflector::DomObject;
use dom::bindings::reflector::MutDomObject;
use dom::bindings::root::Dom;
use dom::bindings::root::DomRoot;
use dom::bindings::root::OptionalHeapSetter;
use dom::bindings::root::RootedReference;
use dom::bindings::str::ByteString;
use dom::bindings::str::DOMString;
use dom::bindings::str::USVString;
use dom::bindings::trace::JSTraceable;
use dom::bindings::trace::RootedTraceable;
use dom::bindings::trace::RootedTraceableBox;
use dom::bindings::utils::AsVoidPtr;
use dom::bindings::utils::DOMClass;
use dom::bindings::utils::DOMJSClass;
use dom::bindings::utils::DOM_PROTO_UNFORGEABLE_HOLDER_SLOT;
use dom::bindings::utils::JSCLASS_DOM_GLOBAL;
use dom::bindings::utils::ProtoOrIfaceArray;
use dom::bindings::utils::enumerate_global;
use dom::bindings::utils::finalize_global;
use dom::bindings::utils::find_enum_value;
use dom::bindings::utils::generic_getter;
use dom::bindings::utils::generic_lenient_getter;
use dom::bindings::utils::generic_lenient_setter;
use dom::bindings::utils::generic_method;
use dom::bindings::utils::generic_setter;
use dom::bindings::utils::get_array_index_from_id;
use dom::bindings::utils::get_dictionary_property;
use dom::bindings::utils::get_property_on_prototype;
use dom::bindings::utils::get_proto_or_iface_array;
use dom::bindings::utils::has_property_on_prototype;
use dom::bindings::utils::is_platform_object;
use dom::bindings::utils::resolve_global;
use dom::bindings::utils::set_dictionary_property;
use dom::bindings::utils::trace_global;
use dom::bindings::weakref::DOM_WEAK_SLOT;
use dom::bindings::weakref::WeakBox;
use dom::bindings::weakref::WeakReferenceable;
use dom::globalscope::GlobalScope;
use dom::types::Blob;
use dom::types::Element;
use dom::types::Node;
use dom::types::URL;
use dom::windowproxy::WindowProxy;
use js;
use js::JSCLASS_GLOBAL_SLOT_COUNT;
use js::JSCLASS_IS_DOMJSCLASS;
use js::JSCLASS_IS_GLOBAL;
use js::JSCLASS_RESERVED_SLOTS_MASK;
use js::JS_CALLEE;
use js::error::throw_internal_error;
use js::error::throw_type_error;
use js::glue::AppendToAutoIdVector;
use js::glue::CallJitGetterOp;
use js::glue::CallJitMethodOp;
use js::glue::CallJitSetterOp;
use js::glue::CreateProxyHandler;
use js::glue::GetProxyPrivate;
use js::glue::ProxyTraps;
use js::glue::RUST_JSID_IS_INT;
use js::glue::RUST_JSID_IS_STRING;
use js::glue::RUST_SYMBOL_TO_JSID;
use js::glue::UnwrapObject;
use js::glue::int_to_jsid;
use js::jsapi::AutoIdVector;
use js::jsapi::CallArgs;
use js::jsapi::CurrentGlobalOrNull;
use js::jsapi::FreeOp;
use js::jsapi::GetWellKnownSymbol;
use js::jsapi::Handle as RawHandle;
use js::jsapi::HandleId as RawHandleId;
use js::jsapi::HandleObject as RawHandleObject;
use js::jsapi::HandleValue as RawHandleValue;
use js::jsapi::HandleValueArray;
use js::jsapi::Heap;
use js::jsapi::INTERNED_STRING_TO_JSID;
use js::jsapi::IsCallable;
use js::jsapi::JSAutoCompartment;
use js::jsapi::JSCLASS_RESERVED_SLOTS_SHIFT;
use js::jsapi::JSClass;
use js::jsapi::JSContext;
use js::jsapi::JSFreeOp;
use js::jsapi::JSFunctionSpec;
use js::jsapi::JSITER_HIDDEN;
use js::jsapi::JSITER_OWNONLY;
use js::jsapi::JSITER_SYMBOLS;
use js::jsapi::JSJitGetterCallArgs;
use js::jsapi::JSJitInfo;
use js::jsapi::JSJitInfo_AliasSet;
use js::jsapi::JSJitInfo_ArgType;
use js::jsapi::JSJitInfo_OpType;
use js::jsapi::JSJitMethodCallArgs;
use js::jsapi::JSJitSetterCallArgs;
use js::jsapi::JSNative;
use js::jsapi::JSNativeWrapper;
use js::jsapi::JSObject;
use js::jsapi::JSPROP_ENUMERATE;
use js::jsapi::JSPROP_PERMANENT;
use js::jsapi::JSPROP_READONLY;
use js::jsapi::JSPROP_SHARED;
use js::jsapi::JSPropertySpec;
use js::jsapi::JSString;
use js::jsapi::JSTracer;
use js::jsapi::JSType;
use js::jsapi::JSTypedMethodJitInfo;
use js::jsapi::JSValueType;
use js::jsapi::JS_AtomizeAndPinString;
use js::jsapi::JS_ForwardGetPropertyTo;
use js::jsapi::JS_GetErrorPrototype;
use js::jsapi::JS_GetGlobalForObject;
use js::jsapi::JS_GetIteratorPrototype;
use js::jsapi::JS_GetPropertyById;
use js::jsapi::JS_GetPropertyDescriptorById;
use js::jsapi::JS_GetReservedSlot;
use js::jsapi::JS_HasProperty;
use js::jsapi::JS_HasPropertyById;
use js::jsapi::JS_NewObject;
use js::jsapi::JS_SetReservedSlot;
use js::jsapi::MutableHandle as RawMutableHandle;
use js::jsapi::MutableHandleObject as RawMutableHandleObject;
use js::jsapi::MutableHandleValue as RawMutableHandleValue;
use js::jsapi::ObjectOpResult;
use js::jsapi::PropertyDescriptor;
use js::jsapi::Rooted;
use js::jsapi::RootedId;
use js::jsapi::RootedObject;
use js::jsapi::RootedString;
use js::jsapi::SymbolCode;
use js::jsapi::jsid;
use js::jsval::JSVal;
use js::jsval::NullValue;
use js::jsval::ObjectOrNullValue;
use js::jsval::ObjectValue;
use js::jsval::PrivateValue;
use js::jsval::UndefinedValue;
use js::panic::maybe_resume_unwind;
use js::panic::wrap_panic;
use js::rust::CustomAutoRooterGuard;
use js::rust::GCMethods;
use js::rust::Handle;
use js::rust::HandleId;
use js::rust::HandleObject;
use js::rust::HandleValue;
use js::rust::MutableHandle;
use js::rust::MutableHandleObject;
use js::rust::MutableHandleValue;
use js::rust::define_methods;
use js::rust::define_properties;
use js::rust::get_object_class;
use js::rust::wrappers::Call;
use js::rust::wrappers::GetPropertyKeys;
use js::rust::wrappers::JS_CallFunctionValue;
use js::rust::wrappers::JS_CopyPropertiesFrom;
use js::rust::wrappers::JS_DefineProperty;
use js::rust::wrappers::JS_DefinePropertyById2;
use js::rust::wrappers::JS_GetFunctionPrototype;
use js::rust::wrappers::JS_GetObjectPrototype;
use js::rust::wrappers::JS_GetProperty;
use js::rust::wrappers::JS_InitializePropertiesFromCompatibleNativeObject;
use js::rust::wrappers::JS_NewObjectWithGivenProto;
use js::rust::wrappers::JS_NewObjectWithoutMetadata;
use js::rust::wrappers::JS_ObjectIsDate;
use js::rust::wrappers::JS_SetImmutablePrototype;
use js::rust::wrappers::JS_SetProperty;
use js::rust::wrappers::JS_SetPrototype;
use js::rust::wrappers::JS_SplicePrototype;
use js::rust::wrappers::JS_WrapObject;
use js::rust::wrappers::JS_WrapValue;
use js::rust::wrappers::NewProxyObject;
use js::typedarray;
use libc;
use malloc_size_of::MallocSizeOfOps;
use mem::malloc_size_of_including_raw_self;
use servo_config::prefs::PREFS;
use std::borrow::ToOwned;
use std::cmp;
use std::default::Default;
use std::ffi::CString;
use std::mem;
use std::num;
use std::os;
use std::os::raw::c_void;
use std::panic;
use std::ptr;
use std::ptr::NonNull;
use std::rc;
use std::rc::Rc;
use std::str;
use typeholder::TypeHolderTrait;

#[repr(usize)]
#[derive(Copy, Clone, Debug, JSTraceable, MallocSizeOf, PartialEq)]
pub enum TestEnum {
    _empty,
    Foo,
    Bar
}
pub mod TestEnumValues {
    use dom::bindings::conversions::ToJSValConvertible;
    use js::jsapi::JSContext;
    use js::rust::MutableHandleValue;
    use js::jsval::JSVal;

    pub const pairs: &'static [(&'static str, super::TestEnum)] = &[
        ("", super::TestEnum::_empty),
        ("foo", super::TestEnum::Foo),
        ("bar", super::TestEnum::Bar),
    ];

    impl super::TestEnum {
        pub fn as_str(&self) -> &'static str {
            pairs[*self as usize].0
        }
    }

    impl Default for super::TestEnum {
        fn default() -> super::TestEnum {
            pairs[0].1
        }
    }

    impl ToJSValConvertible for super::TestEnum {
        unsafe fn to_jsval(&self, cx: *mut JSContext, rval: MutableHandleValue) {
            pairs[*self as usize].0.to_jsval(cx, rval);
        }
    }
        } // mod TestEnumValues

pub use self::UnionTypes::StringOrURLOrBlob as TestTypedef;

pub type TestTypedefNullableUnion<TH> = Option<UnionTypes::StringOrURLOrBlob<TH>>;

pub type TestTypedefString = DOMString;

pub type TestTypedefInterface<TH> = DomRoot<Blob<TH>>;

#[derive(JSTraceable, Default)]
#[must_root]
pub struct TestDictionary<TH: TypeHolderTrait> {
    pub anyValue: RootedTraceableBox<Heap<JSVal>>,
    pub booleanValue: Option<bool>,
    pub byteValue: Option<i8>,
    pub dict: RootedTraceableBox<dom::bindings::codegen::Bindings::TestBindingBinding::TestDictionaryDefaults>,
    pub doubleValue: Option<Finite<f64>>,
    pub elementSequence: Option<Vec<DomRoot<Element<TH>>>>,
    pub enumValue: Option<TestEnum>,
    pub floatValue: Option<Finite<f32>>,
    pub interfaceValue: Option<DomRoot<Blob<TH>>>,
    pub longLongValue: Option<i64>,
    pub longValue: Option<i32>,
    pub nonRequiredNullable: Option<Option<DOMString>>,
    pub nonRequiredNullable2: Option<Option<DOMString>>,
    pub objectValue: Option<RootedTraceableBox<Heap<*mut JSObject>>>,
    pub octetValue: Option<u8>,
    pub requiredValue: bool,
    pub seqDict: Option<Vec<RootedTraceableBox<dom::bindings::codegen::Bindings::TestBindingBinding::TestDictionaryDefaults>>>,
    pub shortValue: Option<i16>,
    pub stringValue: Option<DOMString>,
    pub type_: Option<DOMString>,
    pub unrestrictedDoubleValue: Option<f64>,
    pub unrestrictedFloatValue: Option<f32>,
    pub unsignedLongLongValue: Option<u64>,
    pub unsignedLongValue: Option<u32>,
    pub unsignedShortValue: Option<u16>,
    pub usvstringValue: Option<USVString>,
}
impl<TH: TypeHolderTrait> TestDictionary<TH> {
    pub unsafe fn empty(cx: *mut JSContext) -> RootedTraceableBox<TestDictionary<TH>> {
        match TestDictionary::new(cx, HandleValue::null()) {
            Ok(ConversionResult::Success(v)) => v,
            _ => unreachable!(),
        }
    }
    pub unsafe fn new(cx: *mut JSContext, val: HandleValue)
                      -> Result<ConversionResult<RootedTraceableBox<TestDictionary<TH>>>, ()> {
        let object = if val.get().is_null_or_undefined() {
            ptr::null_mut()
        } else if val.get().is_object() {
            val.get().to_object()
        } else {
            return Ok(ConversionResult::Failure("Value is not an object.".into()));
        };
        rooted!(in(cx) let object = object);
            let mut dictionary = RootedTraceableBox::new(TestDictionary::default());
            dictionary.anyValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "anyValue", rval.handle_mut())) {
                    true => {
                        RootedTraceableBox::from_box(Heap::boxed(rval.handle().get()))
                    },
                    false => {
                        RootedTraceableBox::from_box(Heap::boxed(UndefinedValue()))
                    },
                }
            };
            dictionary.booleanValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "booleanValue", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.byteValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "byteValue", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.dict = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "dict", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(dictionary)) => dictionary,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); },
                        }
                    },
                    false => {
                        dom::bindings::codegen::Bindings::TestBindingBinding::TestDictionaryDefaults::empty(cx)
                    },
                }
            };
            dictionary.doubleValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "doubleValue", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.elementSequence = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "elementSequence", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(value)) => value,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); },
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.enumValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "enumValue", rval.handle_mut())) {
                    true => {
                        Some(match find_enum_value(cx, rval.handle(), TestEnumValues::pairs) {
                            Err(_) => { return Err(()); },
                            Ok((None, search)) => { throw_type_error(cx, &format!("'{}' is not a valid enum value for enumeration 'TestEnum'.", search)); return Err(()); },
                            Ok((Some(&value), _)) => value,
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.floatValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "floatValue", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.interfaceValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "interfaceValue", rval.handle_mut())) {
                    true => {
                        Some(if rval.handle().get().is_object() {
                            match root_from_handlevalue(rval.handle()) {
                                Ok(val) => val,
                                Err(()) => {
                                    throw_type_error(cx, "value does not implement interface Blob.");
                                    return Err(());
                                }
                            }

                        } else {
                            throw_type_error(cx, "Value is not an object.");
                            return Err(());
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.longLongValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "longLongValue", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.longValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "longValue", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.nonRequiredNullable = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nonRequiredNullable", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), StringificationBehavior::Default) {
                            Ok(ConversionResult::Success(strval)) => strval,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); },
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.nonRequiredNullable2 = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nonRequiredNullable2", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), StringificationBehavior::Default) {
                            Ok(ConversionResult::Success(strval)) => strval,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); },
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.objectValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "objectValue", rval.handle_mut())) {
                    true => {
                        Some(if rval.handle().get().is_object() {
                            RootedTraceableBox::from_box(Heap::boxed(rval.handle().get().to_object()))
                        } else {
                            throw_type_error(cx, "Value is not an object.");
                            return Err(());
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.octetValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "octetValue", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.requiredValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "requiredValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        throw_type_error(cx, "Missing required member \"requiredValue\".");
                        return Err(());
                    },
                }
            };
            dictionary.seqDict = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "seqDict", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(value)) => value,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); },
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.shortValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "shortValue", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.stringValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "stringValue", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), StringificationBehavior::Default) {
                            Ok(ConversionResult::Success(strval)) => strval,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); },
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.type_ = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "type", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), StringificationBehavior::Default) {
                            Ok(ConversionResult::Success(strval)) => strval,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); },
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.unrestrictedDoubleValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "unrestrictedDoubleValue", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.unrestrictedFloatValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "unrestrictedFloatValue", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.unsignedLongLongValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "unsignedLongLongValue", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.unsignedLongValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "unsignedLongValue", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.unsignedShortValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "unsignedShortValue", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            };
            dictionary.usvstringValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "usvstringValue", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(strval)) => strval,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); },
                        })
                    },
                    false => {
                        None
                    },
                }
            };
        Ok(ConversionResult::Success(dictionary))
    }
}

impl<TH: TypeHolderTrait> FromJSValConvertible for RootedTraceableBox<TestDictionary<TH>> {
    type Config = ();
    unsafe fn from_jsval(cx: *mut JSContext, value: HandleValue, _option: ())
                         -> Result<ConversionResult<RootedTraceableBox<TestDictionary<TH>>>, ()> {
        TestDictionary::new(cx, value)
    }
}

impl<TH: TypeHolderTrait> ToJSValConvertible for RootedTraceableBox<TestDictionary<TH>> {
    unsafe fn to_jsval(&self, cx: *mut JSContext, mut rval: MutableHandleValue) {
        rooted!(in(cx) let obj = JS_NewObject(cx, ptr::null()));
        let anyValue = &self.anyValue;
        rooted!(in(cx) let mut anyValue_js = UndefinedValue());
        anyValue.to_jsval(cx, anyValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "anyValue", anyValue_js.handle()).unwrap();
        if let Some(ref booleanValue) = self.booleanValue {
            rooted!(in(cx) let mut booleanValue_js = UndefinedValue());
            booleanValue.to_jsval(cx, booleanValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "booleanValue", booleanValue_js.handle()).unwrap();
        }
        if let Some(ref byteValue) = self.byteValue {
            rooted!(in(cx) let mut byteValue_js = UndefinedValue());
            byteValue.to_jsval(cx, byteValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "byteValue", byteValue_js.handle()).unwrap();
        }
        let dict = &self.dict;
        rooted!(in(cx) let mut dict_js = UndefinedValue());
        dict.to_jsval(cx, dict_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "dict", dict_js.handle()).unwrap();
        if let Some(ref doubleValue) = self.doubleValue {
            rooted!(in(cx) let mut doubleValue_js = UndefinedValue());
            doubleValue.to_jsval(cx, doubleValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "doubleValue", doubleValue_js.handle()).unwrap();
        }
        if let Some(ref elementSequence) = self.elementSequence {
            rooted!(in(cx) let mut elementSequence_js = UndefinedValue());
            elementSequence.to_jsval(cx, elementSequence_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "elementSequence", elementSequence_js.handle()).unwrap();
        }
        if let Some(ref enumValue) = self.enumValue {
            rooted!(in(cx) let mut enumValue_js = UndefinedValue());
            enumValue.to_jsval(cx, enumValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "enumValue", enumValue_js.handle()).unwrap();
        }
        if let Some(ref floatValue) = self.floatValue {
            rooted!(in(cx) let mut floatValue_js = UndefinedValue());
            floatValue.to_jsval(cx, floatValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "floatValue", floatValue_js.handle()).unwrap();
        }
        if let Some(ref interfaceValue) = self.interfaceValue {
            rooted!(in(cx) let mut interfaceValue_js = UndefinedValue());
            interfaceValue.to_jsval(cx, interfaceValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "interfaceValue", interfaceValue_js.handle()).unwrap();
        }
        if let Some(ref longLongValue) = self.longLongValue {
            rooted!(in(cx) let mut longLongValue_js = UndefinedValue());
            longLongValue.to_jsval(cx, longLongValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "longLongValue", longLongValue_js.handle()).unwrap();
        }
        if let Some(ref longValue) = self.longValue {
            rooted!(in(cx) let mut longValue_js = UndefinedValue());
            longValue.to_jsval(cx, longValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "longValue", longValue_js.handle()).unwrap();
        }
        if let Some(ref nonRequiredNullable) = self.nonRequiredNullable {
            rooted!(in(cx) let mut nonRequiredNullable_js = UndefinedValue());
            nonRequiredNullable.to_jsval(cx, nonRequiredNullable_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "nonRequiredNullable", nonRequiredNullable_js.handle()).unwrap();
        }
        if let Some(ref nonRequiredNullable2) = self.nonRequiredNullable2 {
            rooted!(in(cx) let mut nonRequiredNullable2_js = UndefinedValue());
            nonRequiredNullable2.to_jsval(cx, nonRequiredNullable2_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "nonRequiredNullable2", nonRequiredNullable2_js.handle()).unwrap();
        }
        if let Some(ref objectValue) = self.objectValue {
            rooted!(in(cx) let mut objectValue_js = UndefinedValue());
            objectValue.to_jsval(cx, objectValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "objectValue", objectValue_js.handle()).unwrap();
        }
        if let Some(ref octetValue) = self.octetValue {
            rooted!(in(cx) let mut octetValue_js = UndefinedValue());
            octetValue.to_jsval(cx, octetValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "octetValue", octetValue_js.handle()).unwrap();
        }
        let requiredValue = &self.requiredValue;
        rooted!(in(cx) let mut requiredValue_js = UndefinedValue());
        requiredValue.to_jsval(cx, requiredValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "requiredValue", requiredValue_js.handle()).unwrap();
        if let Some(ref seqDict) = self.seqDict {
            rooted!(in(cx) let mut seqDict_js = UndefinedValue());
            seqDict.to_jsval(cx, seqDict_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "seqDict", seqDict_js.handle()).unwrap();
        }
        if let Some(ref shortValue) = self.shortValue {
            rooted!(in(cx) let mut shortValue_js = UndefinedValue());
            shortValue.to_jsval(cx, shortValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "shortValue", shortValue_js.handle()).unwrap();
        }
        if let Some(ref stringValue) = self.stringValue {
            rooted!(in(cx) let mut stringValue_js = UndefinedValue());
            stringValue.to_jsval(cx, stringValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "stringValue", stringValue_js.handle()).unwrap();
        }
        if let Some(ref type_) = self.type_ {
            rooted!(in(cx) let mut type__js = UndefinedValue());
            type_.to_jsval(cx, type__js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "type", type__js.handle()).unwrap();
        }
        if let Some(ref unrestrictedDoubleValue) = self.unrestrictedDoubleValue {
            rooted!(in(cx) let mut unrestrictedDoubleValue_js = UndefinedValue());
            unrestrictedDoubleValue.to_jsval(cx, unrestrictedDoubleValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "unrestrictedDoubleValue", unrestrictedDoubleValue_js.handle()).unwrap();
        }
        if let Some(ref unrestrictedFloatValue) = self.unrestrictedFloatValue {
            rooted!(in(cx) let mut unrestrictedFloatValue_js = UndefinedValue());
            unrestrictedFloatValue.to_jsval(cx, unrestrictedFloatValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "unrestrictedFloatValue", unrestrictedFloatValue_js.handle()).unwrap();
        }
        if let Some(ref unsignedLongLongValue) = self.unsignedLongLongValue {
            rooted!(in(cx) let mut unsignedLongLongValue_js = UndefinedValue());
            unsignedLongLongValue.to_jsval(cx, unsignedLongLongValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "unsignedLongLongValue", unsignedLongLongValue_js.handle()).unwrap();
        }
        if let Some(ref unsignedLongValue) = self.unsignedLongValue {
            rooted!(in(cx) let mut unsignedLongValue_js = UndefinedValue());
            unsignedLongValue.to_jsval(cx, unsignedLongValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "unsignedLongValue", unsignedLongValue_js.handle()).unwrap();
        }
        if let Some(ref unsignedShortValue) = self.unsignedShortValue {
            rooted!(in(cx) let mut unsignedShortValue_js = UndefinedValue());
            unsignedShortValue.to_jsval(cx, unsignedShortValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "unsignedShortValue", unsignedShortValue_js.handle()).unwrap();
        }
        if let Some(ref usvstringValue) = self.usvstringValue {
            rooted!(in(cx) let mut usvstringValue_js = UndefinedValue());
            usvstringValue.to_jsval(cx, usvstringValue_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "usvstringValue", usvstringValue_js.handle()).unwrap();
        }
        rval.set(ObjectOrNullValue(obj.get()))
    }
}


#[derive(JSTraceable, Default)]
#[must_root]
pub struct TestDictionaryDefaults {
    pub UnrestrictedDoubleValue: f64,
    pub anyValue: RootedTraceableBox<Heap<JSVal>>,
    pub booleanValue: bool,
    pub byteValue: i8,
    pub bytestringValue: ByteString,
    pub doubleValue: Finite<f64>,
    pub enumValue: TestEnum,
    pub floatValue: Finite<f32>,
    pub longLongValue: i64,
    pub longValue: i32,
    pub nullableBooleanValue: Option<bool>,
    pub nullableByteValue: Option<i8>,
    pub nullableBytestringValue: Option<ByteString>,
    pub nullableDoubleValue: Option<Finite<f64>>,
    pub nullableFloatValue: Option<Finite<f32>>,
    pub nullableLongLongValue: Option<i64>,
    pub nullableLongValue: Option<i32>,
    pub nullableObjectValue: RootedTraceableBox<Heap<*mut JSObject>>,
    pub nullableOctetValue: Option<u8>,
    pub nullableShortValue: Option<i16>,
    pub nullableStringValue: Option<DOMString>,
    pub nullableUnrestrictedDoubleValue: Option<f64>,
    pub nullableUnrestrictedFloatValue: Option<f32>,
    pub nullableUnsignedLongLongValue: Option<u64>,
    pub nullableUnsignedLongValue: Option<u32>,
    pub nullableUnsignedShortValue: Option<u16>,
    pub nullableUsvstringValue: Option<USVString>,
    pub octetValue: u8,
    pub shortValue: i16,
    pub stringValue: DOMString,
    pub unrestrictedFloatValue: f32,
    pub unsignedLongLongValue: u64,
    pub unsignedLongValue: u32,
    pub unsignedShortValue: u16,
    pub usvstringValue: USVString,
}
impl TestDictionaryDefaults {
    pub unsafe fn empty(cx: *mut JSContext) -> RootedTraceableBox<TestDictionaryDefaults> {
        match TestDictionaryDefaults::new(cx, HandleValue::null()) {
            Ok(ConversionResult::Success(v)) => v,
            _ => unreachable!(),
        }
    }
    pub unsafe fn new(cx: *mut JSContext, val: HandleValue)
                      -> Result<ConversionResult<RootedTraceableBox<TestDictionaryDefaults>>, ()> {
        let object = if val.get().is_null_or_undefined() {
            ptr::null_mut()
        } else if val.get().is_object() {
            val.get().to_object()
        } else {
            return Ok(ConversionResult::Failure("Value is not an object.".into()));
        };
        rooted!(in(cx) let object = object);
            let mut dictionary = RootedTraceableBox::new(TestDictionaryDefaults::default());
            dictionary.UnrestrictedDoubleValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "UnrestrictedDoubleValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        7.0
                    },
                }
            };
            dictionary.anyValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "anyValue", rval.handle_mut())) {
                    true => {
                        RootedTraceableBox::from_box(Heap::boxed(rval.handle().get()))
                    },
                    false => {
                        RootedTraceableBox::from_box(Heap::boxed(NullValue()))
                    },
                }
            };
            dictionary.booleanValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "booleanValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        false
                    },
                }
            };
            dictionary.byteValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "byteValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        7
                    },
                }
            };
            dictionary.bytestringValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "bytestringValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(strval)) => strval,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); },
                        }
                    },
                    false => {
                        ByteString::new(b"foo".to_vec())
                    },
                }
            };
            dictionary.doubleValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "doubleValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        Finite::wrap(7.0)
                    },
                }
            };
            dictionary.enumValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "enumValue", rval.handle_mut())) {
                    true => {
                        match find_enum_value(cx, rval.handle(), TestEnumValues::pairs) {
                            Err(_) => { return Err(()); },
                            Ok((None, search)) => { throw_type_error(cx, &format!("'{}' is not a valid enum value for enumeration 'TestEnum'.", search)); return Err(()); },
                            Ok((Some(&value), _)) => value,
                        }
                    },
                    false => {
                        TestEnum::Bar
                    },
                }
            };
            dictionary.floatValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "floatValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        Finite::wrap(7.0)
                    },
                }
            };
            dictionary.longLongValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "longLongValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        7
                    },
                }
            };
            dictionary.longValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "longValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        7
                    },
                }
            };
            dictionary.nullableBooleanValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableBooleanValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        Some(false)
                    },
                }
            };
            dictionary.nullableByteValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableByteValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        Some(7)
                    },
                }
            };
            dictionary.nullableBytestringValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableBytestringValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(strval)) => strval,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); },
                        }
                    },
                    false => {
                        Some(ByteString::new(b"foo".to_vec()))
                    },
                }
            };
            dictionary.nullableDoubleValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableDoubleValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        Some(Finite::wrap(7.0))
                    },
                }
            };
            dictionary.nullableFloatValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableFloatValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        Some(Finite::wrap(7.0))
                    },
                }
            };
            dictionary.nullableLongLongValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableLongLongValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        Some(7)
                    },
                }
            };
            dictionary.nullableLongValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableLongValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        Some(7)
                    },
                }
            };
            dictionary.nullableObjectValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableObjectValue", rval.handle_mut())) {
                    true => {
                        if rval.handle().get().is_object() {
                            RootedTraceableBox::from_box(Heap::boxed(rval.handle().get().to_object()))
                        } else if rval.handle().get().is_null_or_undefined() {
                            RootedTraceableBox::new(Heap::default())
                        } else {
                            throw_type_error(cx, "Value is not an object.");
                            return Err(());
                        }
                    },
                    false => {
                        RootedTraceableBox::new(Heap::default())
                    },
                }
            };
            dictionary.nullableOctetValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableOctetValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        Some(7)
                    },
                }
            };
            dictionary.nullableShortValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableShortValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        Some(7)
                    },
                }
            };
            dictionary.nullableStringValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableStringValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), StringificationBehavior::Default) {
                            Ok(ConversionResult::Success(strval)) => strval,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); },
                        }
                    },
                    false => {
                        Some(DOMString::from("foo"))
                    },
                }
            };
            dictionary.nullableUnrestrictedDoubleValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableUnrestrictedDoubleValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        Some(7.0)
                    },
                }
            };
            dictionary.nullableUnrestrictedFloatValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableUnrestrictedFloatValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        Some(7.0)
                    },
                }
            };
            dictionary.nullableUnsignedLongLongValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableUnsignedLongLongValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        Some(7)
                    },
                }
            };
            dictionary.nullableUnsignedLongValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableUnsignedLongValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        Some(7)
                    },
                }
            };
            dictionary.nullableUnsignedShortValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableUnsignedShortValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        Some(7)
                    },
                }
            };
            dictionary.nullableUsvstringValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "nullableUsvstringValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(strval)) => strval,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); },
                        }
                    },
                    false => {
                        Some(USVString("foo".to_owned()))
                    },
                }
            };
            dictionary.octetValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "octetValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        7
                    },
                }
            };
            dictionary.shortValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "shortValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        7
                    },
                }
            };
            dictionary.stringValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "stringValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), StringificationBehavior::Default) {
                            Ok(ConversionResult::Success(strval)) => strval,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); },
                        }
                    },
                    false => {
                        DOMString::from("foo")
                    },
                }
            };
            dictionary.unrestrictedFloatValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "unrestrictedFloatValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        7.0
                    },
                }
            };
            dictionary.unsignedLongLongValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "unsignedLongLongValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        7
                    },
                }
            };
            dictionary.unsignedLongValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "unsignedLongValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        7
                    },
                }
            };
            dictionary.unsignedShortValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "unsignedShortValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        }
                    },
                    false => {
                        7
                    },
                }
            };
            dictionary.usvstringValue = {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "usvstringValue", rval.handle_mut())) {
                    true => {
                        match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(strval)) => strval,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); },
                        }
                    },
                    false => {
                        USVString("foo".to_owned())
                    },
                }
            };
        Ok(ConversionResult::Success(dictionary))
    }
}

impl FromJSValConvertible for RootedTraceableBox<TestDictionaryDefaults> {
    type Config = ();
    unsafe fn from_jsval(cx: *mut JSContext, value: HandleValue, _option: ())
                         -> Result<ConversionResult<RootedTraceableBox<TestDictionaryDefaults>>, ()> {
        TestDictionaryDefaults::new(cx, value)
    }
}

impl ToJSValConvertible for RootedTraceableBox<TestDictionaryDefaults> {
    unsafe fn to_jsval(&self, cx: *mut JSContext, mut rval: MutableHandleValue) {
        rooted!(in(cx) let obj = JS_NewObject(cx, ptr::null()));
        let UnrestrictedDoubleValue = &self.UnrestrictedDoubleValue;
        rooted!(in(cx) let mut UnrestrictedDoubleValue_js = UndefinedValue());
        UnrestrictedDoubleValue.to_jsval(cx, UnrestrictedDoubleValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "UnrestrictedDoubleValue", UnrestrictedDoubleValue_js.handle()).unwrap();
        let anyValue = &self.anyValue;
        rooted!(in(cx) let mut anyValue_js = UndefinedValue());
        anyValue.to_jsval(cx, anyValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "anyValue", anyValue_js.handle()).unwrap();
        let booleanValue = &self.booleanValue;
        rooted!(in(cx) let mut booleanValue_js = UndefinedValue());
        booleanValue.to_jsval(cx, booleanValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "booleanValue", booleanValue_js.handle()).unwrap();
        let byteValue = &self.byteValue;
        rooted!(in(cx) let mut byteValue_js = UndefinedValue());
        byteValue.to_jsval(cx, byteValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "byteValue", byteValue_js.handle()).unwrap();
        let bytestringValue = &self.bytestringValue;
        rooted!(in(cx) let mut bytestringValue_js = UndefinedValue());
        bytestringValue.to_jsval(cx, bytestringValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "bytestringValue", bytestringValue_js.handle()).unwrap();
        let doubleValue = &self.doubleValue;
        rooted!(in(cx) let mut doubleValue_js = UndefinedValue());
        doubleValue.to_jsval(cx, doubleValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "doubleValue", doubleValue_js.handle()).unwrap();
        let enumValue = &self.enumValue;
        rooted!(in(cx) let mut enumValue_js = UndefinedValue());
        enumValue.to_jsval(cx, enumValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "enumValue", enumValue_js.handle()).unwrap();
        let floatValue = &self.floatValue;
        rooted!(in(cx) let mut floatValue_js = UndefinedValue());
        floatValue.to_jsval(cx, floatValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "floatValue", floatValue_js.handle()).unwrap();
        let longLongValue = &self.longLongValue;
        rooted!(in(cx) let mut longLongValue_js = UndefinedValue());
        longLongValue.to_jsval(cx, longLongValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "longLongValue", longLongValue_js.handle()).unwrap();
        let longValue = &self.longValue;
        rooted!(in(cx) let mut longValue_js = UndefinedValue());
        longValue.to_jsval(cx, longValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "longValue", longValue_js.handle()).unwrap();
        let nullableBooleanValue = &self.nullableBooleanValue;
        rooted!(in(cx) let mut nullableBooleanValue_js = UndefinedValue());
        nullableBooleanValue.to_jsval(cx, nullableBooleanValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableBooleanValue", nullableBooleanValue_js.handle()).unwrap();
        let nullableByteValue = &self.nullableByteValue;
        rooted!(in(cx) let mut nullableByteValue_js = UndefinedValue());
        nullableByteValue.to_jsval(cx, nullableByteValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableByteValue", nullableByteValue_js.handle()).unwrap();
        let nullableBytestringValue = &self.nullableBytestringValue;
        rooted!(in(cx) let mut nullableBytestringValue_js = UndefinedValue());
        nullableBytestringValue.to_jsval(cx, nullableBytestringValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableBytestringValue", nullableBytestringValue_js.handle()).unwrap();
        let nullableDoubleValue = &self.nullableDoubleValue;
        rooted!(in(cx) let mut nullableDoubleValue_js = UndefinedValue());
        nullableDoubleValue.to_jsval(cx, nullableDoubleValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableDoubleValue", nullableDoubleValue_js.handle()).unwrap();
        let nullableFloatValue = &self.nullableFloatValue;
        rooted!(in(cx) let mut nullableFloatValue_js = UndefinedValue());
        nullableFloatValue.to_jsval(cx, nullableFloatValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableFloatValue", nullableFloatValue_js.handle()).unwrap();
        let nullableLongLongValue = &self.nullableLongLongValue;
        rooted!(in(cx) let mut nullableLongLongValue_js = UndefinedValue());
        nullableLongLongValue.to_jsval(cx, nullableLongLongValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableLongLongValue", nullableLongLongValue_js.handle()).unwrap();
        let nullableLongValue = &self.nullableLongValue;
        rooted!(in(cx) let mut nullableLongValue_js = UndefinedValue());
        nullableLongValue.to_jsval(cx, nullableLongValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableLongValue", nullableLongValue_js.handle()).unwrap();
        let nullableObjectValue = &self.nullableObjectValue;
        rooted!(in(cx) let mut nullableObjectValue_js = UndefinedValue());
        nullableObjectValue.to_jsval(cx, nullableObjectValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableObjectValue", nullableObjectValue_js.handle()).unwrap();
        let nullableOctetValue = &self.nullableOctetValue;
        rooted!(in(cx) let mut nullableOctetValue_js = UndefinedValue());
        nullableOctetValue.to_jsval(cx, nullableOctetValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableOctetValue", nullableOctetValue_js.handle()).unwrap();
        let nullableShortValue = &self.nullableShortValue;
        rooted!(in(cx) let mut nullableShortValue_js = UndefinedValue());
        nullableShortValue.to_jsval(cx, nullableShortValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableShortValue", nullableShortValue_js.handle()).unwrap();
        let nullableStringValue = &self.nullableStringValue;
        rooted!(in(cx) let mut nullableStringValue_js = UndefinedValue());
        nullableStringValue.to_jsval(cx, nullableStringValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableStringValue", nullableStringValue_js.handle()).unwrap();
        let nullableUnrestrictedDoubleValue = &self.nullableUnrestrictedDoubleValue;
        rooted!(in(cx) let mut nullableUnrestrictedDoubleValue_js = UndefinedValue());
        nullableUnrestrictedDoubleValue.to_jsval(cx, nullableUnrestrictedDoubleValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableUnrestrictedDoubleValue", nullableUnrestrictedDoubleValue_js.handle()).unwrap();
        let nullableUnrestrictedFloatValue = &self.nullableUnrestrictedFloatValue;
        rooted!(in(cx) let mut nullableUnrestrictedFloatValue_js = UndefinedValue());
        nullableUnrestrictedFloatValue.to_jsval(cx, nullableUnrestrictedFloatValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableUnrestrictedFloatValue", nullableUnrestrictedFloatValue_js.handle()).unwrap();
        let nullableUnsignedLongLongValue = &self.nullableUnsignedLongLongValue;
        rooted!(in(cx) let mut nullableUnsignedLongLongValue_js = UndefinedValue());
        nullableUnsignedLongLongValue.to_jsval(cx, nullableUnsignedLongLongValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableUnsignedLongLongValue", nullableUnsignedLongLongValue_js.handle()).unwrap();
        let nullableUnsignedLongValue = &self.nullableUnsignedLongValue;
        rooted!(in(cx) let mut nullableUnsignedLongValue_js = UndefinedValue());
        nullableUnsignedLongValue.to_jsval(cx, nullableUnsignedLongValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableUnsignedLongValue", nullableUnsignedLongValue_js.handle()).unwrap();
        let nullableUnsignedShortValue = &self.nullableUnsignedShortValue;
        rooted!(in(cx) let mut nullableUnsignedShortValue_js = UndefinedValue());
        nullableUnsignedShortValue.to_jsval(cx, nullableUnsignedShortValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableUnsignedShortValue", nullableUnsignedShortValue_js.handle()).unwrap();
        let nullableUsvstringValue = &self.nullableUsvstringValue;
        rooted!(in(cx) let mut nullableUsvstringValue_js = UndefinedValue());
        nullableUsvstringValue.to_jsval(cx, nullableUsvstringValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "nullableUsvstringValue", nullableUsvstringValue_js.handle()).unwrap();
        let octetValue = &self.octetValue;
        rooted!(in(cx) let mut octetValue_js = UndefinedValue());
        octetValue.to_jsval(cx, octetValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "octetValue", octetValue_js.handle()).unwrap();
        let shortValue = &self.shortValue;
        rooted!(in(cx) let mut shortValue_js = UndefinedValue());
        shortValue.to_jsval(cx, shortValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "shortValue", shortValue_js.handle()).unwrap();
        let stringValue = &self.stringValue;
        rooted!(in(cx) let mut stringValue_js = UndefinedValue());
        stringValue.to_jsval(cx, stringValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "stringValue", stringValue_js.handle()).unwrap();
        let unrestrictedFloatValue = &self.unrestrictedFloatValue;
        rooted!(in(cx) let mut unrestrictedFloatValue_js = UndefinedValue());
        unrestrictedFloatValue.to_jsval(cx, unrestrictedFloatValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "unrestrictedFloatValue", unrestrictedFloatValue_js.handle()).unwrap();
        let unsignedLongLongValue = &self.unsignedLongLongValue;
        rooted!(in(cx) let mut unsignedLongLongValue_js = UndefinedValue());
        unsignedLongLongValue.to_jsval(cx, unsignedLongLongValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "unsignedLongLongValue", unsignedLongLongValue_js.handle()).unwrap();
        let unsignedLongValue = &self.unsignedLongValue;
        rooted!(in(cx) let mut unsignedLongValue_js = UndefinedValue());
        unsignedLongValue.to_jsval(cx, unsignedLongValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "unsignedLongValue", unsignedLongValue_js.handle()).unwrap();
        let unsignedShortValue = &self.unsignedShortValue;
        rooted!(in(cx) let mut unsignedShortValue_js = UndefinedValue());
        unsignedShortValue.to_jsval(cx, unsignedShortValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "unsignedShortValue", unsignedShortValue_js.handle()).unwrap();
        let usvstringValue = &self.usvstringValue;
        rooted!(in(cx) let mut usvstringValue_js = UndefinedValue());
        usvstringValue.to_jsval(cx, usvstringValue_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "usvstringValue", usvstringValue_js.handle()).unwrap();
        rval.set(ObjectOrNullValue(obj.get()))
    }
}


#[derive(JSTraceable, PartialEq)]
#[allow_unrooted_interior]
pub struct SimpleCallback<TH: TypeHolderTrait> {
    pub parent: CallbackFunction<TH>,
}

impl<TH: TypeHolderTrait> SimpleCallback<TH> {
    pub unsafe fn new(aCx: *mut JSContext, aCallback: *mut JSObject) -> Rc<SimpleCallback<TH>> {
        let mut ret = Rc::new(SimpleCallback {
            parent: CallbackFunction::new()
        });
        // Note: callback cannot be moved after calling init.
        match Rc::get_mut(&mut ret) {
            Some(ref mut callback) => callback.parent.init(aCx, aCallback),
            None => unreachable!(),
        };
        ret
    }

    pub fn Call_<T: DomObject>(&self, thisObj: &T, value: HandleValue, aExceptionHandling: ExceptionHandling) -> Fallible<(), TH> {
        let s = CallSetup::new(self, aExceptionHandling);
        rooted!(in(s.get_context()) let mut thisObjJS = ptr::null_mut::<JSObject>());
        wrap_call_this_object(s.get_context(), thisObj, thisObjJS.handle_mut());
        if thisObjJS.is_null() {
            return Err(JSFailed);
        }
        unsafe { self.Call(s.get_context(), thisObjJS.handle(), value) }
    }

    pub fn Call__(&self, value: HandleValue, aExceptionHandling: ExceptionHandling) -> Fallible<(), TH> {
        let s = CallSetup::new(self, aExceptionHandling);
        rooted!(in(s.get_context()) let thisObjJS = ptr::null_mut::<JSObject>());
        unsafe { self.Call(s.get_context(), thisObjJS.handle(), value) }
    }

    unsafe fn Call(&self, cx: *mut JSContext, aThisObj: HandleObject, value: HandleValue) -> Fallible<(), TH> {
        rooted!(in(cx) let mut rval = UndefinedValue());
        rooted_vec!(let mut argv);
        argv.extend((0..1).map(|_| Heap::default()));

        let argc = 1;

        rooted!(in(cx) let mut argv_root = UndefinedValue());
        (value).to_jsval(cx, argv_root.handle_mut());
        {
        let arg = &mut argv[0];
        *arg = Heap::default();
        arg.set(argv_root.get());
        }

        rooted!(in(cx) let callable = ObjectValue(self.callback()));
        rooted!(in(cx) let rootedThis = aThisObj.get());
        let ok = JS_CallFunctionValue(
            cx, rootedThis.handle(), callable.handle(),
            &HandleValueArray {
                length_: argc as ::libc::size_t,
                elements_: argv.as_ptr() as *const JSVal
            }, rval.handle_mut());
        maybe_resume_unwind();
        if !ok {
            return Err(JSFailed);
        }

        Ok(())

    }
}
impl<TH: TypeHolderTrait> CallbackContainer<TH> for SimpleCallback<TH> {
    unsafe fn new(cx: *mut JSContext, callback: *mut JSObject) -> Rc<SimpleCallback<TH>> {
        SimpleCallback::new(cx, callback)
    }

    fn callback_holder(&self) -> &CallbackObject<TH> {
        self.parent.callback_holder()
    }
}

impl<TH: TypeHolderTrait> ToJSValConvertible for SimpleCallback<TH> {
    unsafe fn to_jsval(&self, cx: *mut JSContext, rval: MutableHandleValue) {
        self.callback().to_jsval(cx, rval);
    }
}

pub use self::TestBindingBinding::{TestBindingConstants, Wrap, TestBindingMethods, GetProtoObject, GetConstructorObject, DefineDOMInterface};
pub mod TestBindingBinding {
#![allow(non_camel_case_types,non_upper_case_globals,unused_imports,unused_variables,unused_assignments,unused_mut)]
use dom;
use dom::bindings;
use dom::bindings::callback::CallSetup;
use dom::bindings::callback::CallbackContainer;
use dom::bindings::callback::CallbackFunction;
use dom::bindings::callback::CallbackInterface;
use dom::bindings::callback::CallbackObject;
use dom::bindings::callback::ExceptionHandling;
use dom::bindings::callback::wrap_call_this_object;
use dom::bindings::codegen::Bindings::ElementBinding::ElementBinding;
use dom::bindings::codegen::Bindings::EventListenerBinding::EventListener;
use dom::bindings::codegen::Bindings::EventTargetBinding::EventTargetBinding;
use dom::bindings::codegen::Bindings::FunctionBinding::Function;
use dom::bindings::codegen::Bindings::NodeBinding::NodeBinding;
use dom::bindings::codegen::Bindings::TestBindingBinding::SimpleCallback;
use dom::bindings::codegen::Bindings::TestBindingBinding::TestDictionary;
use dom::bindings::codegen::Bindings::TestBindingBinding::TestDictionaryDefaults;
use dom::bindings::codegen::Bindings::TestBindingBinding::TestEnum;
use dom::bindings::codegen::Bindings::TestBindingBinding::TestEnumValues;
use dom::bindings::codegen::InterfaceObjectMap;
use dom::bindings::codegen::PrototypeList;
use dom::bindings::codegen::RegisterBindings;
use dom::bindings::codegen::UnionTypes;
use dom::bindings::constant::ConstantSpec;
use dom::bindings::constant::ConstantVal;
use dom::bindings::conversions::ConversionBehavior;
use dom::bindings::conversions::ConversionResult;
use dom::bindings::conversions::DOM_OBJECT_SLOT;
use dom::bindings::conversions::FromJSValConvertible;
use dom::bindings::conversions::IDLInterface;
use dom::bindings::conversions::StringificationBehavior;
use dom::bindings::conversions::ToJSValConvertible;
use dom::bindings::conversions::is_array_like;
use dom::bindings::conversions::jsid_to_string;
use dom::bindings::conversions::native_from_handlevalue;
use dom::bindings::conversions::native_from_object;
use dom::bindings::conversions::private_from_object;
use dom::bindings::conversions::root_from_handleobject;
use dom::bindings::conversions::root_from_handlevalue;
use dom::bindings::conversions::root_from_object;
use dom::bindings::error::Error;
use dom::bindings::error::Error::JSFailed;
use dom::bindings::error::ErrorResult;
use dom::bindings::error::Fallible;
use dom::bindings::error::throw_dom_exception;
use dom::bindings::guard::Condition;
use dom::bindings::guard::Guard;
use dom::bindings::htmlconstructor::html_constructor;
use dom::bindings::htmlconstructor::pop_current_element_queue;
use dom::bindings::htmlconstructor::push_new_element_queue;
use dom::bindings::inheritance::Castable;
use dom::bindings::interface::ConstructorClassHook;
use dom::bindings::interface::InterfaceConstructorBehavior;
use dom::bindings::interface::NonCallbackInterfaceObjectClass;
use dom::bindings::interface::create_callback_interface_object;
use dom::bindings::interface::create_global_object;
use dom::bindings::interface::create_interface_prototype_object;
use dom::bindings::interface::create_named_constructors;
use dom::bindings::interface::create_noncallback_interface_object;
use dom::bindings::interface::define_guarded_constants;
use dom::bindings::interface::define_guarded_methods;
use dom::bindings::interface::define_guarded_properties;
use dom::bindings::interface::is_exposed_in;
use dom::bindings::iterable::Iterable;
use dom::bindings::iterable::IteratorType;
use dom::bindings::mozmap::MozMap;
use dom::bindings::namespace::NamespaceObjectClass;
use dom::bindings::namespace::create_namespace_object;
use dom::bindings::num::Finite;
use dom::bindings::proxyhandler;
use dom::bindings::proxyhandler::ensure_expando_object;
use dom::bindings::proxyhandler::fill_property_descriptor;
use dom::bindings::proxyhandler::get_expando_object;
use dom::bindings::proxyhandler::get_property_descriptor;
use dom::bindings::reflector::DomObject;
use dom::bindings::reflector::MutDomObject;
use dom::bindings::root::Dom;
use dom::bindings::root::DomRoot;
use dom::bindings::root::OptionalHeapSetter;
use dom::bindings::root::RootedReference;
use dom::bindings::str::ByteString;
use dom::bindings::str::DOMString;
use dom::bindings::str::USVString;
use dom::bindings::trace::JSTraceable;
use dom::bindings::trace::RootedTraceable;
use dom::bindings::trace::RootedTraceableBox;
use dom::bindings::utils::AsVoidPtr;
use dom::bindings::utils::DOMClass;
use dom::bindings::utils::DOMJSClass;
use dom::bindings::utils::DOM_PROTO_UNFORGEABLE_HOLDER_SLOT;
use dom::bindings::utils::JSCLASS_DOM_GLOBAL;
use dom::bindings::utils::ProtoOrIfaceArray;
use dom::bindings::utils::enumerate_global;
use dom::bindings::utils::finalize_global;
use dom::bindings::utils::find_enum_value;
use dom::bindings::utils::generic_getter;
use dom::bindings::utils::generic_lenient_getter;
use dom::bindings::utils::generic_lenient_setter;
use dom::bindings::utils::generic_method;
use dom::bindings::utils::generic_setter;
use dom::bindings::utils::get_array_index_from_id;
use dom::bindings::utils::get_dictionary_property;
use dom::bindings::utils::get_property_on_prototype;
use dom::bindings::utils::get_proto_or_iface_array;
use dom::bindings::utils::has_property_on_prototype;
use dom::bindings::utils::is_platform_object;
use dom::bindings::utils::resolve_global;
use dom::bindings::utils::set_dictionary_property;
use dom::bindings::utils::trace_global;
use dom::bindings::weakref::DOM_WEAK_SLOT;
use dom::bindings::weakref::WeakBox;
use dom::bindings::weakref::WeakReferenceable;
use dom::globalscope::GlobalScope;
use dom::promise::Promise;
use dom::types::Blob;
use dom::types::Document;
use dom::types::Element;
use dom::types::Event;
use dom::types::EventTarget;
use dom::types::HTMLElement;
use dom::types::Node;
use dom::types::TestBinding;
use dom::types::URL;
use dom::windowproxy::WindowProxy;
use js;
use js::JSCLASS_GLOBAL_SLOT_COUNT;
use js::JSCLASS_IS_DOMJSCLASS;
use js::JSCLASS_IS_GLOBAL;
use js::JSCLASS_RESERVED_SLOTS_MASK;
use js::JS_CALLEE;
use js::error::throw_internal_error;
use js::error::throw_type_error;
use js::glue::AppendToAutoIdVector;
use js::glue::CallJitGetterOp;
use js::glue::CallJitMethodOp;
use js::glue::CallJitSetterOp;
use js::glue::CreateProxyHandler;
use js::glue::GetProxyPrivate;
use js::glue::ProxyTraps;
use js::glue::RUST_JSID_IS_INT;
use js::glue::RUST_JSID_IS_STRING;
use js::glue::RUST_SYMBOL_TO_JSID;
use js::glue::UnwrapObject;
use js::glue::int_to_jsid;
use js::jsapi::AutoIdVector;
use js::jsapi::CallArgs;
use js::jsapi::CurrentGlobalOrNull;
use js::jsapi::FreeOp;
use js::jsapi::GetWellKnownSymbol;
use js::jsapi::Handle as RawHandle;
use js::jsapi::HandleId as RawHandleId;
use js::jsapi::HandleObject as RawHandleObject;
use js::jsapi::HandleValue as RawHandleValue;
use js::jsapi::HandleValueArray;
use js::jsapi::Heap;
use js::jsapi::INTERNED_STRING_TO_JSID;
use js::jsapi::IsCallable;
use js::jsapi::JSAutoCompartment;
use js::jsapi::JSCLASS_RESERVED_SLOTS_SHIFT;
use js::jsapi::JSClass;
use js::jsapi::JSContext;
use js::jsapi::JSFreeOp;
use js::jsapi::JSFunctionSpec;
use js::jsapi::JSITER_HIDDEN;
use js::jsapi::JSITER_OWNONLY;
use js::jsapi::JSITER_SYMBOLS;
use js::jsapi::JSJitGetterCallArgs;
use js::jsapi::JSJitInfo;
use js::jsapi::JSJitInfo_AliasSet;
use js::jsapi::JSJitInfo_ArgType;
use js::jsapi::JSJitInfo_OpType;
use js::jsapi::JSJitMethodCallArgs;
use js::jsapi::JSJitSetterCallArgs;
use js::jsapi::JSNative;
use js::jsapi::JSNativeWrapper;
use js::jsapi::JSObject;
use js::jsapi::JSPROP_ENUMERATE;
use js::jsapi::JSPROP_PERMANENT;
use js::jsapi::JSPROP_READONLY;
use js::jsapi::JSPROP_SHARED;
use js::jsapi::JSPropertySpec;
use js::jsapi::JSString;
use js::jsapi::JSTracer;
use js::jsapi::JSType;
use js::jsapi::JSTypedMethodJitInfo;
use js::jsapi::JSValueType;
use js::jsapi::JS_AtomizeAndPinString;
use js::jsapi::JS_ForwardGetPropertyTo;
use js::jsapi::JS_GetErrorPrototype;
use js::jsapi::JS_GetGlobalForObject;
use js::jsapi::JS_GetIteratorPrototype;
use js::jsapi::JS_GetPropertyById;
use js::jsapi::JS_GetPropertyDescriptorById;
use js::jsapi::JS_GetReservedSlot;
use js::jsapi::JS_HasProperty;
use js::jsapi::JS_HasPropertyById;
use js::jsapi::JS_NewObject;
use js::jsapi::JS_SetReservedSlot;
use js::jsapi::MutableHandle as RawMutableHandle;
use js::jsapi::MutableHandleObject as RawMutableHandleObject;
use js::jsapi::MutableHandleValue as RawMutableHandleValue;
use js::jsapi::ObjectOpResult;
use js::jsapi::PropertyDescriptor;
use js::jsapi::Rooted;
use js::jsapi::RootedId;
use js::jsapi::RootedObject;
use js::jsapi::RootedString;
use js::jsapi::SymbolCode;
use js::jsapi::jsid;
use js::jsval::JSVal;
use js::jsval::NullValue;
use js::jsval::ObjectOrNullValue;
use js::jsval::ObjectValue;
use js::jsval::PrivateValue;
use js::jsval::UndefinedValue;
use js::panic::maybe_resume_unwind;
use js::panic::wrap_panic;
use js::rust::CustomAutoRooterGuard;
use js::rust::GCMethods;
use js::rust::Handle;
use js::rust::HandleId;
use js::rust::HandleObject;
use js::rust::HandleValue;
use js::rust::MutableHandle;
use js::rust::MutableHandleObject;
use js::rust::MutableHandleValue;
use js::rust::define_methods;
use js::rust::define_properties;
use js::rust::get_object_class;
use js::rust::wrappers::Call;
use js::rust::wrappers::GetPropertyKeys;
use js::rust::wrappers::JS_CallFunctionValue;
use js::rust::wrappers::JS_CopyPropertiesFrom;
use js::rust::wrappers::JS_DefineProperty;
use js::rust::wrappers::JS_DefinePropertyById2;
use js::rust::wrappers::JS_GetFunctionPrototype;
use js::rust::wrappers::JS_GetObjectPrototype;
use js::rust::wrappers::JS_GetProperty;
use js::rust::wrappers::JS_InitializePropertiesFromCompatibleNativeObject;
use js::rust::wrappers::JS_NewObjectWithGivenProto;
use js::rust::wrappers::JS_NewObjectWithoutMetadata;
use js::rust::wrappers::JS_ObjectIsDate;
use js::rust::wrappers::JS_SetImmutablePrototype;
use js::rust::wrappers::JS_SetProperty;
use js::rust::wrappers::JS_SetPrototype;
use js::rust::wrappers::JS_SplicePrototype;
use js::rust::wrappers::JS_WrapObject;
use js::rust::wrappers::JS_WrapValue;
use js::rust::wrappers::NewProxyObject;
use js::typedarray;
use libc;
use malloc_size_of::MallocSizeOfOps;
use mem::malloc_size_of_including_raw_self;
use servo_config::prefs::PREFS;
use std::borrow::ToOwned;
use std::cmp;
use std::default::Default;
use std::ffi::CString;
use std::mem;
use std::num;
use std::os;
use std::os::raw::c_void;
use std::panic;
use std::ptr;
use std::ptr::NonNull;
use std::rc;
use std::rc::Rc;
use std::str;
use typeholder::TypeHolderTrait;

unsafe extern fn get_booleanAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: bool = this.BooleanAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_booleanAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: bool = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetBooleanAttribute(arg0);

        return true;
    }), false);
}


const booleanAttribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_booleanAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_BOOLEAN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const booleanAttribute_setterinfo: JSJitInfo = JSJitInfo {
    call: set_booleanAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_byteAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: i8 = this.ByteAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_byteAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: i8 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetByteAttribute(arg0);

        return true;
    }), false);
}


const byteAttribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_byteAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const byteAttribute_setterinfo: JSJitInfo = JSJitInfo {
    call: set_byteAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_octetAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: u8 = this.OctetAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_octetAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: u8 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetOctetAttribute(arg0);

        return true;
    }), false);
}


const octetAttribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_octetAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const octetAttribute_setterinfo: JSJitInfo = JSJitInfo {
    call: set_octetAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_shortAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: i16 = this.ShortAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_shortAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: i16 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetShortAttribute(arg0);

        return true;
    }), false);
}


const shortAttribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_shortAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const shortAttribute_setterinfo: JSJitInfo = JSJitInfo {
    call: set_shortAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_unsignedShortAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: u16 = this.UnsignedShortAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_unsignedShortAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: u16 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetUnsignedShortAttribute(arg0);

        return true;
    }), false);
}


const unsignedShortAttribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_unsignedShortAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const unsignedShortAttribute_setterinfo: JSJitInfo = JSJitInfo {
    call: set_unsignedShortAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_longAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: i32 = this.LongAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_longAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: i32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetLongAttribute(arg0);

        return true;
    }), false);
}


const longAttribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_longAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const longAttribute_setterinfo: JSJitInfo = JSJitInfo {
    call: set_longAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_unsignedLongAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: u32 = this.UnsignedLongAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_unsignedLongAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetUnsignedLongAttribute(arg0);

        return true;
    }), false);
}


const unsignedLongAttribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_unsignedLongAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const unsignedLongAttribute_setterinfo: JSJitInfo = JSJitInfo {
    call: set_unsignedLongAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_longLongAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: i64 = this.LongLongAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_longLongAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: i64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetLongLongAttribute(arg0);

        return true;
    }), false);
}


const longLongAttribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_longLongAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const longLongAttribute_setterinfo: JSJitInfo = JSJitInfo {
    call: set_longLongAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_unsignedLongLongAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: u64 = this.UnsignedLongLongAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_unsignedLongLongAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: u64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetUnsignedLongLongAttribute(arg0);

        return true;
    }), false);
}


const unsignedLongLongAttribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_unsignedLongLongAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const unsignedLongLongAttribute_setterinfo: JSJitInfo = JSJitInfo {
    call: set_unsignedLongLongAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_unrestrictedFloatAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f32 = this.UnrestrictedFloatAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_unrestrictedFloatAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetUnrestrictedFloatAttribute(arg0);

        return true;
    }), false);
}


const unrestrictedFloatAttribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_unrestrictedFloatAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const unrestrictedFloatAttribute_setterinfo: JSJitInfo = JSJitInfo {
    call: set_unrestrictedFloatAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_floatAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Finite<f32> = this.FloatAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_floatAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Finite<f32> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetFloatAttribute(arg0);

        return true;
    }), false);
}


const floatAttribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_floatAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const floatAttribute_setterinfo: JSJitInfo = JSJitInfo {
    call: set_floatAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_unrestrictedDoubleAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: f64 = this.UnrestrictedDoubleAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_unrestrictedDoubleAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetUnrestrictedDoubleAttribute(arg0);

        return true;
    }), false);
}


const unrestrictedDoubleAttribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_unrestrictedDoubleAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const unrestrictedDoubleAttribute_setterinfo: JSJitInfo = JSJitInfo {
    call: set_unrestrictedDoubleAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_doubleAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Finite<f64> = this.DoubleAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_doubleAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Finite<f64> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetDoubleAttribute(arg0);

        return true;
    }), false);
}


const doubleAttribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_doubleAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const doubleAttribute_setterinfo: JSJitInfo = JSJitInfo {
    call: set_doubleAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_stringAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DOMString = this.StringAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_stringAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetStringAttribute(arg0);

        return true;
    }), false);
}


const stringAttribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_stringAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const stringAttribute_setterinfo: JSJitInfo = JSJitInfo {
    call: set_stringAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_usvstringAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: USVString = this.UsvstringAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_usvstringAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: USVString = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUsvstringAttribute(arg0);

        return true;
    }), false);
}


const usvstringAttribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_usvstringAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const usvstringAttribute_setterinfo: JSJitInfo = JSJitInfo {
    call: set_usvstringAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_byteStringAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: ByteString = this.ByteStringAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_byteStringAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: ByteString = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetByteStringAttribute(arg0);

        return true;
    }), false);
}


const byteStringAttribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_byteStringAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const byteStringAttribute_setterinfo: JSJitInfo = JSJitInfo {
    call: set_byteStringAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_enumAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: TestEnum = this.EnumAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_enumAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: TestEnum = match find_enum_value(cx, args.get(0), TestEnumValues::pairs) {
            Err(_) => { return false;
         },
            Ok((None, search)) => { return true; },
            Ok((Some(&value), _)) => value,
        };
        let result: () = this.SetEnumAttribute(arg0);

        return true;
    }), false);
}


const enumAttribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_enumAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const enumAttribute_setterinfo: JSJitInfo = JSJitInfo {
    call: set_enumAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_interfaceAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<Blob<TH>> = this.InterfaceAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_interfaceAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DomRoot<Blob<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface Blob.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.SetInterfaceAttribute(&arg0);

        return true;
    }), false);
}


const interfaceAttribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_interfaceAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const interfaceAttribute_setterinfo: JSJitInfo = JSJitInfo {
    call: set_interfaceAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_unionAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: UnionTypes::HTMLElementOrLong = this.UnionAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_unionAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: UnionTypes::HTMLElementOrLong<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUnionAttribute(arg0);

        return true;
    }), false);
}


const unionAttribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_unionAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const unionAttribute_setterinfo: JSJitInfo = JSJitInfo {
    call: set_unionAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_union2Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: UnionTypes::EventOrString = this.Union2Attribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_union2Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: UnionTypes::EventOrString<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUnion2Attribute(arg0);

        return true;
    }), false);
}


const union2Attribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_union2Attribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const union2Attribute_setterinfo: JSJitInfo = JSJitInfo {
    call: set_union2Attribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_union3Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: UnionTypes::EventOrUSVString = this.Union3Attribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_union3Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: UnionTypes::EventOrUSVString<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUnion3Attribute(arg0);

        return true;
    }), false);
}


const union3Attribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_union3Attribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const union3Attribute_setterinfo: JSJitInfo = JSJitInfo {
    call: set_union3Attribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_union4Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: UnionTypes::StringOrUnsignedLong = this.Union4Attribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_union4Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: UnionTypes::StringOrUnsignedLong = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUnion4Attribute(arg0);

        return true;
    }), false);
}


const union4Attribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_union4Attribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const union4Attribute_setterinfo: JSJitInfo = JSJitInfo {
    call: set_union4Attribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_union5Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: UnionTypes::StringOrBoolean = this.Union5Attribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_union5Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: UnionTypes::StringOrBoolean = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUnion5Attribute(arg0);

        return true;
    }), false);
}


const union5Attribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_union5Attribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const union5Attribute_setterinfo: JSJitInfo = JSJitInfo {
    call: set_union5Attribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_union6Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: UnionTypes::UnsignedLongOrBoolean = this.Union6Attribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_union6Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: UnionTypes::UnsignedLongOrBoolean = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUnion6Attribute(arg0);

        return true;
    }), false);
}


const union6Attribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_union6Attribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const union6Attribute_setterinfo: JSJitInfo = JSJitInfo {
    call: set_union6Attribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_union7Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: UnionTypes::BlobOrBoolean = this.Union7Attribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_union7Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: UnionTypes::BlobOrBoolean<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUnion7Attribute(arg0);

        return true;
    }), false);
}


const union7Attribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_union7Attribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const union7Attribute_setterinfo: JSJitInfo = JSJitInfo {
    call: set_union7Attribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_union8Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: UnionTypes::BlobOrUnsignedLong = this.Union8Attribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_union8Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: UnionTypes::BlobOrUnsignedLong<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUnion8Attribute(arg0);

        return true;
    }), false);
}


const union8Attribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_union8Attribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const union8Attribute_setterinfo: JSJitInfo = JSJitInfo {
    call: set_union8Attribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_union9Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: UnionTypes::ByteStringOrLong = this.Union9Attribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_union9Attribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: UnionTypes::ByteStringOrLong = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUnion9Attribute(arg0);

        return true;
    }), false);
}


const union9Attribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_union9Attribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const union9Attribute_setterinfo: JSJitInfo = JSJitInfo {
    call: set_union9Attribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_arrayAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: NonNull<JSObject> = this.ArrayAttribute(cx);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const arrayAttribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_arrayAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_anyAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: JSVal = this.AnyAttribute(cx);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_anyAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: HandleValue = args.get(0);
        let result: () = this.SetAnyAttribute(cx, arg0);

        return true;
    }), false);
}


const anyAttribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_anyAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const anyAttribute_setterinfo: JSJitInfo = JSJitInfo {
    call: set_anyAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_objectAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: NonNull<JSObject> = this.ObjectAttribute(cx);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_objectAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: *mut JSObject = if args.get(0).get().is_object() {
            args.get(0).get().to_object()
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.SetObjectAttribute(cx, arg0);

        return true;
    }), false);
}


const objectAttribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_objectAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const objectAttribute_setterinfo: JSJitInfo = JSJitInfo {
    call: set_objectAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_booleanAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<bool> = this.GetBooleanAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_booleanAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<bool> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetBooleanAttributeNullable(arg0);

        return true;
    }), false);
}


const booleanAttributeNullable_getterinfo: JSJitInfo = JSJitInfo {
    call: get_booleanAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const booleanAttributeNullable_setterinfo: JSJitInfo = JSJitInfo {
    call: set_booleanAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_byteAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<i8> = this.GetByteAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_byteAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<i8> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetByteAttributeNullable(arg0);

        return true;
    }), false);
}


const byteAttributeNullable_getterinfo: JSJitInfo = JSJitInfo {
    call: get_byteAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const byteAttributeNullable_setterinfo: JSJitInfo = JSJitInfo {
    call: set_byteAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_octetAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<u8> = this.GetOctetAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_octetAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<u8> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetOctetAttributeNullable(arg0);

        return true;
    }), false);
}


const octetAttributeNullable_getterinfo: JSJitInfo = JSJitInfo {
    call: get_octetAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const octetAttributeNullable_setterinfo: JSJitInfo = JSJitInfo {
    call: set_octetAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_shortAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<i16> = this.GetShortAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_shortAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<i16> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetShortAttributeNullable(arg0);

        return true;
    }), false);
}


const shortAttributeNullable_getterinfo: JSJitInfo = JSJitInfo {
    call: get_shortAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const shortAttributeNullable_setterinfo: JSJitInfo = JSJitInfo {
    call: set_shortAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_unsignedShortAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<u16> = this.GetUnsignedShortAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_unsignedShortAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<u16> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetUnsignedShortAttributeNullable(arg0);

        return true;
    }), false);
}


const unsignedShortAttributeNullable_getterinfo: JSJitInfo = JSJitInfo {
    call: get_unsignedShortAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const unsignedShortAttributeNullable_setterinfo: JSJitInfo = JSJitInfo {
    call: set_unsignedShortAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_longAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<i32> = this.GetLongAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_longAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<i32> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetLongAttributeNullable(arg0);

        return true;
    }), false);
}


const longAttributeNullable_getterinfo: JSJitInfo = JSJitInfo {
    call: get_longAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const longAttributeNullable_setterinfo: JSJitInfo = JSJitInfo {
    call: set_longAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_unsignedLongAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<u32> = this.GetUnsignedLongAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_unsignedLongAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<u32> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetUnsignedLongAttributeNullable(arg0);

        return true;
    }), false);
}


const unsignedLongAttributeNullable_getterinfo: JSJitInfo = JSJitInfo {
    call: get_unsignedLongAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const unsignedLongAttributeNullable_setterinfo: JSJitInfo = JSJitInfo {
    call: set_unsignedLongAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_longLongAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<i64> = this.GetLongLongAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_longLongAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<i64> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetLongLongAttributeNullable(arg0);

        return true;
    }), false);
}


const longLongAttributeNullable_getterinfo: JSJitInfo = JSJitInfo {
    call: get_longLongAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const longLongAttributeNullable_setterinfo: JSJitInfo = JSJitInfo {
    call: set_longLongAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_unsignedLongLongAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<u64> = this.GetUnsignedLongLongAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_unsignedLongLongAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<u64> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetUnsignedLongLongAttributeNullable(arg0);

        return true;
    }), false);
}


const unsignedLongLongAttributeNullable_getterinfo: JSJitInfo = JSJitInfo {
    call: get_unsignedLongLongAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const unsignedLongLongAttributeNullable_setterinfo: JSJitInfo = JSJitInfo {
    call: set_unsignedLongLongAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_unrestrictedFloatAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<f32> = this.GetUnrestrictedFloatAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_unrestrictedFloatAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<f32> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetUnrestrictedFloatAttributeNullable(arg0);

        return true;
    }), false);
}


const unrestrictedFloatAttributeNullable_getterinfo: JSJitInfo = JSJitInfo {
    call: get_unrestrictedFloatAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const unrestrictedFloatAttributeNullable_setterinfo: JSJitInfo = JSJitInfo {
    call: set_unrestrictedFloatAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_floatAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Finite<f32>> = this.GetFloatAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_floatAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Finite<f32>> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetFloatAttributeNullable(arg0);

        return true;
    }), false);
}


const floatAttributeNullable_getterinfo: JSJitInfo = JSJitInfo {
    call: get_floatAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const floatAttributeNullable_setterinfo: JSJitInfo = JSJitInfo {
    call: set_floatAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_unrestrictedDoubleAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<f64> = this.GetUnrestrictedDoubleAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_unrestrictedDoubleAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<f64> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetUnrestrictedDoubleAttributeNullable(arg0);

        return true;
    }), false);
}


const unrestrictedDoubleAttributeNullable_getterinfo: JSJitInfo = JSJitInfo {
    call: get_unrestrictedDoubleAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const unrestrictedDoubleAttributeNullable_setterinfo: JSJitInfo = JSJitInfo {
    call: set_unrestrictedDoubleAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_doubleAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Finite<f64>> = this.GetDoubleAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_doubleAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Finite<f64>> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SetDoubleAttributeNullable(arg0);

        return true;
    }), false);
}


const doubleAttributeNullable_getterinfo: JSJitInfo = JSJitInfo {
    call: get_doubleAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const doubleAttributeNullable_setterinfo: JSJitInfo = JSJitInfo {
    call: set_doubleAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_stringAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DOMString> = this.GetStringAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_stringAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<DOMString> = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetStringAttributeNullable(arg0);

        return true;
    }), false);
}


const stringAttributeNullable_getterinfo: JSJitInfo = JSJitInfo {
    call: get_stringAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const stringAttributeNullable_setterinfo: JSJitInfo = JSJitInfo {
    call: set_stringAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_usvstringAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<USVString> = this.GetUsvstringAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_usvstringAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<USVString> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUsvstringAttributeNullable(arg0);

        return true;
    }), false);
}


const usvstringAttributeNullable_getterinfo: JSJitInfo = JSJitInfo {
    call: get_usvstringAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const usvstringAttributeNullable_setterinfo: JSJitInfo = JSJitInfo {
    call: set_usvstringAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_byteStringAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<ByteString> = this.GetByteStringAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_byteStringAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<ByteString> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetByteStringAttributeNullable(arg0);

        return true;
    }), false);
}


const byteStringAttributeNullable_getterinfo: JSJitInfo = JSJitInfo {
    call: get_byteStringAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const byteStringAttributeNullable_setterinfo: JSJitInfo = JSJitInfo {
    call: set_byteStringAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_enumAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<TestEnum> = this.GetEnumAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const enumAttributeNullable_getterinfo: JSJitInfo = JSJitInfo {
    call: get_enumAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_interfaceAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DomRoot<Blob<TH>>> = this.GetInterfaceAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_interfaceAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<DomRoot<Blob<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface Blob.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.SetInterfaceAttributeNullable(arg0.r());

        return true;
    }), false);
}


const interfaceAttributeNullable_getterinfo: JSJitInfo = JSJitInfo {
    call: get_interfaceAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const interfaceAttributeNullable_setterinfo: JSJitInfo = JSJitInfo {
    call: set_interfaceAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_interfaceAttributeWeak<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DomRoot<URL<TH>>> = this.GetInterfaceAttributeWeak();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_interfaceAttributeWeak<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<DomRoot<URL<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface URL.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.SetInterfaceAttributeWeak(arg0.r());

        return true;
    }), false);
}


const interfaceAttributeWeak_getterinfo: JSJitInfo = JSJitInfo {
    call: get_interfaceAttributeWeak as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const interfaceAttributeWeak_setterinfo: JSJitInfo = JSJitInfo {
    call: set_interfaceAttributeWeak as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_objectAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<NonNull<JSObject>> = this.GetObjectAttributeNullable(cx);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_objectAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: *mut JSObject = if args.get(0).get().is_object() {
            args.get(0).get().to_object()
        } else if args.get(0).get().is_null_or_undefined() {
            ptr::null_mut()
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.SetObjectAttributeNullable(cx, arg0);

        return true;
    }), false);
}


const objectAttributeNullable_getterinfo: JSJitInfo = JSJitInfo {
    call: get_objectAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const objectAttributeNullable_setterinfo: JSJitInfo = JSJitInfo {
    call: set_objectAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_unionAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<UnionTypes::HTMLElementOrLong> = this.GetUnionAttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_unionAttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<UnionTypes::HTMLElementOrLong<TH>> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUnionAttributeNullable(arg0);

        return true;
    }), false);
}


const unionAttributeNullable_getterinfo: JSJitInfo = JSJitInfo {
    call: get_unionAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const unionAttributeNullable_setterinfo: JSJitInfo = JSJitInfo {
    call: set_unionAttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_union2AttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<UnionTypes::EventOrString> = this.GetUnion2AttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_union2AttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<UnionTypes::EventOrString<TH>> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUnion2AttributeNullable(arg0);

        return true;
    }), false);
}


const union2AttributeNullable_getterinfo: JSJitInfo = JSJitInfo {
    call: get_union2AttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const union2AttributeNullable_setterinfo: JSJitInfo = JSJitInfo {
    call: set_union2AttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_union3AttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<UnionTypes::BlobOrBoolean> = this.GetUnion3AttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_union3AttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<UnionTypes::BlobOrBoolean<TH>> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUnion3AttributeNullable(arg0);

        return true;
    }), false);
}


const union3AttributeNullable_getterinfo: JSJitInfo = JSJitInfo {
    call: get_union3AttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const union3AttributeNullable_setterinfo: JSJitInfo = JSJitInfo {
    call: set_union3AttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_union4AttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<UnionTypes::UnsignedLongOrBoolean> = this.GetUnion4AttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_union4AttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<UnionTypes::UnsignedLongOrBoolean> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUnion4AttributeNullable(arg0);

        return true;
    }), false);
}


const union4AttributeNullable_getterinfo: JSJitInfo = JSJitInfo {
    call: get_union4AttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const union4AttributeNullable_setterinfo: JSJitInfo = JSJitInfo {
    call: set_union4AttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_union5AttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<UnionTypes::StringOrBoolean> = this.GetUnion5AttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_union5AttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<UnionTypes::StringOrBoolean> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUnion5AttributeNullable(arg0);

        return true;
    }), false);
}


const union5AttributeNullable_getterinfo: JSJitInfo = JSJitInfo {
    call: get_union5AttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const union5AttributeNullable_setterinfo: JSJitInfo = JSJitInfo {
    call: set_union5AttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_union6AttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<UnionTypes::ByteStringOrLong> = this.GetUnion6AttributeNullable();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_union6AttributeNullable<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<UnionTypes::ByteStringOrLong> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetUnion6AttributeNullable(arg0);

        return true;
    }), false);
}


const union6AttributeNullable_getterinfo: JSJitInfo = JSJitInfo {
    call: get_union6AttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const union6AttributeNullable_setterinfo: JSJitInfo = JSJitInfo {
    call: set_union6AttributeNullable as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_attrToBinaryRename<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DOMString = this.BinaryRenamedAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_attrToBinaryRename<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetBinaryRenamedAttribute(arg0);

        return true;
    }), false);
}


const attrToBinaryRename_getterinfo: JSJitInfo = JSJitInfo {
    call: get_attrToBinaryRename as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const attrToBinaryRename_setterinfo: JSJitInfo = JSJitInfo {
    call: set_attrToBinaryRename as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_attr_to_binary_rename<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DOMString = this.BinaryRenamedAttribute2();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_attr_to_binary_rename<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetBinaryRenamedAttribute2(arg0);

        return true;
    }), false);
}


const attr_to_binary_rename_getterinfo: JSJitInfo = JSJitInfo {
    call: get_attr_to_binary_rename as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const attr_to_binary_rename_setterinfo: JSJitInfo = JSJitInfo {
    call: set_attr_to_binary_rename as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_attr_to_automatically_rename<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DOMString = this.Attr_to_automatically_rename();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_attr_to_automatically_rename<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetAttr_to_automatically_rename(arg0);

        return true;
    }), false);
}


const attr_to_automatically_rename_getterinfo: JSJitInfo = JSJitInfo {
    call: get_attr_to_automatically_rename as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const attr_to_automatically_rename_setterinfo: JSJitInfo = JSJitInfo {
    call: set_attr_to_automatically_rename as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_forwardedAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<TestBinding<TH>> = this.ForwardedAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_forwardedAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const TestBinding<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        rooted!(in(cx) let mut v = UndefinedValue());
        if !JS_GetProperty(cx, obj, b"forwardedAttribute\0" as *const u8 as *const libc::c_char, v.handle_mut()) {
            return false;
        }
        if !v.is_object() {
            throw_type_error(cx, "Value.forwardedAttribute is not an object.");
            return false;
        }
        rooted!(in(cx) let target_obj = v.to_object());
        JS_SetProperty(cx, target_obj.handle(), b"booleanAttribute\0" as *const u8 as *const libc::c_char, args.get(0))

    }), false);
}


const forwardedAttribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_forwardedAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

const forwardedAttribute_setterinfo: JSJitInfo = JSJitInfo {
    call: set_forwardedAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn methToBinaryRename<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.BinaryRenamedMethod();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const methToBinaryRename_methodinfo: JSJitInfo = JSJitInfo {
    call: methToBinaryRename as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveVoid<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.ReceiveVoid();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveVoid_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveVoid as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveBoolean<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: bool = this.ReceiveBoolean();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveBoolean_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveBoolean as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_BOOLEAN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveByte<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: i8 = this.ReceiveByte();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveByte_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveByte as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveOctet<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: u8 = this.ReceiveOctet();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveOctet_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveOctet as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveShort<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: i16 = this.ReceiveShort();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveShort_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveShort as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveUnsignedShort<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: u16 = this.ReceiveUnsignedShort();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveUnsignedShort_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveUnsignedShort as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: i32 = this.ReceiveLong();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveLong_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveLong as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveUnsignedLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: u32 = this.ReceiveUnsignedLong();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveUnsignedLong_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveUnsignedLong as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveLongLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: i64 = this.ReceiveLongLong();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveLongLong_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveLongLong as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveUnsignedLongLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: u64 = this.ReceiveUnsignedLongLong();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveUnsignedLongLong_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveUnsignedLongLong as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveUnrestrictedFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: f32 = this.ReceiveUnrestrictedFloat();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveUnrestrictedFloat_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveUnrestrictedFloat as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Finite<f32> = this.ReceiveFloat();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveFloat_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveFloat as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveUnrestrictedDouble<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: f64 = this.ReceiveUnrestrictedDouble();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveUnrestrictedDouble_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveUnrestrictedDouble as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveDouble<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Finite<f64> = this.ReceiveDouble();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveDouble_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveDouble as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveString<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: DOMString = this.ReceiveString();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveString_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveString as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveUsvstring<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: USVString = this.ReceiveUsvstring();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveUsvstring_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveUsvstring as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveByteString<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: ByteString = this.ReceiveByteString();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveByteString_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveByteString as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveEnum<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: TestEnum = this.ReceiveEnum();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveEnum_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveEnum as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: DomRoot<Blob<TH>> = this.ReceiveInterface();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveInterface_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveInterface as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveAny<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: JSVal = this.ReceiveAny(cx);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveAny_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveAny as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveObject<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: NonNull<JSObject> = this.ReceiveObject(cx);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveObject_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveObject as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveUnion<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: UnionTypes::HTMLElementOrLong = this.ReceiveUnion();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveUnion_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveUnion as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveUnion2<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: UnionTypes::EventOrString = this.ReceiveUnion2();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveUnion2_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveUnion2 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveUnion3<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: UnionTypes::StringOrLongSequence = this.ReceiveUnion3();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveUnion3_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveUnion3 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveUnion4<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: UnionTypes::StringOrStringSequence = this.ReceiveUnion4();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveUnion4_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveUnion4 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveUnion5<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: UnionTypes::BlobOrBlobSequence = this.ReceiveUnion5();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveUnion5_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveUnion5 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveUnion6<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: UnionTypes::StringOrUnsignedLong = this.ReceiveUnion6();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveUnion6_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveUnion6 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveUnion7<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: UnionTypes::StringOrBoolean = this.ReceiveUnion7();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveUnion7_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveUnion7 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveUnion8<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: UnionTypes::UnsignedLongOrBoolean = this.ReceiveUnion8();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveUnion8_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveUnion8 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveUnion9<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: UnionTypes::HTMLElementOrUnsignedLongOrStringOrBoolean = this.ReceiveUnion9();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveUnion9_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveUnion9 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveUnion10<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: UnionTypes::ByteStringOrLong = this.ReceiveUnion10();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveUnion10_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveUnion10 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveUnion11<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: UnionTypes::ByteStringSequenceOrLongOrString = this.ReceiveUnion11();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveUnion11_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveUnion11 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveSequence<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Vec<i32> = this.ReceiveSequence();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveSequence_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveSequence as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveInterfaceSequence<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Vec<DomRoot<Blob<TH>>> = this.ReceiveInterfaceSequence();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveInterfaceSequence_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveInterfaceSequence as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveNullableByte<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<i8> = this.ReceiveNullableByte();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveNullableByte_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveNullableByte as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveNullableBoolean<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<bool> = this.ReceiveNullableBoolean();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveNullableBoolean_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveNullableBoolean as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveNullableOctet<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<u8> = this.ReceiveNullableOctet();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveNullableOctet_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveNullableOctet as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveNullableShort<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<i16> = this.ReceiveNullableShort();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveNullableShort_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveNullableShort as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveNullableUnsignedShort<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<u16> = this.ReceiveNullableUnsignedShort();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveNullableUnsignedShort_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveNullableUnsignedShort as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveNullableLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<i32> = this.ReceiveNullableLong();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveNullableLong_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveNullableLong as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveNullableUnsignedLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<u32> = this.ReceiveNullableUnsignedLong();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveNullableUnsignedLong_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveNullableUnsignedLong as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveNullableLongLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<i64> = this.ReceiveNullableLongLong();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveNullableLongLong_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveNullableLongLong as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveNullableUnsignedLongLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<u64> = this.ReceiveNullableUnsignedLongLong();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveNullableUnsignedLongLong_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveNullableUnsignedLongLong as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveNullableUnrestrictedFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<f32> = this.ReceiveNullableUnrestrictedFloat();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveNullableUnrestrictedFloat_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveNullableUnrestrictedFloat as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveNullableFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<Finite<f32>> = this.ReceiveNullableFloat();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveNullableFloat_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveNullableFloat as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveNullableUnrestrictedDouble<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<f64> = this.ReceiveNullableUnrestrictedDouble();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveNullableUnrestrictedDouble_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveNullableUnrestrictedDouble as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveNullableDouble<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<Finite<f64>> = this.ReceiveNullableDouble();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveNullableDouble_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveNullableDouble as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveNullableString<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<DOMString> = this.ReceiveNullableString();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveNullableString_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveNullableString as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveNullableUsvstring<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<USVString> = this.ReceiveNullableUsvstring();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveNullableUsvstring_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveNullableUsvstring as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveNullableByteString<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<ByteString> = this.ReceiveNullableByteString();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveNullableByteString_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveNullableByteString as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveNullableEnum<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<TestEnum> = this.ReceiveNullableEnum();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveNullableEnum_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveNullableEnum as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveNullableInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<DomRoot<Blob<TH>>> = this.ReceiveNullableInterface();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveNullableInterface_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveNullableInterface as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveNullableObject<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<NonNull<JSObject>> = this.ReceiveNullableObject(cx);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveNullableObject_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveNullableObject as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveNullableUnion<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<UnionTypes::HTMLElementOrLong> = this.ReceiveNullableUnion();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveNullableUnion_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveNullableUnion as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveNullableUnion2<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<UnionTypes::EventOrString> = this.ReceiveNullableUnion2();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveNullableUnion2_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveNullableUnion2 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveNullableUnion3<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<UnionTypes::StringOrLongSequence> = this.ReceiveNullableUnion3();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveNullableUnion3_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveNullableUnion3 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveNullableUnion4<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<UnionTypes::LongSequenceOrBoolean> = this.ReceiveNullableUnion4();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveNullableUnion4_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveNullableUnion4 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveNullableUnion5<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<UnionTypes::UnsignedLongOrBoolean> = this.ReceiveNullableUnion5();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveNullableUnion5_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveNullableUnion5 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveNullableUnion6<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<UnionTypes::ByteStringOrLong> = this.ReceiveNullableUnion6();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveNullableUnion6_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveNullableUnion6 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveNullableSequence<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<Vec<i32>> = this.ReceiveNullableSequence();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveNullableSequence_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveNullableSequence as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveTestDictionaryWithSuccessOnKeyword<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: RootedTraceableBox<TestDictionary> = this.ReceiveTestDictionaryWithSuccessOnKeyword();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveTestDictionaryWithSuccessOnKeyword_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveTestDictionaryWithSuccessOnKeyword as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn dictMatchesPassedValues<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.dictMatchesPassedValues\".");
            return false;
        }
        let arg0: RootedTraceableBox<dom::bindings::codegen::Bindings::TestBindingBinding::TestDictionary> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(dictionary)) => dictionary,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: bool = this.DictMatchesPassedValues(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const dictMatchesPassedValues_methodinfo: JSJitInfo = JSJitInfo {
    call: dictMatchesPassedValues as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_BOOLEAN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveUnionIdentity<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.receiveUnionIdentity\".");
            return false;
        }
        let arg0: UnionTypes::StringOrObject = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: UnionTypes::StringOrObject = this.ReceiveUnionIdentity(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveUnionIdentity_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveUnionIdentity as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passBoolean<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passBoolean\".");
            return false;
        }
        let arg0: bool = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassBoolean(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passBoolean_methodinfo: JSJitInfo = JSJitInfo {
    call: passBoolean as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passByte<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passByte\".");
            return false;
        }
        let arg0: i8 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassByte(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passByte_methodinfo: JSJitInfo = JSJitInfo {
    call: passByte as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOctet<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passOctet\".");
            return false;
        }
        let arg0: u8 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassOctet(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOctet_methodinfo: JSJitInfo = JSJitInfo {
    call: passOctet as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passShort<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passShort\".");
            return false;
        }
        let arg0: i16 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassShort(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passShort_methodinfo: JSJitInfo = JSJitInfo {
    call: passShort as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passUnsignedShort<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnsignedShort\".");
            return false;
        }
        let arg0: u16 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassUnsignedShort(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passUnsignedShort_methodinfo: JSJitInfo = JSJitInfo {
    call: passUnsignedShort as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passLong\".");
            return false;
        }
        let arg0: i32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passLong_methodinfo: JSJitInfo = JSJitInfo {
    call: passLong as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passUnsignedLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnsignedLong\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassUnsignedLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passUnsignedLong_methodinfo: JSJitInfo = JSJitInfo {
    call: passUnsignedLong as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passLongLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passLongLong\".");
            return false;
        }
        let arg0: i64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassLongLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passLongLong_methodinfo: JSJitInfo = JSJitInfo {
    call: passLongLong as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passUnsignedLongLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnsignedLongLong\".");
            return false;
        }
        let arg0: u64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassUnsignedLongLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passUnsignedLongLong_methodinfo: JSJitInfo = JSJitInfo {
    call: passUnsignedLongLong as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passUnrestrictedFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnrestrictedFloat\".");
            return false;
        }
        let arg0: f32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassUnrestrictedFloat(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passUnrestrictedFloat_methodinfo: JSJitInfo = JSJitInfo {
    call: passUnrestrictedFloat as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passFloat\".");
            return false;
        }
        let arg0: Finite<f32> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassFloat(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passFloat_methodinfo: JSJitInfo = JSJitInfo {
    call: passFloat as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passUnrestrictedDouble<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnrestrictedDouble\".");
            return false;
        }
        let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassUnrestrictedDouble(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passUnrestrictedDouble_methodinfo: JSJitInfo = JSJitInfo {
    call: passUnrestrictedDouble as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passDouble<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passDouble\".");
            return false;
        }
        let arg0: Finite<f64> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassDouble(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passDouble_methodinfo: JSJitInfo = JSJitInfo {
    call: passDouble as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passString<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passString\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassString(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passString_methodinfo: JSJitInfo = JSJitInfo {
    call: passString as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passUsvstring<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUsvstring\".");
            return false;
        }
        let arg0: USVString = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassUsvstring(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passUsvstring_methodinfo: JSJitInfo = JSJitInfo {
    call: passUsvstring as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passByteString<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passByteString\".");
            return false;
        }
        let arg0: ByteString = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassByteString(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passByteString_methodinfo: JSJitInfo = JSJitInfo {
    call: passByteString as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passEnum<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passEnum\".");
            return false;
        }
        let arg0: TestEnum = match find_enum_value(cx, args.get(0), TestEnumValues::pairs) {
            Err(_) => { return false;
         },
            Ok((None, search)) => { throw_type_error(cx, &format!("'{}' is not a valid enum value for enumeration 'TestEnum'.", search)); return false;
         },
            Ok((Some(&value), _)) => value,
        };
        let result: () = this.PassEnum(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passEnum_methodinfo: JSJitInfo = JSJitInfo {
    call: passEnum as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passInterface\".");
            return false;
        }
        let arg0: DomRoot<Blob<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface Blob.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.PassInterface(&arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passInterface_methodinfo: JSJitInfo = JSJitInfo {
    call: passInterface as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passTypedArray<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passTypedArray\".");
            return false;
        }
        let arg0: typedarray::Int8Array = if args.get(0).get().is_object() {
            match typedarray::Int8Array::from(args.get(0).get().to_object()) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value is not a typed array.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        auto_root!(in(cx) let arg0 = arg0);
        let result: () = this.PassTypedArray(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passTypedArray_methodinfo: JSJitInfo = JSJitInfo {
    call: passTypedArray as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passTypedArray2<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passTypedArray2\".");
            return false;
        }
        let arg0: typedarray::ArrayBuffer = if args.get(0).get().is_object() {
            match typedarray::ArrayBuffer::from(args.get(0).get().to_object()) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value is not a typed array.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        auto_root!(in(cx) let arg0 = arg0);
        let result: () = this.PassTypedArray2(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passTypedArray2_methodinfo: JSJitInfo = JSJitInfo {
    call: passTypedArray2 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passTypedArray3<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passTypedArray3\".");
            return false;
        }
        let arg0: typedarray::ArrayBufferView = if args.get(0).get().is_object() {
            match typedarray::ArrayBufferView::from(args.get(0).get().to_object()) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value is not a typed array.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        auto_root!(in(cx) let arg0 = arg0);
        let result: () = this.PassTypedArray3(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passTypedArray3_methodinfo: JSJitInfo = JSJitInfo {
    call: passTypedArray3 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passUnion<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnion\".");
            return false;
        }
        let arg0: UnionTypes::HTMLElementOrLong<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassUnion(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passUnion_methodinfo: JSJitInfo = JSJitInfo {
    call: passUnion as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passUnion2<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnion2\".");
            return false;
        }
        let arg0: UnionTypes::EventOrString<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassUnion2(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passUnion2_methodinfo: JSJitInfo = JSJitInfo {
    call: passUnion2 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passUnion3<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnion3\".");
            return false;
        }
        let arg0: UnionTypes::BlobOrString<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassUnion3(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passUnion3_methodinfo: JSJitInfo = JSJitInfo {
    call: passUnion3 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passUnion4<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnion4\".");
            return false;
        }
        let arg0: UnionTypes::StringOrStringSequence = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassUnion4(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passUnion4_methodinfo: JSJitInfo = JSJitInfo {
    call: passUnion4 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passUnion5<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnion5\".");
            return false;
        }
        let arg0: UnionTypes::StringOrBoolean = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassUnion5(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passUnion5_methodinfo: JSJitInfo = JSJitInfo {
    call: passUnion5 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passUnion6<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnion6\".");
            return false;
        }
        let arg0: UnionTypes::UnsignedLongOrBoolean = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassUnion6(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passUnion6_methodinfo: JSJitInfo = JSJitInfo {
    call: passUnion6 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passUnion7<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnion7\".");
            return false;
        }
        let arg0: UnionTypes::StringSequenceOrUnsignedLong = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassUnion7(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passUnion7_methodinfo: JSJitInfo = JSJitInfo {
    call: passUnion7 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passUnion8<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnion8\".");
            return false;
        }
        let arg0: UnionTypes::ByteStringSequenceOrLong = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassUnion8(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passUnion8_methodinfo: JSJitInfo = JSJitInfo {
    call: passUnion8 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passUnion9<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnion9\".");
            return false;
        }
        let arg0: UnionTypes::TestDictionaryOrLong<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassUnion9(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passUnion9_methodinfo: JSJitInfo = JSJitInfo {
    call: passUnion9 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passUnion10<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnion10\".");
            return false;
        }
        let arg0: UnionTypes::StringOrObject = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassUnion10(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passUnion10_methodinfo: JSJitInfo = JSJitInfo {
    call: passUnion10 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passUnion11<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnion11\".");
            return false;
        }
        let arg0: UnionTypes::ArrayBufferOrArrayBufferView = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassUnion11(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passUnion11_methodinfo: JSJitInfo = JSJitInfo {
    call: passUnion11 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passUnionWithTypedef<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnionWithTypedef\".");
            return false;
        }
        let arg0: UnionTypes::DocumentOrTestTypedef<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassUnionWithTypedef(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passUnionWithTypedef_methodinfo: JSJitInfo = JSJitInfo {
    call: passUnionWithTypedef as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passUnionWithTypedef2<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnionWithTypedef2\".");
            return false;
        }
        let arg0: UnionTypes::LongSequenceOrTestTypedef<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassUnionWithTypedef2(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passUnionWithTypedef2_methodinfo: JSJitInfo = JSJitInfo {
    call: passUnionWithTypedef2 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passAny<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passAny\".");
            return false;
        }
        let arg0: HandleValue = args.get(0);
        let result: () = this.PassAny(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passAny_methodinfo: JSJitInfo = JSJitInfo {
    call: passAny as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passObject<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passObject\".");
            return false;
        }
        let arg0: *mut JSObject = if args.get(0).get().is_object() {
            args.get(0).get().to_object()
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.PassObject(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passObject_methodinfo: JSJitInfo = JSJitInfo {
    call: passObject as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passCallbackFunction<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passCallbackFunction\".");
            return false;
        }
        let arg0: Rc<Function> = if args.get(0).get().is_object() {
            if IsCallable(args.get(0).get().to_object()) {
                Function::new(cx, args.get(0).get().to_object())
            } else {
                throw_type_error(cx, "Value is not callable.");
                return false;

            }
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.PassCallbackFunction(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passCallbackFunction_methodinfo: JSJitInfo = JSJitInfo {
    call: passCallbackFunction as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passCallbackInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passCallbackInterface\".");
            return false;
        }
        let arg0: Rc<dom::bindings::codegen::Bindings::EventListenerBinding::EventListener<TH>> = dom::bindings::codegen::Bindings::EventListenerBinding::EventListener::new(cx, args.get(0).get().to_object());
        let result: () = this.PassCallbackInterface(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passCallbackInterface_methodinfo: JSJitInfo = JSJitInfo {
    call: passCallbackInterface as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passSequence<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passSequence\".");
            return false;
        }
        let arg0: Vec<i32> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassSequence(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passSequence_methodinfo: JSJitInfo = JSJitInfo {
    call: passSequence as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passAnySequence<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passAnySequence\".");
            return false;
        }
        let arg0: Vec<JSVal> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        auto_root!(in(cx) let arg0 = arg0);
        let result: () = this.PassAnySequence(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passAnySequence_methodinfo: JSJitInfo = JSJitInfo {
    call: passAnySequence as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn anySequencePassthrough<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.anySequencePassthrough\".");
            return false;
        }
        let arg0: Vec<JSVal> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        auto_root!(in(cx) let arg0 = arg0);
        let result: Vec<JSVal> = this.AnySequencePassthrough(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const anySequencePassthrough_methodinfo: JSJitInfo = JSJitInfo {
    call: anySequencePassthrough as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passObjectSequence<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passObjectSequence\".");
            return false;
        }
        let arg0: Vec<*mut JSObject> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        auto_root!(in(cx) let arg0 = arg0);
        let result: () = this.PassObjectSequence(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passObjectSequence_methodinfo: JSJitInfo = JSJitInfo {
    call: passObjectSequence as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passStringSequence<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passStringSequence\".");
            return false;
        }
        let arg0: Vec<DOMString> = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassStringSequence(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passStringSequence_methodinfo: JSJitInfo = JSJitInfo {
    call: passStringSequence as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passInterfaceSequence<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passInterfaceSequence\".");
            return false;
        }
        let arg0: Vec<DomRoot<Blob<TH>>> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassInterfaceSequence(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passInterfaceSequence_methodinfo: JSJitInfo = JSJitInfo {
    call: passInterfaceSequence as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOverloaded<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        let argcount = cmp::min(argc, 1);
        match argcount {
            1 => {
                if args.get(0).get().is_object() {
                    loop {
                    let arg0: typedarray::ArrayBuffer = match typedarray::ArrayBuffer::from(args.get(0).get().to_object()) {
                        Ok(val) => val,
                        Err(()) => {
                            break;
                        }
                    }
                    ;
                    auto_root!(in(cx) let arg0 = arg0);
                    let result: () = this.PassOverloaded(arg0);

                    (result).to_jsval(cx, args.rval());
                    return true;
                    }
                }
                let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
                    Ok(ConversionResult::Success(strval)) => strval,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                let result: () = this.PassOverloaded_(arg0);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            _ => {
                throw_type_error(cx, "Not enough arguments to \"TestBinding.passOverloaded\".");
                return false;
            }
        }
    }), false);
}


const passOverloaded_methodinfo: JSJitInfo = JSJitInfo {
    call: passOverloaded as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passNullableBoolean<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableBoolean\".");
            return false;
        }
        let arg0: Option<bool> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassNullableBoolean(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passNullableBoolean_methodinfo: JSJitInfo = JSJitInfo {
    call: passNullableBoolean as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passNullableByte<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableByte\".");
            return false;
        }
        let arg0: Option<i8> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassNullableByte(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passNullableByte_methodinfo: JSJitInfo = JSJitInfo {
    call: passNullableByte as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passNullableOctet<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableOctet\".");
            return false;
        }
        let arg0: Option<u8> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassNullableOctet(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passNullableOctet_methodinfo: JSJitInfo = JSJitInfo {
    call: passNullableOctet as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passNullableShort<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableShort\".");
            return false;
        }
        let arg0: Option<i16> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassNullableShort(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passNullableShort_methodinfo: JSJitInfo = JSJitInfo {
    call: passNullableShort as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passNullableUnsignedShort<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableUnsignedShort\".");
            return false;
        }
        let arg0: Option<u16> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassNullableUnsignedShort(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passNullableUnsignedShort_methodinfo: JSJitInfo = JSJitInfo {
    call: passNullableUnsignedShort as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passNullableLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableLong\".");
            return false;
        }
        let arg0: Option<i32> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassNullableLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passNullableLong_methodinfo: JSJitInfo = JSJitInfo {
    call: passNullableLong as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passNullableUnsignedLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableUnsignedLong\".");
            return false;
        }
        let arg0: Option<u32> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassNullableUnsignedLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passNullableUnsignedLong_methodinfo: JSJitInfo = JSJitInfo {
    call: passNullableUnsignedLong as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passNullableLongLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableLongLong\".");
            return false;
        }
        let arg0: Option<i64> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassNullableLongLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passNullableLongLong_methodinfo: JSJitInfo = JSJitInfo {
    call: passNullableLongLong as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passNullableUnsignedLongLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableUnsignedLongLong\".");
            return false;
        }
        let arg0: Option<u64> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassNullableUnsignedLongLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passNullableUnsignedLongLong_methodinfo: JSJitInfo = JSJitInfo {
    call: passNullableUnsignedLongLong as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passNullableUnrestrictedFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableUnrestrictedFloat\".");
            return false;
        }
        let arg0: Option<f32> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassNullableUnrestrictedFloat(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passNullableUnrestrictedFloat_methodinfo: JSJitInfo = JSJitInfo {
    call: passNullableUnrestrictedFloat as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passNullableFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableFloat\".");
            return false;
        }
        let arg0: Option<Finite<f32>> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassNullableFloat(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passNullableFloat_methodinfo: JSJitInfo = JSJitInfo {
    call: passNullableFloat as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passNullableUnrestrictedDouble<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableUnrestrictedDouble\".");
            return false;
        }
        let arg0: Option<f64> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassNullableUnrestrictedDouble(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passNullableUnrestrictedDouble_methodinfo: JSJitInfo = JSJitInfo {
    call: passNullableUnrestrictedDouble as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passNullableDouble<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableDouble\".");
            return false;
        }
        let arg0: Option<Finite<f64>> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PassNullableDouble(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passNullableDouble_methodinfo: JSJitInfo = JSJitInfo {
    call: passNullableDouble as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passNullableString<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableString\".");
            return false;
        }
        let arg0: Option<DOMString> = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassNullableString(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passNullableString_methodinfo: JSJitInfo = JSJitInfo {
    call: passNullableString as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passNullableUsvstring<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableUsvstring\".");
            return false;
        }
        let arg0: Option<USVString> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassNullableUsvstring(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passNullableUsvstring_methodinfo: JSJitInfo = JSJitInfo {
    call: passNullableUsvstring as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passNullableByteString<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableByteString\".");
            return false;
        }
        let arg0: Option<ByteString> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassNullableByteString(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passNullableByteString_methodinfo: JSJitInfo = JSJitInfo {
    call: passNullableByteString as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passNullableInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableInterface\".");
            return false;
        }
        let arg0: Option<DomRoot<Blob<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface Blob.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.PassNullableInterface(arg0.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passNullableInterface_methodinfo: JSJitInfo = JSJitInfo {
    call: passNullableInterface as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passNullableObject<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableObject\".");
            return false;
        }
        let arg0: *mut JSObject = if args.get(0).get().is_object() {
            args.get(0).get().to_object()
        } else if args.get(0).get().is_null_or_undefined() {
            ptr::null_mut()
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.PassNullableObject(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passNullableObject_methodinfo: JSJitInfo = JSJitInfo {
    call: passNullableObject as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passNullableTypedArray<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableTypedArray\".");
            return false;
        }
        let arg0: Option<typedarray::Int8Array> = if args.get(0).get().is_object() {
            Some(match typedarray::Int8Array::from(args.get(0).get().to_object()) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value is not a typed array.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        auto_root!(in(cx) let arg0 = arg0);
        let result: () = this.PassNullableTypedArray(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passNullableTypedArray_methodinfo: JSJitInfo = JSJitInfo {
    call: passNullableTypedArray as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passNullableUnion<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableUnion\".");
            return false;
        }
        let arg0: Option<UnionTypes::HTMLElementOrLong<TH>> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassNullableUnion(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passNullableUnion_methodinfo: JSJitInfo = JSJitInfo {
    call: passNullableUnion as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passNullableUnion2<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableUnion2\".");
            return false;
        }
        let arg0: Option<UnionTypes::EventOrString<TH>> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassNullableUnion2(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passNullableUnion2_methodinfo: JSJitInfo = JSJitInfo {
    call: passNullableUnion2 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passNullableUnion3<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableUnion3\".");
            return false;
        }
        let arg0: Option<UnionTypes::StringOrLongSequence> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassNullableUnion3(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passNullableUnion3_methodinfo: JSJitInfo = JSJitInfo {
    call: passNullableUnion3 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passNullableUnion4<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableUnion4\".");
            return false;
        }
        let arg0: Option<UnionTypes::LongSequenceOrBoolean> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassNullableUnion4(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passNullableUnion4_methodinfo: JSJitInfo = JSJitInfo {
    call: passNullableUnion4 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passNullableUnion5<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableUnion5\".");
            return false;
        }
        let arg0: Option<UnionTypes::UnsignedLongOrBoolean> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassNullableUnion5(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passNullableUnion5_methodinfo: JSJitInfo = JSJitInfo {
    call: passNullableUnion5 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passNullableUnion6<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableUnion6\".");
            return false;
        }
        let arg0: Option<UnionTypes::ByteStringOrLong> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassNullableUnion6(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passNullableUnion6_methodinfo: JSJitInfo = JSJitInfo {
    call: passNullableUnion6 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passNullableCallbackFunction<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableCallbackFunction\".");
            return false;
        }
        let arg0: Option<Rc<Function>> = if args.get(0).get().is_object() {
            if IsCallable(args.get(0).get().to_object()) {
                Some(Function::new(cx, args.get(0).get().to_object()))
            } else {
                throw_type_error(cx, "Value is not callable.");
                return false;

            }
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.PassNullableCallbackFunction(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passNullableCallbackFunction_methodinfo: JSJitInfo = JSJitInfo {
    call: passNullableCallbackFunction as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passNullableCallbackInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableCallbackInterface\".");
            return false;
        }
        let arg0: Option<Rc<dom::bindings::codegen::Bindings::EventListenerBinding::EventListener<TH>>> = if args.get(0).get().is_object() {
            Some(dom::bindings::codegen::Bindings::EventListenerBinding::EventListener::new(cx, args.get(0).get().to_object()))
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.PassNullableCallbackInterface(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passNullableCallbackInterface_methodinfo: JSJitInfo = JSJitInfo {
    call: passNullableCallbackInterface as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passNullableSequence<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableSequence\".");
            return false;
        }
        let arg0: Option<Vec<i32> > = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassNullableSequence(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passNullableSequence_methodinfo: JSJitInfo = JSJitInfo {
    call: passNullableSequence as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalBoolean<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<bool> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalBoolean(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalBoolean_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalBoolean as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalByte<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<i8> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalByte(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalByte_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalByte as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalOctet<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<u8> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalOctet(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalOctet_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalOctet as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalShort<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<i16> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalShort(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalShort_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalShort as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalUnsignedShort<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<u16> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalUnsignedShort(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalUnsignedShort_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalUnsignedShort as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<i32> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalLong_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalLong as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalUnsignedLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<u32> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalUnsignedLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalUnsignedLong_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalUnsignedLong as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalLongLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<i64> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalLongLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalLongLong_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalLongLong as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalUnsignedLongLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<u64> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalUnsignedLongLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalUnsignedLongLong_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalUnsignedLongLong as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalUnrestrictedFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<f32> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalUnrestrictedFloat(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalUnrestrictedFloat_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalUnrestrictedFloat as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Finite<f32>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalFloat(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalFloat_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalFloat as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalUnrestrictedDouble<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<f64> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalUnrestrictedDouble(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalUnrestrictedDouble_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalUnrestrictedDouble as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalDouble<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Finite<f64>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalDouble(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalDouble_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalDouble as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalString<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<DOMString> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalString(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalString_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalString as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalUsvstring<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<USVString> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalUsvstring(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalUsvstring_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalUsvstring as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalByteString<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<ByteString> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalByteString(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalByteString_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalByteString as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalEnum<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<TestEnum> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match find_enum_value(cx, args.get(0), TestEnumValues::pairs) {
                Err(_) => { return false;
             },
                Ok((None, search)) => { throw_type_error(cx, &format!("'{}' is not a valid enum value for enumeration 'TestEnum'.", search)); return false;
             },
                Ok((Some(&value), _)) => value,
            })
        };
        let result: () = this.PassOptionalEnum(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalEnum_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalEnum as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<DomRoot<Blob<TH>>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(if args.get(0).get().is_object() {
                match root_from_handlevalue(args.get(0)) {
                    Ok(val) => val,
                    Err(()) => {
                        throw_type_error(cx, "value does not implement interface Blob.");
                        return false;

                    }
                }

            } else {
                throw_type_error(cx, "Value is not an object.");
                return false;

            })
        };
        let result: () = this.PassOptionalInterface(arg0.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalInterface_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalInterface as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalUnion<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<UnionTypes::HTMLElementOrLong<TH>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalUnion(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalUnion_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalUnion as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalUnion2<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<UnionTypes::EventOrString<TH>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalUnion2(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalUnion2_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalUnion2 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalUnion3<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<UnionTypes::StringOrLongSequence> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalUnion3(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalUnion3_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalUnion3 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalUnion4<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<UnionTypes::LongSequenceOrBoolean> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalUnion4(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalUnion4_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalUnion4 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalUnion5<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<UnionTypes::UnsignedLongOrBoolean> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalUnion5(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalUnion5_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalUnion5 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalUnion6<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<UnionTypes::ByteStringOrLong> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalUnion6(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalUnion6_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalUnion6 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalAny<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: HandleValue = if args.get(0).is_undefined() {
            HandleValue::undefined()
        } else {
            args.get(0)
        };
        let result: () = this.PassOptionalAny(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalAny_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalAny as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalObject<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<*mut JSObject> = if args.get(0).is_undefined() {
            None
        } else {
            Some(if args.get(0).get().is_object() {
                args.get(0).get().to_object()
            } else {
                throw_type_error(cx, "Value is not an object.");
                return false;

            })
        };
        let result: () = this.PassOptionalObject(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalObject_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalObject as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalCallbackFunction<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Rc<Function>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(if args.get(0).get().is_object() {
                if IsCallable(args.get(0).get().to_object()) {
                    Function::new(cx, args.get(0).get().to_object())
                } else {
                    throw_type_error(cx, "Value is not callable.");
                    return false;

                }
            } else {
                throw_type_error(cx, "Value is not an object.");
                return false;

            })
        };
        let result: () = this.PassOptionalCallbackFunction(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalCallbackFunction_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalCallbackFunction as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalCallbackInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Rc<dom::bindings::codegen::Bindings::EventListenerBinding::EventListener<TH>>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(dom::bindings::codegen::Bindings::EventListenerBinding::EventListener::new(cx, args.get(0).get().to_object()))
        };
        let result: () = this.PassOptionalCallbackInterface(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalCallbackInterface_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalCallbackInterface as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalSequence<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Vec<i32>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalSequence(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalSequence_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalSequence as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableBoolean<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<bool>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalNullableBoolean(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableBoolean_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableBoolean as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableByte<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<i8>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalNullableByte(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableByte_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableByte as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableOctet<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<u8>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalNullableOctet(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableOctet_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableOctet as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableShort<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<i16>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalNullableShort(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableShort_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableShort as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableUnsignedShort<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<u16>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalNullableUnsignedShort(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableUnsignedShort_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableUnsignedShort as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<i32>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalNullableLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableLong_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableLong as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableUnsignedLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<u32>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalNullableUnsignedLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableUnsignedLong_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableUnsignedLong as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableLongLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<i64>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalNullableLongLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableLongLong_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableLongLong as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableUnsignedLongLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<u64>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalNullableUnsignedLongLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableUnsignedLongLong_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableUnsignedLongLong as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableUnrestrictedFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<f32>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalNullableUnrestrictedFloat(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableUnrestrictedFloat_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableUnrestrictedFloat as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<Finite<f32>>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalNullableFloat(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableFloat_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableFloat as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableUnrestrictedDouble<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<f64>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalNullableUnrestrictedDouble(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableUnrestrictedDouble_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableUnrestrictedDouble as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableDouble<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<Finite<f64>>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            })
        };
        let result: () = this.PassOptionalNullableDouble(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableDouble_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableDouble as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableString<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<DOMString>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalNullableString(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableString_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableString as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableUsvstring<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<USVString>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalNullableUsvstring(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableUsvstring_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableUsvstring as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableByteString<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<ByteString>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalNullableByteString(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableByteString_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableByteString as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<DomRoot<Blob<TH>>>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(if args.get(0).get().is_object() {
                Some(match root_from_handlevalue(args.get(0)) {
                    Ok(val) => val,
                    Err(()) => {
                        throw_type_error(cx, "value does not implement interface Blob.");
                        return false;

                    }
                }
                )
            } else if args.get(0).get().is_null_or_undefined() {
                None
            } else {
                throw_type_error(cx, "Value is not an object.");
                return false;

            })
        };
        let result: () = this.PassOptionalNullableInterface(arg0.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableInterface_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableInterface as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableObject<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<*mut JSObject> = if args.get(0).is_undefined() {
            None
        } else {
            Some(if args.get(0).get().is_object() {
                args.get(0).get().to_object()
            } else if args.get(0).get().is_null_or_undefined() {
                ptr::null_mut()
            } else {
                throw_type_error(cx, "Value is not an object.");
                return false;

            })
        };
        let result: () = this.PassOptionalNullableObject(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableObject_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableObject as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableUnion<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<UnionTypes::HTMLElementOrLong<TH>>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalNullableUnion(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableUnion_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableUnion as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableUnion2<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<UnionTypes::EventOrString<TH>>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalNullableUnion2(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableUnion2_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableUnion2 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableUnion3<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<UnionTypes::StringOrLongSequence>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalNullableUnion3(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableUnion3_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableUnion3 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableUnion4<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<UnionTypes::LongSequenceOrBoolean>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalNullableUnion4(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableUnion4_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableUnion4 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableUnion5<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<UnionTypes::UnsignedLongOrBoolean>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalNullableUnion5(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableUnion5_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableUnion5 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableUnion6<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<UnionTypes::ByteStringOrLong>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalNullableUnion6(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableUnion6_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableUnion6 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableCallbackFunction<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<Rc<Function>>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(if args.get(0).get().is_object() {
                if IsCallable(args.get(0).get().to_object()) {
                    Some(Function::new(cx, args.get(0).get().to_object()))
                } else {
                    throw_type_error(cx, "Value is not callable.");
                    return false;

                }
            } else if args.get(0).get().is_null_or_undefined() {
                None
            } else {
                throw_type_error(cx, "Value is not an object.");
                return false;

            })
        };
        let result: () = this.PassOptionalNullableCallbackFunction(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableCallbackFunction_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableCallbackFunction as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableCallbackInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<Rc<dom::bindings::codegen::Bindings::EventListenerBinding::EventListener<TH>>>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(if args.get(0).get().is_object() {
                Some(dom::bindings::codegen::Bindings::EventListenerBinding::EventListener::new(cx, args.get(0).get().to_object()))
            } else if args.get(0).get().is_null_or_undefined() {
                None
            } else {
                throw_type_error(cx, "Value is not an object.");
                return false;

            })
        };
        let result: () = this.PassOptionalNullableCallbackInterface(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableCallbackInterface_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableCallbackInterface as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableSequence<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<Vec<i32> >> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalNullableSequence(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableSequence_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableSequence as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalBooleanWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: bool = if args.get(0).is_undefined() {
            false
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalBooleanWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalBooleanWithDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalBooleanWithDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalByteWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: i8 = if args.get(0).is_undefined() {
            0
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalByteWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalByteWithDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalByteWithDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalOctetWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: u8 = if args.get(0).is_undefined() {
            19
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalOctetWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalOctetWithDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalOctetWithDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalShortWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: i16 = if args.get(0).is_undefined() {
            5
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalShortWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalShortWithDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalShortWithDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalUnsignedShortWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: u16 = if args.get(0).is_undefined() {
            2
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalUnsignedShortWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalUnsignedShortWithDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalUnsignedShortWithDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalLongWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: i32 = if args.get(0).is_undefined() {
            7
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalLongWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalLongWithDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalLongWithDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalUnsignedLongWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: u32 = if args.get(0).is_undefined() {
            6
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalUnsignedLongWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalUnsignedLongWithDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalUnsignedLongWithDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalLongLongWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: i64 = if args.get(0).is_undefined() {
            -12
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalLongLongWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalLongLongWithDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalLongLongWithDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalUnsignedLongLongWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: u64 = if args.get(0).is_undefined() {
            17
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalUnsignedLongLongWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalUnsignedLongLongWithDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalUnsignedLongLongWithDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalBytestringWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: ByteString = if args.get(0).is_undefined() {
            ByteString::new(b"x".to_vec())
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        let result: () = this.PassOptionalBytestringWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalBytestringWithDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalBytestringWithDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalStringWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: DOMString = if args.get(0).is_undefined() {
            DOMString::from("x")
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        let result: () = this.PassOptionalStringWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalStringWithDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalStringWithDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalUsvstringWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: USVString = if args.get(0).is_undefined() {
            USVString("x".to_owned())
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        let result: () = this.PassOptionalUsvstringWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalUsvstringWithDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalUsvstringWithDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalEnumWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: TestEnum = if args.get(0).is_undefined() {
            TestEnum::Foo
        } else {
            match find_enum_value(cx, args.get(0), TestEnumValues::pairs) {
                Err(_) => { return false;
             },
                Ok((None, search)) => { throw_type_error(cx, &format!("'{}' is not a valid enum value for enumeration 'TestEnum'.", search)); return false;
             },
                Ok((Some(&value), _)) => value,
            }
        };
        let result: () = this.PassOptionalEnumWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalEnumWithDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalEnumWithDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableBooleanWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<bool> = if args.get(0).is_undefined() {
            None
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableBooleanWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableBooleanWithDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableBooleanWithDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableByteWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<i8> = if args.get(0).is_undefined() {
            None
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableByteWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableByteWithDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableByteWithDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableOctetWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<u8> = if args.get(0).is_undefined() {
            None
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableOctetWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableOctetWithDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableOctetWithDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableShortWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<i16> = if args.get(0).is_undefined() {
            None
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableShortWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableShortWithDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableShortWithDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableUnsignedShortWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<u16> = if args.get(0).is_undefined() {
            None
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableUnsignedShortWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableUnsignedShortWithDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableUnsignedShortWithDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableLongWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<i32> = if args.get(0).is_undefined() {
            None
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableLongWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableLongWithDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableLongWithDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableUnsignedLongWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<u32> = if args.get(0).is_undefined() {
            None
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableUnsignedLongWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableUnsignedLongWithDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableUnsignedLongWithDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableLongLongWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<i64> = if args.get(0).is_undefined() {
            None
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableLongLongWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableLongLongWithDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableLongLongWithDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableUnsignedLongLongWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<u64> = if args.get(0).is_undefined() {
            None
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableUnsignedLongLongWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableUnsignedLongLongWithDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableUnsignedLongLongWithDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableStringWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<DOMString> = if args.get(0).is_undefined() {
            None
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        let result: () = this.PassOptionalNullableStringWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableStringWithDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableStringWithDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableUsvstringWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<USVString> = if args.get(0).is_undefined() {
            None
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        let result: () = this.PassOptionalNullableUsvstringWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableUsvstringWithDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableUsvstringWithDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableByteStringWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<ByteString> = if args.get(0).is_undefined() {
            None
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        let result: () = this.PassOptionalNullableByteStringWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableByteStringWithDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableByteStringWithDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableInterfaceWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<DomRoot<Blob<TH>>> = if args.get(0).is_undefined() {
            None
        } else {
            if args.get(0).get().is_object() {
                Some(match root_from_handlevalue(args.get(0)) {
                    Ok(val) => val,
                    Err(()) => {
                        throw_type_error(cx, "value does not implement interface Blob.");
                        return false;

                    }
                }
                )
            } else if args.get(0).get().is_null_or_undefined() {
                None
            } else {
                throw_type_error(cx, "Value is not an object.");
                return false;

            }
        };
        let result: () = this.PassOptionalNullableInterfaceWithDefault(arg0.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableInterfaceWithDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableInterfaceWithDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableObjectWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: *mut JSObject = if args.get(0).is_undefined() {
            ptr::null_mut()
        } else {
            if args.get(0).get().is_object() {
                args.get(0).get().to_object()
            } else if args.get(0).get().is_null_or_undefined() {
                ptr::null_mut()
            } else {
                throw_type_error(cx, "Value is not an object.");
                return false;

            }
        };
        let result: () = this.PassOptionalNullableObjectWithDefault(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableObjectWithDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableObjectWithDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableUnionWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<UnionTypes::HTMLElementOrLong<TH>> = if args.get(0).is_undefined() {
            None
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        let result: () = this.PassOptionalNullableUnionWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableUnionWithDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableUnionWithDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableUnion2WithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<UnionTypes::EventOrString<TH>> = if args.get(0).is_undefined() {
            None
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        let result: () = this.PassOptionalNullableUnion2WithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableUnion2WithDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableUnion2WithDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableCallbackInterfaceWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Rc<dom::bindings::codegen::Bindings::EventListenerBinding::EventListener<TH>>> = if args.get(0).is_undefined() {
            None
        } else {
            if args.get(0).get().is_object() {
                Some(dom::bindings::codegen::Bindings::EventListenerBinding::EventListener::new(cx, args.get(0).get().to_object()))
            } else if args.get(0).get().is_null_or_undefined() {
                None
            } else {
                throw_type_error(cx, "Value is not an object.");
                return false;

            }
        };
        let result: () = this.PassOptionalNullableCallbackInterfaceWithDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableCallbackInterfaceWithDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableCallbackInterfaceWithDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalAnyWithDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: HandleValue = if args.get(0).is_undefined() {
            HandleValue::null()
        } else {
            args.get(0)
        };
        let result: () = this.PassOptionalAnyWithDefault(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalAnyWithDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalAnyWithDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableBooleanWithNonNullDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<bool> = if args.get(0).is_undefined() {
            Some(false)
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableBooleanWithNonNullDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableBooleanWithNonNullDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableBooleanWithNonNullDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableByteWithNonNullDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<i8> = if args.get(0).is_undefined() {
            Some(7)
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableByteWithNonNullDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableByteWithNonNullDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableByteWithNonNullDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableOctetWithNonNullDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<u8> = if args.get(0).is_undefined() {
            Some(7)
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableOctetWithNonNullDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableOctetWithNonNullDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableOctetWithNonNullDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableShortWithNonNullDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<i16> = if args.get(0).is_undefined() {
            Some(7)
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableShortWithNonNullDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableShortWithNonNullDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableShortWithNonNullDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableUnsignedShortWithNonNullDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<u16> = if args.get(0).is_undefined() {
            Some(7)
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableUnsignedShortWithNonNullDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableUnsignedShortWithNonNullDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableUnsignedShortWithNonNullDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableLongWithNonNullDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<i32> = if args.get(0).is_undefined() {
            Some(7)
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableLongWithNonNullDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableLongWithNonNullDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableLongWithNonNullDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableUnsignedLongWithNonNullDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<u32> = if args.get(0).is_undefined() {
            Some(7)
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableUnsignedLongWithNonNullDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableUnsignedLongWithNonNullDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableUnsignedLongWithNonNullDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableLongLongWithNonNullDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<i64> = if args.get(0).is_undefined() {
            Some(7)
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableLongLongWithNonNullDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableLongLongWithNonNullDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableLongLongWithNonNullDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableUnsignedLongLongWithNonNullDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<u64> = if args.get(0).is_undefined() {
            Some(7)
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.PassOptionalNullableUnsignedLongLongWithNonNullDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableUnsignedLongLongWithNonNullDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableUnsignedLongLongWithNonNullDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableStringWithNonNullDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<DOMString> = if args.get(0).is_undefined() {
            Some(DOMString::from("x"))
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        let result: () = this.PassOptionalNullableStringWithNonNullDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableStringWithNonNullDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableStringWithNonNullDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableUsvstringWithNonNullDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<USVString> = if args.get(0).is_undefined() {
            Some(USVString("x".to_owned()))
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        let result: () = this.PassOptionalNullableUsvstringWithNonNullDefault(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableUsvstringWithNonNullDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableUsvstringWithNonNullDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalOverloaded<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        let argcount = cmp::min(argc, 3);
        match argcount {
            1 => {
                if args.get(0).get().is_object() {
                    loop {
                    let arg0: DomRoot<TestBinding<TH>> = match root_from_handlevalue(args.get(0)) {
                        Ok(val) => val,
                        Err(()) => {
                            break;
                        }
                    }
                    ;
                    let arg1: u32 = if args.get(1).is_undefined() {
                        0
                    } else {
                        match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return false;

                            }
                            _ => { return false;
                         }
                        }
                    };
                    let arg2: u32 = if args.get(2).is_undefined() {
                        0
                    } else {
                        match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return false;

                            }
                            _ => { return false;
                         }
                        }
                    };
                    let result: DomRoot<TestBinding<TH>> = this.PassOptionalOverloaded(&arg0, arg1, arg2);

                    (result).to_jsval(cx, args.rval());
                    return true;
                    }
                    loop {
                    let arg0: DomRoot<Blob<TH>> = match root_from_handlevalue(args.get(0)) {
                        Ok(val) => val,
                        Err(()) => {
                            break;
                        }
                    }
                    ;
                    let arg1: u32 = if args.get(1).is_undefined() {
                        0
                    } else {
                        match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return false;

                            }
                            _ => { return false;
                         }
                        }
                    };
                    let result: () = this.PassOptionalOverloaded_(&arg0, arg1);

                    (result).to_jsval(cx, args.rval());
                    return true;
                    }
                }
                throw_internal_error(cx, "Could not convert JavaScript argument");
                return false;
            }
            2 => {
                if args.get(0).get().is_object() {
                    loop {
                    let arg0: DomRoot<TestBinding<TH>> = match root_from_handlevalue(args.get(0)) {
                        Ok(val) => val,
                        Err(()) => {
                            break;
                        }
                    }
                    ;
                    let arg1: u32 = if args.get(1).is_undefined() {
                        0
                    } else {
                        match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return false;

                            }
                            _ => { return false;
                         }
                        }
                    };
                    let arg2: u32 = if args.get(2).is_undefined() {
                        0
                    } else {
                        match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return false;

                            }
                            _ => { return false;
                         }
                        }
                    };
                    let result: DomRoot<TestBinding<TH>> = this.PassOptionalOverloaded(&arg0, arg1, arg2);

                    (result).to_jsval(cx, args.rval());
                    return true;
                    }
                    loop {
                    let arg0: DomRoot<Blob<TH>> = match root_from_handlevalue(args.get(0)) {
                        Ok(val) => val,
                        Err(()) => {
                            break;
                        }
                    }
                    ;
                    let arg1: u32 = if args.get(1).is_undefined() {
                        0
                    } else {
                        match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return false;

                            }
                            _ => { return false;
                         }
                        }
                    };
                    let result: () = this.PassOptionalOverloaded_(&arg0, arg1);

                    (result).to_jsval(cx, args.rval());
                    return true;
                    }
                }
                throw_internal_error(cx, "Could not convert JavaScript argument");
                return false;
            }
            3 => {
                let arg0: DomRoot<TestBinding<TH>> = if args.get(0).get().is_object() {
                    match root_from_handlevalue(args.get(0)) {
                        Ok(val) => val,
                        Err(()) => {
                            throw_type_error(cx, "value does not implement interface TestBinding.");
                            return false;

                        }
                    }

                } else {
                    throw_type_error(cx, "Value is not an object.");
                    return false;

                };
                let arg1: u32 = if args.get(1).is_undefined() {
                    0
                } else {
                    match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                        Ok(ConversionResult::Success(v)) => v,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     }
                    }
                };
                let arg2: u32 = if args.get(2).is_undefined() {
                    0
                } else {
                    match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
                        Ok(ConversionResult::Success(v)) => v,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     }
                    }
                };
                let result: DomRoot<TestBinding<TH>> = this.PassOptionalOverloaded(&arg0, arg1, arg2);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            _ => {
                throw_type_error(cx, "Not enough arguments to \"TestBinding.passOptionalOverloaded\".");
                return false;
            }
        }
    }), false);
}


const passOptionalOverloaded_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalOverloaded as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passVariadicBoolean<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: bool = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicBoolean(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passVariadicBoolean_methodinfo: JSJitInfo = JSJitInfo {
    call: passVariadicBoolean as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passVariadicBooleanAndDefault<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: bool = if args.get(0).is_undefined() {
            true
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let mut arg1 = vec![];
        if argc > 1 {
            arg1.reserve(argc as usize - 1);
            for variadicArg in 1..argc {
                let slot: bool = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                arg1.push(slot);
            }
        }
        let result: () = this.PassVariadicBooleanAndDefault(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passVariadicBooleanAndDefault_methodinfo: JSJitInfo = JSJitInfo {
    call: passVariadicBooleanAndDefault as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passVariadicByte<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: i8 = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicByte(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passVariadicByte_methodinfo: JSJitInfo = JSJitInfo {
    call: passVariadicByte as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passVariadicOctet<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: u8 = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicOctet(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passVariadicOctet_methodinfo: JSJitInfo = JSJitInfo {
    call: passVariadicOctet as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passVariadicShort<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: i16 = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicShort(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passVariadicShort_methodinfo: JSJitInfo = JSJitInfo {
    call: passVariadicShort as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passVariadicUnsignedShort<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: u16 = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicUnsignedShort(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passVariadicUnsignedShort_methodinfo: JSJitInfo = JSJitInfo {
    call: passVariadicUnsignedShort as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passVariadicLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: i32 = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passVariadicLong_methodinfo: JSJitInfo = JSJitInfo {
    call: passVariadicLong as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passVariadicUnsignedLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: u32 = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicUnsignedLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passVariadicUnsignedLong_methodinfo: JSJitInfo = JSJitInfo {
    call: passVariadicUnsignedLong as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passVariadicLongLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: i64 = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicLongLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passVariadicLongLong_methodinfo: JSJitInfo = JSJitInfo {
    call: passVariadicLongLong as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passVariadicUnsignedLongLong<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: u64 = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicUnsignedLongLong(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passVariadicUnsignedLongLong_methodinfo: JSJitInfo = JSJitInfo {
    call: passVariadicUnsignedLongLong as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passVariadicUnrestrictedFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: f32 = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicUnrestrictedFloat(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passVariadicUnrestrictedFloat_methodinfo: JSJitInfo = JSJitInfo {
    call: passVariadicUnrestrictedFloat as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passVariadicFloat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: Finite<f32> = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicFloat(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passVariadicFloat_methodinfo: JSJitInfo = JSJitInfo {
    call: passVariadicFloat as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passVariadicUnrestrictedDouble<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: f64 = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicUnrestrictedDouble(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passVariadicUnrestrictedDouble_methodinfo: JSJitInfo = JSJitInfo {
    call: passVariadicUnrestrictedDouble as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passVariadicDouble<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: Finite<f64> = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicDouble(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passVariadicDouble_methodinfo: JSJitInfo = JSJitInfo {
    call: passVariadicDouble as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passVariadicString<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), StringificationBehavior::Default) {
                    Ok(ConversionResult::Success(strval)) => strval,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicString(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passVariadicString_methodinfo: JSJitInfo = JSJitInfo {
    call: passVariadicString as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passVariadicUsvstring<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: USVString = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(strval)) => strval,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicUsvstring(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passVariadicUsvstring_methodinfo: JSJitInfo = JSJitInfo {
    call: passVariadicUsvstring as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passVariadicByteString<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: ByteString = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(strval)) => strval,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicByteString(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passVariadicByteString_methodinfo: JSJitInfo = JSJitInfo {
    call: passVariadicByteString as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passVariadicEnum<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: TestEnum = match find_enum_value(cx, args.get(variadicArg), TestEnumValues::pairs) {
                    Err(_) => { return false;
                 },
                    Ok((None, search)) => { throw_type_error(cx, &format!("'{}' is not a valid enum value for enumeration 'TestEnum'.", search)); return false;
                 },
                    Ok((Some(&value), _)) => value,
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicEnum(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passVariadicEnum_methodinfo: JSJitInfo = JSJitInfo {
    call: passVariadicEnum as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passVariadicInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        rooted_vec!(let mut arg0);
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: *const Blob<TH> = if args.get(variadicArg).get().is_object() {
                    match native_from_handlevalue(args.get(variadicArg)) {
                        Ok(val) => val,
                        Err(()) => {
                            throw_type_error(cx, "value does not implement interface Blob.");
                            return false;

                        }
                    }

                } else {
                    throw_type_error(cx, "Value is not an object.");
                    return false;

                };
                arg0.push(Dom::from_ref(&*slot));
            }
        }
        let result: () = this.PassVariadicInterface(arg0.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passVariadicInterface_methodinfo: JSJitInfo = JSJitInfo {
    call: passVariadicInterface as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passVariadicUnion<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: UnionTypes::HTMLElementOrLong<TH> = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(value)) => value,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicUnion(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passVariadicUnion_methodinfo: JSJitInfo = JSJitInfo {
    call: passVariadicUnion as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passVariadicUnion2<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: UnionTypes::EventOrString<TH> = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(value)) => value,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicUnion2(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passVariadicUnion2_methodinfo: JSJitInfo = JSJitInfo {
    call: passVariadicUnion2 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passVariadicUnion3<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: UnionTypes::BlobOrString<TH> = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(value)) => value,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicUnion3(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passVariadicUnion3_methodinfo: JSJitInfo = JSJitInfo {
    call: passVariadicUnion3 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passVariadicUnion4<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: UnionTypes::BlobOrBoolean<TH> = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(value)) => value,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicUnion4(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passVariadicUnion4_methodinfo: JSJitInfo = JSJitInfo {
    call: passVariadicUnion4 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passVariadicUnion5<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: UnionTypes::StringOrUnsignedLong = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(value)) => value,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicUnion5(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passVariadicUnion5_methodinfo: JSJitInfo = JSJitInfo {
    call: passVariadicUnion5 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passVariadicUnion6<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: UnionTypes::UnsignedLongOrBoolean = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(value)) => value,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicUnion6(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passVariadicUnion6_methodinfo: JSJitInfo = JSJitInfo {
    call: passVariadicUnion6 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passVariadicUnion7<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: UnionTypes::ByteStringOrLong = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), ()) {
                    Ok(ConversionResult::Success(value)) => value,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicUnion7(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passVariadicUnion7_methodinfo: JSJitInfo = JSJitInfo {
    call: passVariadicUnion7 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passVariadicAny<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: HandleValue = args.get(variadicArg);
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicAny(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passVariadicAny_methodinfo: JSJitInfo = JSJitInfo {
    call: passVariadicAny as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passVariadicObject<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: *mut JSObject = if args.get(variadicArg).get().is_object() {
                    args.get(variadicArg).get().to_object()
                } else {
                    throw_type_error(cx, "Value is not an object.");
                    return false;

                };
                arg0.push(slot);
            }
        }
        let result: () = this.PassVariadicObject(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passVariadicObject_methodinfo: JSJitInfo = JSJitInfo {
    call: passVariadicObject as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passSequenceSequence<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passSequenceSequence\".");
            return false;
        }
        let arg0: Vec<Vec<i32>> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassSequenceSequence(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passSequenceSequence_methodinfo: JSJitInfo = JSJitInfo {
    call: passSequenceSequence as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn returnSequenceSequence<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Vec<Vec<i32>> = this.ReturnSequenceSequence();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const returnSequenceSequence_methodinfo: JSJitInfo = JSJitInfo {
    call: returnSequenceSequence as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passUnionSequenceSequence<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passUnionSequenceSequence\".");
            return false;
        }
        let arg0: UnionTypes::LongOrLongSequenceSequence = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassUnionSequenceSequence(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passUnionSequenceSequence_methodinfo: JSJitInfo = JSJitInfo {
    call: passUnionSequenceSequence as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passMozMap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passMozMap\".");
            return false;
        }
        let arg0: MozMap<i32> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassMozMap(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passMozMap_methodinfo: JSJitInfo = JSJitInfo {
    call: passMozMap as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passNullableMozMap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableMozMap\".");
            return false;
        }
        let arg0: Option<MozMap<i32> > = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassNullableMozMap(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passNullableMozMap_methodinfo: JSJitInfo = JSJitInfo {
    call: passNullableMozMap as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passMozMapOfNullableInts<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passMozMapOfNullableInts\".");
            return false;
        }
        let arg0: MozMap<Option<i32>> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassMozMapOfNullableInts(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passMozMapOfNullableInts_methodinfo: JSJitInfo = JSJitInfo {
    call: passMozMapOfNullableInts as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalMozMapOfNullableInts<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<MozMap<Option<i32>>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalMozMapOfNullableInts(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalMozMapOfNullableInts_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalMozMapOfNullableInts as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableMozMapOfNullableInts<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<MozMap<Option<i32>> >> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalNullableMozMapOfNullableInts(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableMozMapOfNullableInts_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableMozMapOfNullableInts as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passCastableObjectMozMap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passCastableObjectMozMap\".");
            return false;
        }
        let arg0: MozMap<DomRoot<TestBinding<TH>>> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassCastableObjectMozMap(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passCastableObjectMozMap_methodinfo: JSJitInfo = JSJitInfo {
    call: passCastableObjectMozMap as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passNullableCastableObjectMozMap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableCastableObjectMozMap\".");
            return false;
        }
        let arg0: MozMap<Option<DomRoot<TestBinding<TH>>>> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassNullableCastableObjectMozMap(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passNullableCastableObjectMozMap_methodinfo: JSJitInfo = JSJitInfo {
    call: passNullableCastableObjectMozMap as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passCastableObjectNullableMozMap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passCastableObjectNullableMozMap\".");
            return false;
        }
        let arg0: Option<MozMap<DomRoot<TestBinding<TH>>> > = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassCastableObjectNullableMozMap(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passCastableObjectNullableMozMap_methodinfo: JSJitInfo = JSJitInfo {
    call: passCastableObjectNullableMozMap as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passNullableCastableObjectNullableMozMap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passNullableCastableObjectNullableMozMap\".");
            return false;
        }
        let arg0: Option<MozMap<Option<DomRoot<TestBinding<TH>>>> > = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassNullableCastableObjectNullableMozMap(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passNullableCastableObjectNullableMozMap_methodinfo: JSJitInfo = JSJitInfo {
    call: passNullableCastableObjectNullableMozMap as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalMozMap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<MozMap<i32>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalMozMap(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalMozMap_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalMozMap as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableMozMap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<Option<MozMap<i32> >> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalNullableMozMap(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableMozMap_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableMozMap as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalNullableMozMapWithDefaultValue<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<MozMap<i32> > = if args.get(0).is_undefined() {
            None
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        let result: () = this.PassOptionalNullableMozMapWithDefaultValue(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalNullableMozMapWithDefaultValue_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalNullableMozMapWithDefaultValue as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passOptionalObjectMozMap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: Option<MozMap<DomRoot<TestBinding<TH>>>> = if args.get(0).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                Ok(ConversionResult::Success(value)) => value,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: () = this.PassOptionalObjectMozMap(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passOptionalObjectMozMap_methodinfo: JSJitInfo = JSJitInfo {
    call: passOptionalObjectMozMap as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passStringMozMap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passStringMozMap\".");
            return false;
        }
        let arg0: MozMap<DOMString> = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassStringMozMap(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passStringMozMap_methodinfo: JSJitInfo = JSJitInfo {
    call: passStringMozMap as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passByteStringMozMap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passByteStringMozMap\".");
            return false;
        }
        let arg0: MozMap<ByteString> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassByteStringMozMap(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passByteStringMozMap_methodinfo: JSJitInfo = JSJitInfo {
    call: passByteStringMozMap as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passMozMapOfMozMaps<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passMozMapOfMozMaps\".");
            return false;
        }
        let arg0: MozMap<MozMap<i32>> = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassMozMapOfMozMaps(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passMozMapOfMozMaps_methodinfo: JSJitInfo = JSJitInfo {
    call: passMozMapOfMozMaps as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passMozMapUnion<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passMozMapUnion\".");
            return false;
        }
        let arg0: UnionTypes::LongOrStringByteStringRecord = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassMozMapUnion(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passMozMapUnion_methodinfo: JSJitInfo = JSJitInfo {
    call: passMozMapUnion as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passMozMapUnion2<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passMozMapUnion2\".");
            return false;
        }
        let arg0: UnionTypes::TestBindingOrStringByteStringRecord<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassMozMapUnion2(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passMozMapUnion2_methodinfo: JSJitInfo = JSJitInfo {
    call: passMozMapUnion2 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn passMozMapUnion3<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.passMozMapUnion3\".");
            return false;
        }
        let arg0: UnionTypes::TestBindingOrByteStringSequenceSequenceOrStringByteStringRecord<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PassMozMapUnion3(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const passMozMapUnion3_methodinfo: JSJitInfo = JSJitInfo {
    call: passMozMapUnion3 as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveMozMap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: MozMap<i32> = this.ReceiveMozMap();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveMozMap_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveMozMap as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveNullableMozMap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<MozMap<i32>> = this.ReceiveNullableMozMap();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveNullableMozMap_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveNullableMozMap as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveMozMapOfNullableInts<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: MozMap<Option<i32>> = this.ReceiveMozMapOfNullableInts();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveMozMapOfNullableInts_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveMozMapOfNullableInts as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveNullableMozMapOfNullableInts<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<MozMap<Option<i32>>> = this.ReceiveNullableMozMapOfNullableInts();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveNullableMozMapOfNullableInts_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveNullableMozMapOfNullableInts as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveMozMapOfMozMaps<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: MozMap<MozMap<i32>> = this.ReceiveMozMapOfMozMaps();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveMozMapOfMozMaps_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveMozMapOfMozMaps as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn receiveAnyMozMap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: MozMap<JSVal> = this.ReceiveAnyMozMap();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const receiveAnyMozMap_methodinfo: JSJitInfo = JSJitInfo {
    call: receiveAnyMozMap as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_booleanAttributeStatic<TH: TypeHolderTrait>
(cx: *mut JSContext, argc: libc::c_uint, vp: *mut JSVal) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let global = GlobalScope::from_object(JS_CALLEE(cx, vp).to_object());
        let args = CallArgs::from_vp(vp, argc);
        let result: bool = TestBinding::BooleanAttributeStatic(&global);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_booleanAttributeStatic<TH: TypeHolderTrait>
(cx: *mut JSContext, argc: libc::c_uint, vp: *mut JSVal) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let global = GlobalScope::from_object(JS_CALLEE(cx, vp).to_object());
        let args = CallArgs::from_vp(vp, argc);
        if argc == 0 {
            throw_type_error(cx, "Not enough arguments to booleanAttributeStatic setter.");
            return false;
        }let arg0: bool = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = TestBinding::SetBooleanAttributeStatic(&global, arg0);

        return true;
    }), false);
}

unsafe extern fn receiveVoidStatic<TH: TypeHolderTrait>
(cx: *mut JSContext, argc: libc::c_uint, vp: *mut JSVal) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let global = GlobalScope::from_object(JS_CALLEE(cx, vp).to_object());
        let args = CallArgs::from_vp(vp, argc);
        let result: () = TestBinding::ReceiveVoidStatic(&global);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn BooleanMozPreference<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.BooleanMozPreference\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: bool = this.BooleanMozPreference(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const BooleanMozPreference_methodinfo: JSJitInfo = JSJitInfo {
    call: BooleanMozPreference as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_BOOLEAN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn StringMozPreference<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.StringMozPreference\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: DOMString = this.StringMozPreference(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const StringMozPreference_methodinfo: JSJitInfo = JSJitInfo {
    call: StringMozPreference as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_prefControlledAttributeDisabled<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: bool = this.PrefControlledAttributeDisabled();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const prefControlledAttributeDisabled_getterinfo: JSJitInfo = JSJitInfo {
    call: get_prefControlledAttributeDisabled as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_BOOLEAN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_prefControlledStaticAttributeDisabled<TH: TypeHolderTrait>
(cx: *mut JSContext, argc: libc::c_uint, vp: *mut JSVal) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let global = GlobalScope::from_object(JS_CALLEE(cx, vp).to_object());
        let args = CallArgs::from_vp(vp, argc);
        let result: bool = TestBinding::PrefControlledStaticAttributeDisabled(&global);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn prefControlledMethodDisabled<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.PrefControlledMethodDisabled();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const prefControlledMethodDisabled_methodinfo: JSJitInfo = JSJitInfo {
    call: prefControlledMethodDisabled as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn prefControlledStaticMethodDisabled<TH: TypeHolderTrait>
(cx: *mut JSContext, argc: libc::c_uint, vp: *mut JSVal) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let global = GlobalScope::from_object(JS_CALLEE(cx, vp).to_object());
        let args = CallArgs::from_vp(vp, argc);
        let result: () = TestBinding::PrefControlledStaticMethodDisabled(&global);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn advanceClock<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.advanceClock\".");
            return false;
        }
        let arg0: i32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: bool = if args.get(1).is_undefined() {
            true
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.AdvanceClock(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const advanceClock_methodinfo: JSJitInfo = JSJitInfo {
    call: advanceClock as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_prefControlledAttributeEnabled<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: bool = this.PrefControlledAttributeEnabled();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const prefControlledAttributeEnabled_getterinfo: JSJitInfo = JSJitInfo {
    call: get_prefControlledAttributeEnabled as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_BOOLEAN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_prefControlledStaticAttributeEnabled<TH: TypeHolderTrait>
(cx: *mut JSContext, argc: libc::c_uint, vp: *mut JSVal) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let global = GlobalScope::from_object(JS_CALLEE(cx, vp).to_object());
        let args = CallArgs::from_vp(vp, argc);
        let result: bool = TestBinding::PrefControlledStaticAttributeEnabled(&global);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn prefControlledMethodEnabled<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.PrefControlledMethodEnabled();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const prefControlledMethodEnabled_methodinfo: JSJitInfo = JSJitInfo {
    call: prefControlledMethodEnabled as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn prefControlledStaticMethodEnabled<TH: TypeHolderTrait>
(cx: *mut JSContext, argc: libc::c_uint, vp: *mut JSVal) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let global = GlobalScope::from_object(JS_CALLEE(cx, vp).to_object());
        let args = CallArgs::from_vp(vp, argc);
        let result: () = TestBinding::PrefControlledStaticMethodEnabled(&global);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn get_funcControlledAttributeDisabled<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: bool = this.FuncControlledAttributeDisabled();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const funcControlledAttributeDisabled_getterinfo: JSJitInfo = JSJitInfo {
    call: get_funcControlledAttributeDisabled as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_BOOLEAN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_funcControlledStaticAttributeDisabled<TH: TypeHolderTrait>
(cx: *mut JSContext, argc: libc::c_uint, vp: *mut JSVal) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let global = GlobalScope::from_object(JS_CALLEE(cx, vp).to_object());
        let args = CallArgs::from_vp(vp, argc);
        let result: bool = TestBinding::FuncControlledStaticAttributeDisabled(&global);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn funcControlledMethodDisabled<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.FuncControlledMethodDisabled();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const funcControlledMethodDisabled_methodinfo: JSJitInfo = JSJitInfo {
    call: funcControlledMethodDisabled as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn funcControlledStaticMethodDisabled<TH: TypeHolderTrait>
(cx: *mut JSContext, argc: libc::c_uint, vp: *mut JSVal) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let global = GlobalScope::from_object(JS_CALLEE(cx, vp).to_object());
        let args = CallArgs::from_vp(vp, argc);
        let result: () = TestBinding::FuncControlledStaticMethodDisabled(&global);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn get_funcControlledAttributeEnabled<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: bool = this.FuncControlledAttributeEnabled();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const funcControlledAttributeEnabled_getterinfo: JSJitInfo = JSJitInfo {
    call: get_funcControlledAttributeEnabled as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_BOOLEAN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_funcControlledStaticAttributeEnabled<TH: TypeHolderTrait>
(cx: *mut JSContext, argc: libc::c_uint, vp: *mut JSVal) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let global = GlobalScope::from_object(JS_CALLEE(cx, vp).to_object());
        let args = CallArgs::from_vp(vp, argc);
        let result: bool = TestBinding::FuncControlledStaticAttributeEnabled(&global);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn funcControlledMethodEnabled<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.FuncControlledMethodEnabled();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const funcControlledMethodEnabled_methodinfo: JSJitInfo = JSJitInfo {
    call: funcControlledMethodEnabled as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn funcControlledStaticMethodEnabled<TH: TypeHolderTrait>
(cx: *mut JSContext, argc: libc::c_uint, vp: *mut JSVal) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let global = GlobalScope::from_object(JS_CALLEE(cx, vp).to_object());
        let args = CallArgs::from_vp(vp, argc);
        let result: () = TestBinding::FuncControlledStaticMethodEnabled(&global);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn returnResolvedPromise<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.returnResolvedPromise\".");
            return false;
        }
        let arg0: HandleValue = args.get(0);
        let result: Result<Rc<Promise<TH>>, Error> = this.ReturnResolvedPromise(cx, arg0);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const returnResolvedPromise_methodinfo: JSJitInfo = JSJitInfo {
    call: returnResolvedPromise as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn returnRejectedPromise<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.returnRejectedPromise\".");
            return false;
        }
        let arg0: HandleValue = args.get(0);
        let result: Result<Rc<Promise<TH>>, Error> = this.ReturnRejectedPromise(cx, arg0);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const returnRejectedPromise_methodinfo: JSJitInfo = JSJitInfo {
    call: returnRejectedPromise as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn get_promiseAttribute<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Rc<Promise<TH>> = this.PromiseAttribute();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const promiseAttribute_getterinfo: JSJitInfo = JSJitInfo {
    call: get_promiseAttribute as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn acceptPromise<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.acceptPromise\".");
            return false;
        }
        let arg0: Rc<Promise<TH>> = { // Scope for our JSAutoCompartment.

            rooted!(in(cx) let globalObj = CurrentGlobalOrNull(cx));
            let promiseGlobal = GlobalScope::from_object_maybe_wrapped(globalObj.handle().get());

            rooted!(in(cx) let mut valueToResolve = args.get(0).get());
            if !JS_WrapValue(cx, valueToResolve.handle_mut()) {
            return false;
            }
            match Promise::new_resolved(&promiseGlobal, cx, valueToResolve.handle()) {
                Ok(value) => value,
                Err(error) => {
                throw_dom_exception(cx, &promiseGlobal, error);
                return false;
                }
            }
        }
        ;
        let result: () = this.AcceptPromise(&arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const acceptPromise_methodinfo: JSJitInfo = JSJitInfo {
    call: acceptPromise as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn promiseNativeHandler<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.promiseNativeHandler\".");
            return false;
        }
        let arg0: Option<Rc<SimpleCallback>> = if args.get(0).get().is_object() {
            if IsCallable(args.get(0).get().to_object()) {
                Some(SimpleCallback::new(cx, args.get(0).get().to_object()))
            } else {
                throw_type_error(cx, "Value is not callable.");
                return false;

            }
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: Option<Rc<SimpleCallback>> = if args.get(1).get().is_object() {
            if IsCallable(args.get(1).get().to_object()) {
                Some(SimpleCallback::new(cx, args.get(1).get().to_object()))
            } else {
                throw_type_error(cx, "Value is not callable.");
                return false;

            }
        } else if args.get(1).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: Rc<Promise<TH>> = this.PromiseNativeHandler(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const promiseNativeHandler_methodinfo: JSJitInfo = JSJitInfo {
    call: promiseNativeHandler as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn promiseResolveNative<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.promiseResolveNative\".");
            return false;
        }
        let arg0: Rc<Promise<TH>> = { // Scope for our JSAutoCompartment.

            rooted!(in(cx) let globalObj = CurrentGlobalOrNull(cx));
            let promiseGlobal = GlobalScope::from_object_maybe_wrapped(globalObj.handle().get());

            rooted!(in(cx) let mut valueToResolve = args.get(0).get());
            if !JS_WrapValue(cx, valueToResolve.handle_mut()) {
            return false;
            }
            match Promise::new_resolved(&promiseGlobal, cx, valueToResolve.handle()) {
                Ok(value) => value,
                Err(error) => {
                throw_dom_exception(cx, &promiseGlobal, error);
                return false;
                }
            }
        }
        ;
        let arg1: HandleValue = args.get(1);
        let result: () = this.PromiseResolveNative(cx, &arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const promiseResolveNative_methodinfo: JSJitInfo = JSJitInfo {
    call: promiseResolveNative as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn promiseRejectNative<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.promiseRejectNative\".");
            return false;
        }
        let arg0: Rc<Promise<TH>> = { // Scope for our JSAutoCompartment.

            rooted!(in(cx) let globalObj = CurrentGlobalOrNull(cx));
            let promiseGlobal = GlobalScope::from_object_maybe_wrapped(globalObj.handle().get());

            rooted!(in(cx) let mut valueToResolve = args.get(0).get());
            if !JS_WrapValue(cx, valueToResolve.handle_mut()) {
            return false;
            }
            match Promise::new_resolved(&promiseGlobal, cx, valueToResolve.handle()) {
                Ok(value) => value,
                Err(error) => {
                throw_dom_exception(cx, &promiseGlobal, error);
                return false;
                }
            }
        }
        ;
        let arg1: HandleValue = args.get(1);
        let result: () = this.PromiseRejectNative(cx, &arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const promiseRejectNative_methodinfo: JSJitInfo = JSJitInfo {
    call: promiseRejectNative as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn promiseRejectWithTypeError<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.promiseRejectWithTypeError\".");
            return false;
        }
        let arg0: Rc<Promise<TH>> = { // Scope for our JSAutoCompartment.

            rooted!(in(cx) let globalObj = CurrentGlobalOrNull(cx));
            let promiseGlobal = GlobalScope::from_object_maybe_wrapped(globalObj.handle().get());

            rooted!(in(cx) let mut valueToResolve = args.get(0).get());
            if !JS_WrapValue(cx, valueToResolve.handle_mut()) {
            return false;
            }
            match Promise::new_resolved(&promiseGlobal, cx, valueToResolve.handle()) {
                Ok(value) => value,
                Err(error) => {
                throw_dom_exception(cx, &promiseGlobal, error);
                return false;
                }
            }
        }
        ;
        let arg1: USVString = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.PromiseRejectWithTypeError(&arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const promiseRejectWithTypeError_methodinfo: JSJitInfo = JSJitInfo {
    call: promiseRejectWithTypeError as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn resolvePromiseDelayed<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 3 {
            throw_type_error(cx, "Not enough arguments to \"TestBinding.resolvePromiseDelayed\".");
            return false;
        }
        let arg0: Rc<Promise<TH>> = { // Scope for our JSAutoCompartment.

            rooted!(in(cx) let globalObj = CurrentGlobalOrNull(cx));
            let promiseGlobal = GlobalScope::from_object_maybe_wrapped(globalObj.handle().get());

            rooted!(in(cx) let mut valueToResolve = args.get(0).get());
            if !JS_WrapValue(cx, valueToResolve.handle_mut()) {
            return false;
            }
            match Promise::new_resolved(&promiseGlobal, cx, valueToResolve.handle()) {
                Ok(value) => value,
                Err(error) => {
                throw_dom_exception(cx, &promiseGlobal, error);
                return false;
                }
            }
        }
        ;
        let arg1: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(1), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let arg2: u64 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.ResolvePromiseDelayed(&arg0, arg1, arg2);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const resolvePromiseDelayed_methodinfo: JSJitInfo = JSJitInfo {
    call: resolvePromiseDelayed as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn panic<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.Panic();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const panic_methodinfo: JSJitInfo = JSJitInfo {
    call: panic as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn entryGlobal<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: DomRoot<GlobalScope<TH>> = this.EntryGlobal();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const entryGlobal_methodinfo: JSJitInfo = JSJitInfo {
    call: entryGlobal as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn incumbentGlobal<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: DomRoot<GlobalScope<TH>> = this.IncumbentGlobal();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const incumbentGlobal_methodinfo: JSJitInfo = JSJitInfo {
    call: incumbentGlobal as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn crashHard<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const TestBinding<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.CrashHard();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


const crashHard_methodinfo: JSJitInfo = JSJitInfo {
    call: crashHard as *const os::raw::c_void,
    protoID: PrototypeList::ID::TestBinding as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
};

unsafe extern fn _finalize<TH: TypeHolderTrait>
(_fop: *mut JSFreeOp, obj: *mut JSObject) {
    return wrap_panic(panic::AssertUnwindSafe(|| {

        let this = native_from_object::<TestBinding<TH>>(obj).unwrap();
            if !this.is_null() {
                // The pointer can be null if the object is the unforgeable holder of that interface.
                let _ = Box::from_raw(this as *mut TestBinding<TH>);
            }
            debug!("TestBinding<TH> finalize: {:p}", this);
    }), ());
}

unsafe extern fn _trace<TH: TypeHolderTrait>
(trc: *mut JSTracer, obj: *mut JSObject) {
    return wrap_panic(panic::AssertUnwindSafe(|| {

        let this = native_from_object::<TestBinding<TH>>(obj).unwrap();
        if this.is_null() { return; } // GC during obj creation
        (*this).trace(trc);
    }), ());
}

pub mod TestBindingConstants {
    pub const constantInt64: i64 = -1;
    pub const constantUint64: u64 = 1;
    pub const constantFloat32: f32 = 1.0;
    pub const constantFloat64: f64 = 1.0;
    pub const constantUnrestrictedFloat32: f32 = 1.0;
    pub const constantUnrestrictedFloat64: f64 = 1.0;
    pub const prefControlledConstDisabled: u16 = 0;
    pub const prefControlledConstEnabled: u16 = 0;
    pub const funcControlledConstDisabled: u16 = 0;
    pub const funcControlledConstEnabled: u16 = 0;
} // mod TestBindingConstants
static CLASS_OPS: js::jsapi::JSClassOps = js::jsapi::JSClassOps {
    addProperty: None,
    delProperty: None,
    getProperty: None,
    setProperty: None,
    enumerate: None,
    resolve: None,
    mayResolve: None,
    finalize: Some(_finalize),
    call: None,
    hasInstance: None,
    construct: None,
    trace: Some(_trace),
};

static Class: DOMJSClass = DOMJSClass {
    base: js::jsapi::JSClass {
        name: b"TestBinding\0" as *const u8 as *const libc::c_char,
        flags: JSCLASS_IS_DOMJSCLASS | 0 |
               (((1) & JSCLASS_RESERVED_SLOTS_MASK) << JSCLASS_RESERVED_SLOTS_SHIFT)
               /* JSCLASS_HAS_RESERVED_SLOTS(1) */,
        cOps: &CLASS_OPS,
        reserved: [0 as *mut _; 3],
    },
    dom_class: DOMClass {
    interface_chain: [ PrototypeList::ID::TestBinding, PrototypeList::ID::Last, PrototypeList::ID::Last, PrototypeList::ID::Last, PrototypeList::ID::Last, PrototypeList::ID::Last ],
    type_id: ::dom::bindings::codegen::InheritTypes::TopTypeId { testbinding: (::dom::bindings::codegen::InheritTypes::TestBindingTypeId::TestBinding) },
    global: InterfaceObjectMap::Globals::EMPTY,
}
};

#[inline]
fn malloc_size<TH: TypeHolderTrait>(ops: &mut MallocSizeOfOps, obj: *const c_void) -> usize {
    malloc_size_of_including_raw_self::<TestBinding<TH>>(ops, obj)
}

pub unsafe fn Wrap<TH: TypeHolderTrait>
(cx: *mut JSContext, scope: &GlobalScope<TH>, object: Box<TestBinding<TH>>) -> DomRoot<TestBinding<TH>> {
    let scope = scope.reflector().get_jsobject();
    assert!(!scope.get().is_null());
    assert!(((*get_object_class(scope.get())).flags & JSCLASS_IS_GLOBAL) != 0);

    rooted!(in(cx) let mut proto = ptr::null_mut::<JSObject>());
    let _ac = JSAutoCompartment::new(cx, scope.get());
    GetProtoObject(cx, scope, proto.handle_mut());
    assert!(!proto.is_null());

    let raw = Box::into_raw(object);
    let _rt = RootedTraceable::new(&*raw);
    rooted!(in(cx) let obj = JS_NewObjectWithGivenProto(
        cx, &Class.base as *const JSClass, proto.handle()));
    assert!(!obj.is_null());

    JS_SetReservedSlot(obj.get(), DOM_OBJECT_SLOT,
                       PrivateValue(raw as *const libc::c_void));


    (*raw).init_reflector(obj.get());

    DomRoot::from_ref(&*raw)
}

impl<TH: TypeHolderTrait> IDLInterface for TestBinding<TH> {
    #[inline]
    fn derives(class: &'static DOMClass) -> bool {
        class.interface_chain[0] == PrototypeList::ID::TestBinding
    }
}

impl<TH: TypeHolderTrait> PartialEq for TestBinding<TH> {
    fn eq(&self, other: &TestBinding<TH>) -> bool {
        self as *const TestBinding<TH> == &*other
    }
}

pub trait TestBindingMethods<TH: TypeHolderTrait> {
    fn BooleanAttribute(&self) -> bool;
    fn SetBooleanAttribute(&self, value: bool) -> ();
    fn ByteAttribute(&self) -> i8;
    fn SetByteAttribute(&self, value: i8) -> ();
    fn OctetAttribute(&self) -> u8;
    fn SetOctetAttribute(&self, value: u8) -> ();
    fn ShortAttribute(&self) -> i16;
    fn SetShortAttribute(&self, value: i16) -> ();
    fn UnsignedShortAttribute(&self) -> u16;
    fn SetUnsignedShortAttribute(&self, value: u16) -> ();
    fn LongAttribute(&self) -> i32;
    fn SetLongAttribute(&self, value: i32) -> ();
    fn UnsignedLongAttribute(&self) -> u32;
    fn SetUnsignedLongAttribute(&self, value: u32) -> ();
    fn LongLongAttribute(&self) -> i64;
    fn SetLongLongAttribute(&self, value: i64) -> ();
    fn UnsignedLongLongAttribute(&self) -> u64;
    fn SetUnsignedLongLongAttribute(&self, value: u64) -> ();
    fn UnrestrictedFloatAttribute(&self) -> f32;
    fn SetUnrestrictedFloatAttribute(&self, value: f32) -> ();
    fn FloatAttribute(&self) -> Finite<f32>;
    fn SetFloatAttribute(&self, value: Finite<f32>) -> ();
    fn UnrestrictedDoubleAttribute(&self) -> f64;
    fn SetUnrestrictedDoubleAttribute(&self, value: f64) -> ();
    fn DoubleAttribute(&self) -> Finite<f64>;
    fn SetDoubleAttribute(&self, value: Finite<f64>) -> ();
    fn StringAttribute(&self) -> DOMString;
    fn SetStringAttribute(&self, value: DOMString) -> ();
    fn UsvstringAttribute(&self) -> USVString;
    fn SetUsvstringAttribute(&self, value: USVString) -> ();
    fn ByteStringAttribute(&self) -> ByteString;
    fn SetByteStringAttribute(&self, value: ByteString) -> ();
    fn EnumAttribute(&self) -> TestEnum;
    fn SetEnumAttribute(&self, value: TestEnum) -> ();
    fn InterfaceAttribute(&self) -> DomRoot<Blob<TH>>;
    fn SetInterfaceAttribute(&self, value: &Blob<TH>) -> ();
    fn UnionAttribute(&self) -> UnionTypes::HTMLElementOrLong<TH>;
    fn SetUnionAttribute(&self, value: UnionTypes::HTMLElementOrLong<TH>) -> ();
    fn Union2Attribute(&self) -> UnionTypes::EventOrString<TH>;
    fn SetUnion2Attribute(&self, value: UnionTypes::EventOrString<TH>) -> ();
    fn Union3Attribute(&self) -> UnionTypes::EventOrUSVString<TH>;
    fn SetUnion3Attribute(&self, value: UnionTypes::EventOrUSVString<TH>) -> ();
    fn Union4Attribute(&self) -> UnionTypes::StringOrUnsignedLong;
    fn SetUnion4Attribute(&self, value: UnionTypes::StringOrUnsignedLong) -> ();
    fn Union5Attribute(&self) -> UnionTypes::StringOrBoolean;
    fn SetUnion5Attribute(&self, value: UnionTypes::StringOrBoolean) -> ();
    fn Union6Attribute(&self) -> UnionTypes::UnsignedLongOrBoolean;
    fn SetUnion6Attribute(&self, value: UnionTypes::UnsignedLongOrBoolean) -> ();
    fn Union7Attribute(&self) -> UnionTypes::BlobOrBoolean<TH>;
    fn SetUnion7Attribute(&self, value: UnionTypes::BlobOrBoolean<TH>) -> ();
    fn Union8Attribute(&self) -> UnionTypes::BlobOrUnsignedLong<TH>;
    fn SetUnion8Attribute(&self, value: UnionTypes::BlobOrUnsignedLong<TH>) -> ();
    fn Union9Attribute(&self) -> UnionTypes::ByteStringOrLong;
    fn SetUnion9Attribute(&self, value: UnionTypes::ByteStringOrLong) -> ();
    unsafe fn ArrayAttribute(&self, cx: *mut JSContext) -> NonNull<JSObject>;
    unsafe fn AnyAttribute(&self, cx: *mut JSContext) -> JSVal;
    unsafe fn SetAnyAttribute(&self, cx: *mut JSContext, value: HandleValue) -> ();
    unsafe fn ObjectAttribute(&self, cx: *mut JSContext) -> NonNull<JSObject>;
    unsafe fn SetObjectAttribute(&self, cx: *mut JSContext, value: *mut JSObject) -> ();
    fn GetBooleanAttributeNullable(&self) -> Option<bool>;
    fn SetBooleanAttributeNullable(&self, value: Option<bool>) -> ();
    fn GetByteAttributeNullable(&self) -> Option<i8>;
    fn SetByteAttributeNullable(&self, value: Option<i8>) -> ();
    fn GetOctetAttributeNullable(&self) -> Option<u8>;
    fn SetOctetAttributeNullable(&self, value: Option<u8>) -> ();
    fn GetShortAttributeNullable(&self) -> Option<i16>;
    fn SetShortAttributeNullable(&self, value: Option<i16>) -> ();
    fn GetUnsignedShortAttributeNullable(&self) -> Option<u16>;
    fn SetUnsignedShortAttributeNullable(&self, value: Option<u16>) -> ();
    fn GetLongAttributeNullable(&self) -> Option<i32>;
    fn SetLongAttributeNullable(&self, value: Option<i32>) -> ();
    fn GetUnsignedLongAttributeNullable(&self) -> Option<u32>;
    fn SetUnsignedLongAttributeNullable(&self, value: Option<u32>) -> ();
    fn GetLongLongAttributeNullable(&self) -> Option<i64>;
    fn SetLongLongAttributeNullable(&self, value: Option<i64>) -> ();
    fn GetUnsignedLongLongAttributeNullable(&self) -> Option<u64>;
    fn SetUnsignedLongLongAttributeNullable(&self, value: Option<u64>) -> ();
    fn GetUnrestrictedFloatAttributeNullable(&self) -> Option<f32>;
    fn SetUnrestrictedFloatAttributeNullable(&self, value: Option<f32>) -> ();
    fn GetFloatAttributeNullable(&self) -> Option<Finite<f32>>;
    fn SetFloatAttributeNullable(&self, value: Option<Finite<f32>>) -> ();
    fn GetUnrestrictedDoubleAttributeNullable(&self) -> Option<f64>;
    fn SetUnrestrictedDoubleAttributeNullable(&self, value: Option<f64>) -> ();
    fn GetDoubleAttributeNullable(&self) -> Option<Finite<f64>>;
    fn SetDoubleAttributeNullable(&self, value: Option<Finite<f64>>) -> ();
    fn GetStringAttributeNullable(&self) -> Option<DOMString>;
    fn SetStringAttributeNullable(&self, value: Option<DOMString>) -> ();
    fn GetUsvstringAttributeNullable(&self) -> Option<USVString>;
    fn SetUsvstringAttributeNullable(&self, value: Option<USVString>) -> ();
    fn GetByteStringAttributeNullable(&self) -> Option<ByteString>;
    fn SetByteStringAttributeNullable(&self, value: Option<ByteString>) -> ();
    fn GetEnumAttributeNullable(&self) -> Option<TestEnum>;
    fn GetInterfaceAttributeNullable(&self) -> Option<DomRoot<Blob<TH>>>;
    fn SetInterfaceAttributeNullable(&self, value: Option<&Blob<TH>>) -> ();
    fn GetInterfaceAttributeWeak(&self) -> Option<DomRoot<URL<TH>>>;
    fn SetInterfaceAttributeWeak(&self, value: Option<&URL<TH>>) -> ();
    unsafe fn GetObjectAttributeNullable(&self, cx: *mut JSContext) -> Option<NonNull<JSObject>>;
    unsafe fn SetObjectAttributeNullable(&self, cx: *mut JSContext, value: *mut JSObject) -> ();
    fn GetUnionAttributeNullable(&self) -> Option<UnionTypes::HTMLElementOrLong<TH>>;
    fn SetUnionAttributeNullable(&self, value: Option<UnionTypes::HTMLElementOrLong<TH>>) -> ();
    fn GetUnion2AttributeNullable(&self) -> Option<UnionTypes::EventOrString<TH>>;
    fn SetUnion2AttributeNullable(&self, value: Option<UnionTypes::EventOrString<TH>>) -> ();
    fn GetUnion3AttributeNullable(&self) -> Option<UnionTypes::BlobOrBoolean<TH>>;
    fn SetUnion3AttributeNullable(&self, value: Option<UnionTypes::BlobOrBoolean<TH>>) -> ();
    fn GetUnion4AttributeNullable(&self) -> Option<UnionTypes::UnsignedLongOrBoolean>;
    fn SetUnion4AttributeNullable(&self, value: Option<UnionTypes::UnsignedLongOrBoolean>) -> ();
    fn GetUnion5AttributeNullable(&self) -> Option<UnionTypes::StringOrBoolean>;
    fn SetUnion5AttributeNullable(&self, value: Option<UnionTypes::StringOrBoolean>) -> ();
    fn GetUnion6AttributeNullable(&self) -> Option<UnionTypes::ByteStringOrLong>;
    fn SetUnion6AttributeNullable(&self, value: Option<UnionTypes::ByteStringOrLong>) -> ();
    fn BinaryRenamedAttribute(&self) -> DOMString;
    fn SetBinaryRenamedAttribute(&self, value: DOMString) -> ();
    fn BinaryRenamedAttribute2(&self) -> DOMString;
    fn SetBinaryRenamedAttribute2(&self, value: DOMString) -> ();
    fn Attr_to_automatically_rename(&self) -> DOMString;
    fn SetAttr_to_automatically_rename(&self, value: DOMString) -> ();
    fn ForwardedAttribute(&self) -> DomRoot<TestBinding<TH>>;
    fn BinaryRenamedMethod(&self) -> ();
    fn ReceiveVoid(&self) -> ();
    fn ReceiveBoolean(&self) -> bool;
    fn ReceiveByte(&self) -> i8;
    fn ReceiveOctet(&self) -> u8;
    fn ReceiveShort(&self) -> i16;
    fn ReceiveUnsignedShort(&self) -> u16;
    fn ReceiveLong(&self) -> i32;
    fn ReceiveUnsignedLong(&self) -> u32;
    fn ReceiveLongLong(&self) -> i64;
    fn ReceiveUnsignedLongLong(&self) -> u64;
    fn ReceiveUnrestrictedFloat(&self) -> f32;
    fn ReceiveFloat(&self) -> Finite<f32>;
    fn ReceiveUnrestrictedDouble(&self) -> f64;
    fn ReceiveDouble(&self) -> Finite<f64>;
    fn ReceiveString(&self) -> DOMString;
    fn ReceiveUsvstring(&self) -> USVString;
    fn ReceiveByteString(&self) -> ByteString;
    fn ReceiveEnum(&self) -> TestEnum;
    fn ReceiveInterface(&self) -> DomRoot<Blob<TH>>;
    unsafe fn ReceiveAny(&self, cx: *mut JSContext) -> JSVal;
    unsafe fn ReceiveObject(&self, cx: *mut JSContext) -> NonNull<JSObject>;
    fn ReceiveUnion(&self) -> UnionTypes::HTMLElementOrLong<TH>;
    fn ReceiveUnion2(&self) -> UnionTypes::EventOrString<TH>;
    fn ReceiveUnion3(&self) -> UnionTypes::StringOrLongSequence;
    fn ReceiveUnion4(&self) -> UnionTypes::StringOrStringSequence;
    fn ReceiveUnion5(&self) -> UnionTypes::BlobOrBlobSequence<TH>;
    fn ReceiveUnion6(&self) -> UnionTypes::StringOrUnsignedLong;
    fn ReceiveUnion7(&self) -> UnionTypes::StringOrBoolean;
    fn ReceiveUnion8(&self) -> UnionTypes::UnsignedLongOrBoolean;
    fn ReceiveUnion9(&self) -> UnionTypes::HTMLElementOrUnsignedLongOrStringOrBoolean<TH>;
    fn ReceiveUnion10(&self) -> UnionTypes::ByteStringOrLong;
    fn ReceiveUnion11(&self) -> UnionTypes::ByteStringSequenceOrLongOrString;
    fn ReceiveSequence(&self) -> Vec<i32>;
    fn ReceiveInterfaceSequence(&self) -> Vec<DomRoot<Blob<TH>>>;
    fn ReceiveNullableByte(&self) -> Option<i8>;
    fn ReceiveNullableBoolean(&self) -> Option<bool>;
    fn ReceiveNullableOctet(&self) -> Option<u8>;
    fn ReceiveNullableShort(&self) -> Option<i16>;
    fn ReceiveNullableUnsignedShort(&self) -> Option<u16>;
    fn ReceiveNullableLong(&self) -> Option<i32>;
    fn ReceiveNullableUnsignedLong(&self) -> Option<u32>;
    fn ReceiveNullableLongLong(&self) -> Option<i64>;
    fn ReceiveNullableUnsignedLongLong(&self) -> Option<u64>;
    fn ReceiveNullableUnrestrictedFloat(&self) -> Option<f32>;
    fn ReceiveNullableFloat(&self) -> Option<Finite<f32>>;
    fn ReceiveNullableUnrestrictedDouble(&self) -> Option<f64>;
    fn ReceiveNullableDouble(&self) -> Option<Finite<f64>>;
    fn ReceiveNullableString(&self) -> Option<DOMString>;
    fn ReceiveNullableUsvstring(&self) -> Option<USVString>;
    fn ReceiveNullableByteString(&self) -> Option<ByteString>;
    fn ReceiveNullableEnum(&self) -> Option<TestEnum>;
    fn ReceiveNullableInterface(&self) -> Option<DomRoot<Blob<TH>>>;
    unsafe fn ReceiveNullableObject(&self, cx: *mut JSContext) -> Option<NonNull<JSObject>>;
    fn ReceiveNullableUnion(&self) -> Option<UnionTypes::HTMLElementOrLong<TH>>;
    fn ReceiveNullableUnion2(&self) -> Option<UnionTypes::EventOrString<TH>>;
    fn ReceiveNullableUnion3(&self) -> Option<UnionTypes::StringOrLongSequence>;
    fn ReceiveNullableUnion4(&self) -> Option<UnionTypes::LongSequenceOrBoolean>;
    fn ReceiveNullableUnion5(&self) -> Option<UnionTypes::UnsignedLongOrBoolean>;
    fn ReceiveNullableUnion6(&self) -> Option<UnionTypes::ByteStringOrLong>;
    fn ReceiveNullableSequence(&self) -> Option<Vec<i32>>;
    fn ReceiveTestDictionaryWithSuccessOnKeyword(&self) -> RootedTraceableBox<TestDictionary<TH>>;
    fn DictMatchesPassedValues(&self, arg: RootedTraceableBox<dom::bindings::codegen::Bindings::TestBindingBinding::TestDictionary<TH>>) -> bool;
    unsafe fn ReceiveUnionIdentity(&self, cx: *mut JSContext, arg: UnionTypes::StringOrObject) -> UnionTypes::StringOrObject;
    fn PassBoolean(&self, arg: bool) -> ();
    fn PassByte(&self, arg: i8) -> ();
    fn PassOctet(&self, arg: u8) -> ();
    fn PassShort(&self, arg: i16) -> ();
    fn PassUnsignedShort(&self, arg: u16) -> ();
    fn PassLong(&self, arg: i32) -> ();
    fn PassUnsignedLong(&self, arg: u32) -> ();
    fn PassLongLong(&self, arg: i64) -> ();
    fn PassUnsignedLongLong(&self, arg: u64) -> ();
    fn PassUnrestrictedFloat(&self, arg: f32) -> ();
    fn PassFloat(&self, arg: Finite<f32>) -> ();
    fn PassUnrestrictedDouble(&self, arg: f64) -> ();
    fn PassDouble(&self, arg: Finite<f64>) -> ();
    fn PassString(&self, arg: DOMString) -> ();
    fn PassUsvstring(&self, arg: USVString) -> ();
    fn PassByteString(&self, arg: ByteString) -> ();
    fn PassEnum(&self, arg: TestEnum) -> ();
    fn PassInterface(&self, arg: &Blob<TH>) -> ();
    fn PassTypedArray(&self, arg: CustomAutoRooterGuard<typedarray::Int8Array>) -> ();
    fn PassTypedArray2(&self, arg: CustomAutoRooterGuard<typedarray::ArrayBuffer>) -> ();
    fn PassTypedArray3(&self, arg: CustomAutoRooterGuard<typedarray::ArrayBufferView>) -> ();
    fn PassUnion(&self, arg: UnionTypes::HTMLElementOrLong<TH>) -> ();
    fn PassUnion2(&self, data: UnionTypes::EventOrString<TH>) -> ();
    fn PassUnion3(&self, data: UnionTypes::BlobOrString<TH>) -> ();
    fn PassUnion4(&self, seq: UnionTypes::StringOrStringSequence) -> ();
    fn PassUnion5(&self, data: UnionTypes::StringOrBoolean) -> ();
    fn PassUnion6(&self, bool: UnionTypes::UnsignedLongOrBoolean) -> ();
    fn PassUnion7(&self, arg: UnionTypes::StringSequenceOrUnsignedLong) -> ();
    fn PassUnion8(&self, arg: UnionTypes::ByteStringSequenceOrLong) -> ();
    fn PassUnion9(&self, arg: UnionTypes::TestDictionaryOrLong<TH>) -> ();
    unsafe fn PassUnion10(&self, cx: *mut JSContext, arg: UnionTypes::StringOrObject) -> ();
    fn PassUnion11(&self, arg: UnionTypes::ArrayBufferOrArrayBufferView) -> ();
    fn PassUnionWithTypedef(&self, arg: UnionTypes::DocumentOrTestTypedef<TH>) -> ();
    fn PassUnionWithTypedef2(&self, arg: UnionTypes::LongSequenceOrTestTypedef<TH>) -> ();
    unsafe fn PassAny(&self, cx: *mut JSContext, arg: HandleValue) -> ();
    unsafe fn PassObject(&self, cx: *mut JSContext, arg: *mut JSObject) -> ();
    fn PassCallbackFunction(&self, fun: Rc<Function<TH>>) -> ();
    fn PassCallbackInterface(&self, listener: Rc<dom::bindings::codegen::Bindings::EventListenerBinding::EventListener<TH>>) -> ();
    fn PassSequence(&self, seq: Vec<i32>) -> ();
    unsafe fn PassAnySequence(&self, cx: *mut JSContext, seq: CustomAutoRooterGuard<Vec<JSVal>>) -> ();
    unsafe fn AnySequencePassthrough(&self, cx: *mut JSContext, seq: CustomAutoRooterGuard<Vec<JSVal>>) -> Vec<JSVal>;
    unsafe fn PassObjectSequence(&self, cx: *mut JSContext, seq: CustomAutoRooterGuard<Vec<*mut JSObject>>) -> ();
    fn PassStringSequence(&self, seq: Vec<DOMString>) -> ();
    fn PassInterfaceSequence(&self, seq: Vec<DomRoot<Blob<TH>>>) -> ();
    fn PassOverloaded(&self, arg: CustomAutoRooterGuard<typedarray::ArrayBuffer>) -> ();
    fn PassOverloaded_(&self, arg: DOMString) -> ();
    fn PassNullableBoolean(&self, arg: Option<bool>) -> ();
    fn PassNullableByte(&self, arg: Option<i8>) -> ();
    fn PassNullableOctet(&self, arg: Option<u8>) -> ();
    fn PassNullableShort(&self, arg: Option<i16>) -> ();
    fn PassNullableUnsignedShort(&self, arg: Option<u16>) -> ();
    fn PassNullableLong(&self, arg: Option<i32>) -> ();
    fn PassNullableUnsignedLong(&self, arg: Option<u32>) -> ();
    fn PassNullableLongLong(&self, arg: Option<i64>) -> ();
    fn PassNullableUnsignedLongLong(&self, arg: Option<u64>) -> ();
    fn PassNullableUnrestrictedFloat(&self, arg: Option<f32>) -> ();
    fn PassNullableFloat(&self, arg: Option<Finite<f32>>) -> ();
    fn PassNullableUnrestrictedDouble(&self, arg: Option<f64>) -> ();
    fn PassNullableDouble(&self, arg: Option<Finite<f64>>) -> ();
    fn PassNullableString(&self, arg: Option<DOMString>) -> ();
    fn PassNullableUsvstring(&self, arg: Option<USVString>) -> ();
    fn PassNullableByteString(&self, arg: Option<ByteString>) -> ();
    fn PassNullableInterface(&self, arg: Option<&Blob<TH>>) -> ();
    unsafe fn PassNullableObject(&self, cx: *mut JSContext, arg: *mut JSObject) -> ();
    fn PassNullableTypedArray(&self, arg: CustomAutoRooterGuard<Option<typedarray::Int8Array>>) -> ();
    fn PassNullableUnion(&self, arg: Option<UnionTypes::HTMLElementOrLong<TH>>) -> ();
    fn PassNullableUnion2(&self, data: Option<UnionTypes::EventOrString<TH>>) -> ();
    fn PassNullableUnion3(&self, data: Option<UnionTypes::StringOrLongSequence>) -> ();
    fn PassNullableUnion4(&self, bool: Option<UnionTypes::LongSequenceOrBoolean>) -> ();
    fn PassNullableUnion5(&self, arg: Option<UnionTypes::UnsignedLongOrBoolean>) -> ();
    fn PassNullableUnion6(&self, arg: Option<UnionTypes::ByteStringOrLong>) -> ();
    fn PassNullableCallbackFunction(&self, fun: Option<Rc<Function<TH>>>) -> ();
    fn PassNullableCallbackInterface(&self, listener: Option<Rc<dom::bindings::codegen::Bindings::EventListenerBinding::EventListener<TH>>>) -> ();
    fn PassNullableSequence(&self, seq: Option<Vec<i32> >) -> ();
    fn PassOptionalBoolean(&self, arg: Option<bool>) -> ();
    fn PassOptionalByte(&self, arg: Option<i8>) -> ();
    fn PassOptionalOctet(&self, arg: Option<u8>) -> ();
    fn PassOptionalShort(&self, arg: Option<i16>) -> ();
    fn PassOptionalUnsignedShort(&self, arg: Option<u16>) -> ();
    fn PassOptionalLong(&self, arg: Option<i32>) -> ();
    fn PassOptionalUnsignedLong(&self, arg: Option<u32>) -> ();
    fn PassOptionalLongLong(&self, arg: Option<i64>) -> ();
    fn PassOptionalUnsignedLongLong(&self, arg: Option<u64>) -> ();
    fn PassOptionalUnrestrictedFloat(&self, arg: Option<f32>) -> ();
    fn PassOptionalFloat(&self, arg: Option<Finite<f32>>) -> ();
    fn PassOptionalUnrestrictedDouble(&self, arg: Option<f64>) -> ();
    fn PassOptionalDouble(&self, arg: Option<Finite<f64>>) -> ();
    fn PassOptionalString(&self, arg: Option<DOMString>) -> ();
    fn PassOptionalUsvstring(&self, arg: Option<USVString>) -> ();
    fn PassOptionalByteString(&self, arg: Option<ByteString>) -> ();
    fn PassOptionalEnum(&self, arg: Option<TestEnum>) -> ();
    fn PassOptionalInterface(&self, arg: Option<&Blob<TH>>) -> ();
    fn PassOptionalUnion(&self, arg: Option<UnionTypes::HTMLElementOrLong<TH>>) -> ();
    fn PassOptionalUnion2(&self, data: Option<UnionTypes::EventOrString<TH>>) -> ();
    fn PassOptionalUnion3(&self, arg: Option<UnionTypes::StringOrLongSequence>) -> ();
    fn PassOptionalUnion4(&self, data: Option<UnionTypes::LongSequenceOrBoolean>) -> ();
    fn PassOptionalUnion5(&self, bool: Option<UnionTypes::UnsignedLongOrBoolean>) -> ();
    fn PassOptionalUnion6(&self, arg: Option<UnionTypes::ByteStringOrLong>) -> ();
    unsafe fn PassOptionalAny(&self, cx: *mut JSContext, arg: HandleValue) -> ();
    unsafe fn PassOptionalObject(&self, cx: *mut JSContext, arg: Option<*mut JSObject>) -> ();
    fn PassOptionalCallbackFunction(&self, fun: Option<Rc<Function<TH>>>) -> ();
    fn PassOptionalCallbackInterface(&self, listener: Option<Rc<dom::bindings::codegen::Bindings::EventListenerBinding::EventListener<TH>>>) -> ();
    fn PassOptionalSequence(&self, seq: Option<Vec<i32>>) -> ();
    fn PassOptionalNullableBoolean(&self, arg: Option<Option<bool>>) -> ();
    fn PassOptionalNullableByte(&self, arg: Option<Option<i8>>) -> ();
    fn PassOptionalNullableOctet(&self, arg: Option<Option<u8>>) -> ();
    fn PassOptionalNullableShort(&self, arg: Option<Option<i16>>) -> ();
    fn PassOptionalNullableUnsignedShort(&self, arg: Option<Option<u16>>) -> ();
    fn PassOptionalNullableLong(&self, arg: Option<Option<i32>>) -> ();
    fn PassOptionalNullableUnsignedLong(&self, arg: Option<Option<u32>>) -> ();
    fn PassOptionalNullableLongLong(&self, arg: Option<Option<i64>>) -> ();
    fn PassOptionalNullableUnsignedLongLong(&self, arg: Option<Option<u64>>) -> ();
    fn PassOptionalNullableUnrestrictedFloat(&self, arg: Option<Option<f32>>) -> ();
    fn PassOptionalNullableFloat(&self, arg: Option<Option<Finite<f32>>>) -> ();
    fn PassOptionalNullableUnrestrictedDouble(&self, arg: Option<Option<f64>>) -> ();
    fn PassOptionalNullableDouble(&self, arg: Option<Option<Finite<f64>>>) -> ();
    fn PassOptionalNullableString(&self, arg: Option<Option<DOMString>>) -> ();
    fn PassOptionalNullableUsvstring(&self, arg: Option<Option<USVString>>) -> ();
    fn PassOptionalNullableByteString(&self, arg: Option<Option<ByteString>>) -> ();
    fn PassOptionalNullableInterface(&self, arg: Option<Option<&Blob<TH>>>) -> ();
    unsafe fn PassOptionalNullableObject(&self, cx: *mut JSContext, arg: Option<*mut JSObject>) -> ();
    fn PassOptionalNullableUnion(&self, arg: Option<Option<UnionTypes::HTMLElementOrLong<TH>>>) -> ();
    fn PassOptionalNullableUnion2(&self, data: Option<Option<UnionTypes::EventOrString<TH>>>) -> ();
    fn PassOptionalNullableUnion3(&self, arg: Option<Option<UnionTypes::StringOrLongSequence>>) -> ();
    fn PassOptionalNullableUnion4(&self, data: Option<Option<UnionTypes::LongSequenceOrBoolean>>) -> ();
    fn PassOptionalNullableUnion5(&self, bool: Option<Option<UnionTypes::UnsignedLongOrBoolean>>) -> ();
    fn PassOptionalNullableUnion6(&self, arg: Option<Option<UnionTypes::ByteStringOrLong>>) -> ();
    fn PassOptionalNullableCallbackFunction(&self, fun: Option<Option<Rc<Function<TH>>>>) -> ();
    fn PassOptionalNullableCallbackInterface(&self, listener: Option<Option<Rc<dom::bindings::codegen::Bindings::EventListenerBinding::EventListener<TH>>>>) -> ();
    fn PassOptionalNullableSequence(&self, seq: Option<Option<Vec<i32> >>) -> ();
    fn PassOptionalBooleanWithDefault(&self, arg: bool) -> ();
    fn PassOptionalByteWithDefault(&self, arg: i8) -> ();
    fn PassOptionalOctetWithDefault(&self, arg: u8) -> ();
    fn PassOptionalShortWithDefault(&self, arg: i16) -> ();
    fn PassOptionalUnsignedShortWithDefault(&self, arg: u16) -> ();
    fn PassOptionalLongWithDefault(&self, arg: i32) -> ();
    fn PassOptionalUnsignedLongWithDefault(&self, arg: u32) -> ();
    fn PassOptionalLongLongWithDefault(&self, arg: i64) -> ();
    fn PassOptionalUnsignedLongLongWithDefault(&self, arg: u64) -> ();
    fn PassOptionalBytestringWithDefault(&self, arg: ByteString) -> ();
    fn PassOptionalStringWithDefault(&self, arg: DOMString) -> ();
    fn PassOptionalUsvstringWithDefault(&self, arg: USVString) -> ();
    fn PassOptionalEnumWithDefault(&self, arg: TestEnum) -> ();
    fn PassOptionalNullableBooleanWithDefault(&self, arg: Option<bool>) -> ();
    fn PassOptionalNullableByteWithDefault(&self, arg: Option<i8>) -> ();
    fn PassOptionalNullableOctetWithDefault(&self, arg: Option<u8>) -> ();
    fn PassOptionalNullableShortWithDefault(&self, arg: Option<i16>) -> ();
    fn PassOptionalNullableUnsignedShortWithDefault(&self, arg: Option<u16>) -> ();
    fn PassOptionalNullableLongWithDefault(&self, arg: Option<i32>) -> ();
    fn PassOptionalNullableUnsignedLongWithDefault(&self, arg: Option<u32>) -> ();
    fn PassOptionalNullableLongLongWithDefault(&self, arg: Option<i64>) -> ();
    fn PassOptionalNullableUnsignedLongLongWithDefault(&self, arg: Option<u64>) -> ();
    fn PassOptionalNullableStringWithDefault(&self, arg: Option<DOMString>) -> ();
    fn PassOptionalNullableUsvstringWithDefault(&self, arg: Option<USVString>) -> ();
    fn PassOptionalNullableByteStringWithDefault(&self, arg: Option<ByteString>) -> ();
    fn PassOptionalNullableInterfaceWithDefault(&self, arg: Option<&Blob<TH>>) -> ();
    unsafe fn PassOptionalNullableObjectWithDefault(&self, cx: *mut JSContext, arg: *mut JSObject) -> ();
    fn PassOptionalNullableUnionWithDefault(&self, arg: Option<UnionTypes::HTMLElementOrLong<TH>>) -> ();
    fn PassOptionalNullableUnion2WithDefault(&self, data: Option<UnionTypes::EventOrString<TH>>) -> ();
    fn PassOptionalNullableCallbackInterfaceWithDefault(&self, listener: Option<Rc<dom::bindings::codegen::Bindings::EventListenerBinding::EventListener<TH>>>) -> ();
    unsafe fn PassOptionalAnyWithDefault(&self, cx: *mut JSContext, arg: HandleValue) -> ();
    fn PassOptionalNullableBooleanWithNonNullDefault(&self, arg: Option<bool>) -> ();
    fn PassOptionalNullableByteWithNonNullDefault(&self, arg: Option<i8>) -> ();
    fn PassOptionalNullableOctetWithNonNullDefault(&self, arg: Option<u8>) -> ();
    fn PassOptionalNullableShortWithNonNullDefault(&self, arg: Option<i16>) -> ();
    fn PassOptionalNullableUnsignedShortWithNonNullDefault(&self, arg: Option<u16>) -> ();
    fn PassOptionalNullableLongWithNonNullDefault(&self, arg: Option<i32>) -> ();
    fn PassOptionalNullableUnsignedLongWithNonNullDefault(&self, arg: Option<u32>) -> ();
    fn PassOptionalNullableLongLongWithNonNullDefault(&self, arg: Option<i64>) -> ();
    fn PassOptionalNullableUnsignedLongLongWithNonNullDefault(&self, arg: Option<u64>) -> ();
    fn PassOptionalNullableStringWithNonNullDefault(&self, arg: Option<DOMString>) -> ();
    fn PassOptionalNullableUsvstringWithNonNullDefault(&self, arg: Option<USVString>) -> ();
    fn PassOptionalOverloaded(&self, arg0: &TestBinding<TH>, arg1: u32, arg2: u32) -> DomRoot<TestBinding<TH>>;
    fn PassOptionalOverloaded_(&self, arg0: &Blob<TH>, arg1: u32) -> ();
    fn PassVariadicBoolean(&self, args: Vec<bool>) -> ();
    fn PassVariadicBooleanAndDefault(&self, arg: bool, args: Vec<bool>) -> ();
    fn PassVariadicByte(&self, args: Vec<i8>) -> ();
    fn PassVariadicOctet(&self, args: Vec<u8>) -> ();
    fn PassVariadicShort(&self, args: Vec<i16>) -> ();
    fn PassVariadicUnsignedShort(&self, args: Vec<u16>) -> ();
    fn PassVariadicLong(&self, args: Vec<i32>) -> ();
    fn PassVariadicUnsignedLong(&self, args: Vec<u32>) -> ();
    fn PassVariadicLongLong(&self, args: Vec<i64>) -> ();
    fn PassVariadicUnsignedLongLong(&self, args: Vec<u64>) -> ();
    fn PassVariadicUnrestrictedFloat(&self, args: Vec<f32>) -> ();
    fn PassVariadicFloat(&self, args: Vec<Finite<f32>>) -> ();
    fn PassVariadicUnrestrictedDouble(&self, args: Vec<f64>) -> ();
    fn PassVariadicDouble(&self, args: Vec<Finite<f64>>) -> ();
    fn PassVariadicString(&self, args: Vec<DOMString>) -> ();
    fn PassVariadicUsvstring(&self, args: Vec<USVString>) -> ();
    fn PassVariadicByteString(&self, args: Vec<ByteString>) -> ();
    fn PassVariadicEnum(&self, args: Vec<TestEnum>) -> ();
    fn PassVariadicInterface(&self, args: &[&Blob<TH>]) -> ();
    fn PassVariadicUnion(&self, args: Vec<UnionTypes::HTMLElementOrLong<TH>>) -> ();
    fn PassVariadicUnion2(&self, args: Vec<UnionTypes::EventOrString<TH>>) -> ();
    fn PassVariadicUnion3(&self, args: Vec<UnionTypes::BlobOrString<TH>>) -> ();
    fn PassVariadicUnion4(&self, args: Vec<UnionTypes::BlobOrBoolean<TH>>) -> ();
    fn PassVariadicUnion5(&self, args: Vec<UnionTypes::StringOrUnsignedLong>) -> ();
    fn PassVariadicUnion6(&self, args: Vec<UnionTypes::UnsignedLongOrBoolean>) -> ();
    fn PassVariadicUnion7(&self, args: Vec<UnionTypes::ByteStringOrLong>) -> ();
    unsafe fn PassVariadicAny(&self, cx: *mut JSContext, args: Vec<HandleValue>) -> ();
    unsafe fn PassVariadicObject(&self, cx: *mut JSContext, args: Vec<*mut JSObject>) -> ();
    fn PassSequenceSequence(&self, seq: Vec<Vec<i32>>) -> ();
    fn ReturnSequenceSequence(&self) -> Vec<Vec<i32>>;
    fn PassUnionSequenceSequence(&self, seq: UnionTypes::LongOrLongSequenceSequence) -> ();
    fn PassMozMap(&self, arg: MozMap<i32>) -> ();
    fn PassNullableMozMap(&self, arg: Option<MozMap<i32> >) -> ();
    fn PassMozMapOfNullableInts(&self, arg: MozMap<Option<i32>>) -> ();
    fn PassOptionalMozMapOfNullableInts(&self, arg: Option<MozMap<Option<i32>>>) -> ();
    fn PassOptionalNullableMozMapOfNullableInts(&self, arg: Option<Option<MozMap<Option<i32>> >>) -> ();
    fn PassCastableObjectMozMap(&self, arg: MozMap<DomRoot<TestBinding<TH>>>) -> ();
    fn PassNullableCastableObjectMozMap(&self, arg: MozMap<Option<DomRoot<TestBinding<TH>>>>) -> ();
    fn PassCastableObjectNullableMozMap(&self, arg: Option<MozMap<DomRoot<TestBinding<TH>>> >) -> ();
    fn PassNullableCastableObjectNullableMozMap(&self, arg: Option<MozMap<Option<DomRoot<TestBinding<TH>>>> >) -> ();
    fn PassOptionalMozMap(&self, arg: Option<MozMap<i32>>) -> ();
    fn PassOptionalNullableMozMap(&self, arg: Option<Option<MozMap<i32> >>) -> ();
    fn PassOptionalNullableMozMapWithDefaultValue(&self, arg: Option<MozMap<i32> >) -> ();
    fn PassOptionalObjectMozMap(&self, arg: Option<MozMap<DomRoot<TestBinding<TH>>>>) -> ();
    fn PassStringMozMap(&self, arg: MozMap<DOMString>) -> ();
    fn PassByteStringMozMap(&self, arg: MozMap<ByteString>) -> ();
    fn PassMozMapOfMozMaps(&self, arg: MozMap<MozMap<i32>>) -> ();
    fn PassMozMapUnion(&self, init: UnionTypes::LongOrStringByteStringRecord) -> ();
    fn PassMozMapUnion2(&self, init: UnionTypes::TestBindingOrStringByteStringRecord<TH>) -> ();
    fn PassMozMapUnion3(&self, init: UnionTypes::TestBindingOrByteStringSequenceSequenceOrStringByteStringRecord<TH>) -> ();
    fn ReceiveMozMap(&self) -> MozMap<i32>;
    fn ReceiveNullableMozMap(&self) -> Option<MozMap<i32>>;
    fn ReceiveMozMapOfNullableInts(&self) -> MozMap<Option<i32>>;
    fn ReceiveNullableMozMapOfNullableInts(&self) -> Option<MozMap<Option<i32>>>;
    fn ReceiveMozMapOfMozMaps(&self) -> MozMap<MozMap<i32>>;
    fn ReceiveAnyMozMap(&self) -> MozMap<JSVal>;
    fn BooleanMozPreference(&self, pref_name: DOMString) -> bool;
    fn StringMozPreference(&self, pref_name: DOMString) -> DOMString;
    fn PrefControlledAttributeDisabled(&self) -> bool;
    fn PrefControlledMethodDisabled(&self) -> ();
    fn AdvanceClock(&self, millis: i32, forceLayoutTick: bool) -> ();
    fn PrefControlledAttributeEnabled(&self) -> bool;
    fn PrefControlledMethodEnabled(&self) -> ();
    fn FuncControlledAttributeDisabled(&self) -> bool;
    fn FuncControlledMethodDisabled(&self) -> ();
    fn FuncControlledAttributeEnabled(&self) -> bool;
    fn FuncControlledMethodEnabled(&self) -> ();
    unsafe fn ReturnResolvedPromise(&self, cx: *mut JSContext, value: HandleValue) -> Fallible<Rc<Promise<TH>>, TH>;
    unsafe fn ReturnRejectedPromise(&self, cx: *mut JSContext, value: HandleValue) -> Fallible<Rc<Promise<TH>>, TH>;
    fn PromiseAttribute(&self) -> Rc<Promise<TH>>;
    fn AcceptPromise(&self, string: &Promise<TH>) -> ();
    fn PromiseNativeHandler(&self, resolve: Option<Rc<SimpleCallback<TH>>>, reject: Option<Rc<SimpleCallback<TH>>>) -> Rc<Promise<TH>>;
    unsafe fn PromiseResolveNative(&self, cx: *mut JSContext, p: &Promise<TH>, value: HandleValue) -> ();
    unsafe fn PromiseRejectNative(&self, cx: *mut JSContext, p: &Promise<TH>, value: HandleValue) -> ();
    fn PromiseRejectWithTypeError(&self, p: &Promise<TH>, message: USVString) -> ();
    fn ResolvePromiseDelayed(&self, p: &Promise<TH>, value: DOMString, ms: u64) -> ();
    fn Panic(&self) -> ();
    fn EntryGlobal(&self) -> DomRoot<GlobalScope<TH>>;
    fn IncumbentGlobal(&self) -> DomRoot<GlobalScope<TH>>;
    fn CrashHard(&self) -> ();
}
const sStaticMethods_specs: &'static [&'static[JSFunctionSpec]] = &[
&[
    JSFunctionSpec {
        name: b"receiveVoidStatic\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(receiveVoidStatic), info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]
,
&[
    JSFunctionSpec {
        name: b"prefControlledStaticMethodDisabled\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(prefControlledStaticMethodDisabled), info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]
,
&[
    JSFunctionSpec {
        name: b"prefControlledStaticMethodEnabled\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(prefControlledStaticMethodEnabled), info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]
,
&[
    JSFunctionSpec {
        name: b"funcControlledStaticMethodDisabled\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(funcControlledStaticMethodDisabled), info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]
,
&[
    JSFunctionSpec {
        name: b"funcControlledStaticMethodEnabled\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(funcControlledStaticMethodEnabled), info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]

];
const sStaticMethods: &'static [Guard<&'static [JSFunctionSpec]>] = &[
    Guard::new(Condition::Satisfied, sStaticMethods_specs[0]),
    Guard::new(Condition::Pref("dom.testbinding.prefcontrolled.enabled"), sStaticMethods_specs[1]),
    Guard::new(Condition::Pref("dom.testbinding.prefcontrolled2.enabled"), sStaticMethods_specs[2]),
    Guard::new(Condition::Func(TestBinding::condition_unsatisfied), sStaticMethods_specs[3]),
    Guard::new(Condition::Func(TestBinding::condition_satisfied), sStaticMethods_specs[4])
];
const sStaticAttributes_specs: &'static [&'static[JSPropertySpec]] = &[
&[
    JSPropertySpec {
        name: b"booleanAttributeStatic\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(get_booleanAttributeStatic), info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: Some(set_booleanAttributeStatic), info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]
,
&[
    JSPropertySpec {
        name: b"prefControlledStaticAttributeDisabled\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(get_prefControlledStaticAttributeDisabled), info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]
,
&[
    JSPropertySpec {
        name: b"prefControlledStaticAttributeEnabled\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(get_prefControlledStaticAttributeEnabled), info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]
,
&[
    JSPropertySpec {
        name: b"funcControlledStaticAttributeDisabled\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(get_funcControlledStaticAttributeDisabled), info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]
,
&[
    JSPropertySpec {
        name: b"funcControlledStaticAttributeEnabled\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(get_funcControlledStaticAttributeEnabled), info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]

];
const sStaticAttributes: &'static [Guard<&'static [JSPropertySpec]>] = &[
    Guard::new(Condition::Satisfied, sStaticAttributes_specs[0]),
    Guard::new(Condition::Pref("dom.testbinding.prefcontrolled.enabled"), sStaticAttributes_specs[1]),
    Guard::new(Condition::Pref("dom.testbinding.prefcontrolled2.enabled"), sStaticAttributes_specs[2]),
    Guard::new(Condition::Func(TestBinding::condition_unsatisfied), sStaticAttributes_specs[3]),
    Guard::new(Condition::Func(TestBinding::condition_satisfied), sStaticAttributes_specs[4])
];
const sMethods_specs: &'static [&'static[JSFunctionSpec]] = &[
&[
    JSFunctionSpec {
        name: b"methToBinaryRename\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &methToBinaryRename_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveVoid\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveVoid_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveBoolean\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveBoolean_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveByte\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveByte_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveOctet\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveOctet_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveShort\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveShort_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnsignedShort\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnsignedShort_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveLong_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnsignedLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnsignedLong_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveLongLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveLongLong_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnsignedLongLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnsignedLongLong_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnrestrictedFloat\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnrestrictedFloat_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveFloat\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveFloat_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnrestrictedDouble\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnrestrictedDouble_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveDouble\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveDouble_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveString\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveString_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUsvstring\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUsvstring_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveByteString\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveByteString_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveEnum\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveEnum_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveInterface\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveInterface_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveAny\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveAny_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveObject\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveObject_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnion\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnion_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnion2\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnion2_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnion3\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnion3_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnion4\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnion4_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnion5\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnion5_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnion6\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnion6_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnion7\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnion7_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnion8\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnion8_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnion9\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnion9_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnion10\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnion10_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnion11\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnion11_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveSequence\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveSequence_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveInterfaceSequence\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveInterfaceSequence_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableByte\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableByte_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableBoolean\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableBoolean_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableOctet\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableOctet_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableShort\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableShort_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableUnsignedShort\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableUnsignedShort_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableLong_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableUnsignedLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableUnsignedLong_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableLongLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableLongLong_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableUnsignedLongLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableUnsignedLongLong_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableUnrestrictedFloat\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableUnrestrictedFloat_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableFloat\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableFloat_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableUnrestrictedDouble\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableUnrestrictedDouble_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableDouble\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableDouble_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableString\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableString_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableUsvstring\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableUsvstring_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableByteString\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableByteString_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableEnum\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableEnum_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableInterface\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableInterface_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableObject\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableObject_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableUnion\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableUnion_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableUnion2\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableUnion2_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableUnion3\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableUnion3_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableUnion4\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableUnion4_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableUnion5\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableUnion5_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableUnion6\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableUnion6_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableSequence\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableSequence_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveTestDictionaryWithSuccessOnKeyword\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveTestDictionaryWithSuccessOnKeyword_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"dictMatchesPassedValues\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &dictMatchesPassedValues_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveUnionIdentity\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveUnionIdentity_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passBoolean\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passBoolean_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passByte\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passByte_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOctet\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOctet_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passShort\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passShort_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnsignedShort\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnsignedShort_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passLong_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnsignedLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnsignedLong_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passLongLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passLongLong_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnsignedLongLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnsignedLongLong_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnrestrictedFloat\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnrestrictedFloat_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passFloat\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passFloat_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnrestrictedDouble\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnrestrictedDouble_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passDouble\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passDouble_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passString\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passString_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUsvstring\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUsvstring_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passByteString\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passByteString_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passEnum\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passEnum_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passInterface\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passInterface_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passTypedArray\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passTypedArray_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passTypedArray2\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passTypedArray2_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passTypedArray3\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passTypedArray3_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnion\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnion_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnion2\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnion2_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnion3\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnion3_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnion4\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnion4_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnion5\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnion5_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnion6\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnion6_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnion7\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnion7_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnion8\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnion8_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnion9\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnion9_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnion10\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnion10_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnion11\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnion11_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnionWithTypedef\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnionWithTypedef_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnionWithTypedef2\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnionWithTypedef2_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passAny\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passAny_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passObject\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passObject_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passCallbackFunction\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passCallbackFunction_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passCallbackInterface\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passCallbackInterface_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passSequence\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passSequence_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passAnySequence\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passAnySequence_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"anySequencePassthrough\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &anySequencePassthrough_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passObjectSequence\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passObjectSequence_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passStringSequence\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passStringSequence_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passInterfaceSequence\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passInterfaceSequence_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOverloaded\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOverloaded_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableBoolean\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableBoolean_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableByte\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableByte_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableOctet\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableOctet_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableShort\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableShort_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableUnsignedShort\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableUnsignedShort_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableLong_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableUnsignedLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableUnsignedLong_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableLongLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableLongLong_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableUnsignedLongLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableUnsignedLongLong_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableUnrestrictedFloat\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableUnrestrictedFloat_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableFloat\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableFloat_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableUnrestrictedDouble\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableUnrestrictedDouble_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableDouble\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableDouble_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableString\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableString_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableUsvstring\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableUsvstring_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableByteString\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableByteString_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableInterface\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableInterface_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableObject\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableObject_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableTypedArray\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableTypedArray_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableUnion\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableUnion_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableUnion2\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableUnion2_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableUnion3\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableUnion3_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableUnion4\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableUnion4_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableUnion5\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableUnion5_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableUnion6\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableUnion6_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableCallbackFunction\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableCallbackFunction_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableCallbackInterface\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableCallbackInterface_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableSequence\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableSequence_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalBoolean\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalBoolean_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalByte\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalByte_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalOctet\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalOctet_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalShort\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalShort_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUnsignedShort\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUnsignedShort_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalLong_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUnsignedLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUnsignedLong_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalLongLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalLongLong_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUnsignedLongLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUnsignedLongLong_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUnrestrictedFloat\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUnrestrictedFloat_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalFloat\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalFloat_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUnrestrictedDouble\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUnrestrictedDouble_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalDouble\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalDouble_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalString\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalString_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUsvstring\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUsvstring_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalByteString\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalByteString_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalEnum\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalEnum_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalInterface\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalInterface_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUnion\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUnion_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUnion2\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUnion2_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUnion3\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUnion3_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUnion4\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUnion4_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUnion5\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUnion5_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUnion6\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUnion6_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalAny\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalAny_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalObject\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalObject_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalCallbackFunction\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalCallbackFunction_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalCallbackInterface\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalCallbackInterface_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalSequence\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalSequence_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableBoolean\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableBoolean_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableByte\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableByte_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableOctet\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableOctet_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableShort\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableShort_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnsignedShort\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnsignedShort_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableLong_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnsignedLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnsignedLong_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableLongLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableLongLong_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnsignedLongLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnsignedLongLong_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnrestrictedFloat\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnrestrictedFloat_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableFloat\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableFloat_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnrestrictedDouble\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnrestrictedDouble_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableDouble\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableDouble_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableString\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableString_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUsvstring\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUsvstring_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableByteString\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableByteString_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableInterface\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableInterface_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableObject\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableObject_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnion\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnion_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnion2\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnion2_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnion3\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnion3_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnion4\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnion4_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnion5\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnion5_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnion6\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnion6_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableCallbackFunction\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableCallbackFunction_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableCallbackInterface\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableCallbackInterface_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableSequence\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableSequence_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalBooleanWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalBooleanWithDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalByteWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalByteWithDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalOctetWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalOctetWithDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalShortWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalShortWithDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUnsignedShortWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUnsignedShortWithDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalLongWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalLongWithDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUnsignedLongWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUnsignedLongWithDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalLongLongWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalLongLongWithDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUnsignedLongLongWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUnsignedLongLongWithDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalBytestringWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalBytestringWithDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalStringWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalStringWithDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalUsvstringWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalUsvstringWithDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalEnumWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalEnumWithDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableBooleanWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableBooleanWithDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableByteWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableByteWithDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableOctetWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableOctetWithDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableShortWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableShortWithDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnsignedShortWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnsignedShortWithDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableLongWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableLongWithDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnsignedLongWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnsignedLongWithDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableLongLongWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableLongLongWithDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnsignedLongLongWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnsignedLongLongWithDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableStringWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableStringWithDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUsvstringWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUsvstringWithDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableByteStringWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableByteStringWithDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableInterfaceWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableInterfaceWithDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableObjectWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableObjectWithDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnionWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnionWithDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnion2WithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnion2WithDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableCallbackInterfaceWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableCallbackInterfaceWithDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalAnyWithDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalAnyWithDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableBooleanWithNonNullDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableBooleanWithNonNullDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableByteWithNonNullDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableByteWithNonNullDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableOctetWithNonNullDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableOctetWithNonNullDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableShortWithNonNullDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableShortWithNonNullDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnsignedShortWithNonNullDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnsignedShortWithNonNullDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableLongWithNonNullDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableLongWithNonNullDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnsignedLongWithNonNullDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnsignedLongWithNonNullDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableLongLongWithNonNullDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableLongLongWithNonNullDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUnsignedLongLongWithNonNullDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUnsignedLongLongWithNonNullDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableStringWithNonNullDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableStringWithNonNullDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableUsvstringWithNonNullDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableUsvstringWithNonNullDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalOverloaded\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalOverloaded_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicBoolean\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicBoolean_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicBooleanAndDefault\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicBooleanAndDefault_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicByte\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicByte_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicOctet\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicOctet_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicShort\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicShort_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicUnsignedShort\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicUnsignedShort_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicLong_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicUnsignedLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicUnsignedLong_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicLongLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicLongLong_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicUnsignedLongLong\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicUnsignedLongLong_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicUnrestrictedFloat\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicUnrestrictedFloat_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicFloat\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicFloat_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicUnrestrictedDouble\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicUnrestrictedDouble_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicDouble\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicDouble_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicString\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicString_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicUsvstring\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicUsvstring_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicByteString\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicByteString_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicEnum\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicEnum_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicInterface\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicInterface_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicUnion\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicUnion_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicUnion2\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicUnion2_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicUnion3\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicUnion3_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicUnion4\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicUnion4_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicUnion5\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicUnion5_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicUnion6\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicUnion6_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicUnion7\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicUnion7_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicAny\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicAny_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passVariadicObject\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passVariadicObject_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passSequenceSequence\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passSequenceSequence_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"returnSequenceSequence\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &returnSequenceSequence_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passUnionSequenceSequence\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passUnionSequenceSequence_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passMozMap\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passMozMap_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableMozMap\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableMozMap_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passMozMapOfNullableInts\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passMozMapOfNullableInts_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalMozMapOfNullableInts\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalMozMapOfNullableInts_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableMozMapOfNullableInts\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableMozMapOfNullableInts_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passCastableObjectMozMap\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passCastableObjectMozMap_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableCastableObjectMozMap\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableCastableObjectMozMap_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passCastableObjectNullableMozMap\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passCastableObjectNullableMozMap_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passNullableCastableObjectNullableMozMap\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passNullableCastableObjectNullableMozMap_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalMozMap\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalMozMap_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableMozMap\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableMozMap_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalNullableMozMapWithDefaultValue\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalNullableMozMapWithDefaultValue_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passOptionalObjectMozMap\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passOptionalObjectMozMap_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passStringMozMap\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passStringMozMap_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passByteStringMozMap\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passByteStringMozMap_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passMozMapOfMozMaps\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passMozMapOfMozMaps_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passMozMapUnion\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passMozMapUnion_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passMozMapUnion2\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passMozMapUnion2_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"passMozMapUnion3\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &passMozMapUnion3_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveMozMap\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveMozMap_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableMozMap\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableMozMap_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveMozMapOfNullableInts\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveMozMapOfNullableInts_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveNullableMozMapOfNullableInts\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveNullableMozMapOfNullableInts_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveMozMapOfMozMaps\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveMozMapOfMozMaps_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"receiveAnyMozMap\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &receiveAnyMozMap_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"BooleanMozPreference\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &BooleanMozPreference_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"StringMozPreference\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &StringMozPreference_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]
,
&[
    JSFunctionSpec {
        name: b"prefControlledMethodDisabled\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &prefControlledMethodDisabled_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]
,
&[
    JSFunctionSpec {
        name: b"advanceClock\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &advanceClock_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]
,
&[
    JSFunctionSpec {
        name: b"prefControlledMethodEnabled\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &prefControlledMethodEnabled_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]
,
&[
    JSFunctionSpec {
        name: b"funcControlledMethodDisabled\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &funcControlledMethodDisabled_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]
,
&[
    JSFunctionSpec {
        name: b"funcControlledMethodEnabled\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &funcControlledMethodEnabled_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]
,
&[
    JSFunctionSpec {
        name: b"returnResolvedPromise\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &returnResolvedPromise_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"returnRejectedPromise\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &returnRejectedPromise_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"acceptPromise\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &acceptPromise_methodinfo as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"promiseNativeHandler\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &promiseNativeHandler_methodinfo as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"promiseResolveNative\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &promiseResolveNative_methodinfo as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"promiseRejectNative\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &promiseRejectNative_methodinfo as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"promiseRejectWithTypeError\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &promiseRejectWithTypeError_methodinfo as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"resolvePromiseDelayed\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &resolvePromiseDelayed_methodinfo as *const _ as *const JSJitInfo },
        nargs: 3,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"panic\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &panic_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"entryGlobal\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &entryGlobal_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"incumbentGlobal\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &incumbentGlobal_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]
,
&[
    JSFunctionSpec {
        name: b"crashHard\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &crashHard_methodinfo as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]

];
const sMethods: &'static [Guard<&'static [JSFunctionSpec]>] = &[
    Guard::new(Condition::Satisfied, sMethods_specs[0]),
    Guard::new(Condition::Pref("dom.testbinding.prefcontrolled.enabled"), sMethods_specs[1]),
    Guard::new(Condition::Pref("layout.animations.test.enabled"), sMethods_specs[2]),
    Guard::new(Condition::Pref("dom.testbinding.prefcontrolled2.enabled"), sMethods_specs[3]),
    Guard::new(Condition::Func(TestBinding::condition_unsatisfied), sMethods_specs[4]),
    Guard::new(Condition::Func(TestBinding::condition_satisfied), sMethods_specs[5]),
    Guard::new(Condition::Satisfied, sMethods_specs[6]),
    Guard::new(Condition::Pref("dom.testable_crash.enabled"), sMethods_specs[7])
];
const sAttributes_specs: &'static [&'static[JSPropertySpec]] = &[
&[
    JSPropertySpec {
        name: b"booleanAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &booleanAttribute_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &booleanAttribute_setterinfo }
    },
    JSPropertySpec {
        name: b"byteAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &byteAttribute_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &byteAttribute_setterinfo }
    },
    JSPropertySpec {
        name: b"octetAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &octetAttribute_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &octetAttribute_setterinfo }
    },
    JSPropertySpec {
        name: b"shortAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &shortAttribute_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &shortAttribute_setterinfo }
    },
    JSPropertySpec {
        name: b"unsignedShortAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &unsignedShortAttribute_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &unsignedShortAttribute_setterinfo }
    },
    JSPropertySpec {
        name: b"longAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &longAttribute_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &longAttribute_setterinfo }
    },
    JSPropertySpec {
        name: b"unsignedLongAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &unsignedLongAttribute_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &unsignedLongAttribute_setterinfo }
    },
    JSPropertySpec {
        name: b"longLongAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &longLongAttribute_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &longLongAttribute_setterinfo }
    },
    JSPropertySpec {
        name: b"unsignedLongLongAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &unsignedLongLongAttribute_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &unsignedLongLongAttribute_setterinfo }
    },
    JSPropertySpec {
        name: b"unrestrictedFloatAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &unrestrictedFloatAttribute_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &unrestrictedFloatAttribute_setterinfo }
    },
    JSPropertySpec {
        name: b"floatAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &floatAttribute_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &floatAttribute_setterinfo }
    },
    JSPropertySpec {
        name: b"unrestrictedDoubleAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &unrestrictedDoubleAttribute_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &unrestrictedDoubleAttribute_setterinfo }
    },
    JSPropertySpec {
        name: b"doubleAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &doubleAttribute_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &doubleAttribute_setterinfo }
    },
    JSPropertySpec {
        name: b"stringAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &stringAttribute_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &stringAttribute_setterinfo }
    },
    JSPropertySpec {
        name: b"usvstringAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &usvstringAttribute_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &usvstringAttribute_setterinfo }
    },
    JSPropertySpec {
        name: b"byteStringAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &byteStringAttribute_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &byteStringAttribute_setterinfo }
    },
    JSPropertySpec {
        name: b"enumAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &enumAttribute_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &enumAttribute_setterinfo }
    },
    JSPropertySpec {
        name: b"interfaceAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &interfaceAttribute_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &interfaceAttribute_setterinfo }
    },
    JSPropertySpec {
        name: b"unionAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &unionAttribute_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &unionAttribute_setterinfo }
    },
    JSPropertySpec {
        name: b"union2Attribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &union2Attribute_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &union2Attribute_setterinfo }
    },
    JSPropertySpec {
        name: b"union3Attribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &union3Attribute_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &union3Attribute_setterinfo }
    },
    JSPropertySpec {
        name: b"union4Attribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &union4Attribute_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &union4Attribute_setterinfo }
    },
    JSPropertySpec {
        name: b"union5Attribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &union5Attribute_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &union5Attribute_setterinfo }
    },
    JSPropertySpec {
        name: b"union6Attribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &union6Attribute_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &union6Attribute_setterinfo }
    },
    JSPropertySpec {
        name: b"union7Attribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &union7Attribute_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &union7Attribute_setterinfo }
    },
    JSPropertySpec {
        name: b"union8Attribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &union8Attribute_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &union8Attribute_setterinfo }
    },
    JSPropertySpec {
        name: b"union9Attribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &union9Attribute_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &union9Attribute_setterinfo }
    },
    JSPropertySpec {
        name: b"arrayAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &arrayAttribute_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"anyAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &anyAttribute_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &anyAttribute_setterinfo }
    },
    JSPropertySpec {
        name: b"objectAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &objectAttribute_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &objectAttribute_setterinfo }
    },
    JSPropertySpec {
        name: b"booleanAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &booleanAttributeNullable_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &booleanAttributeNullable_setterinfo }
    },
    JSPropertySpec {
        name: b"byteAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &byteAttributeNullable_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &byteAttributeNullable_setterinfo }
    },
    JSPropertySpec {
        name: b"octetAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &octetAttributeNullable_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &octetAttributeNullable_setterinfo }
    },
    JSPropertySpec {
        name: b"shortAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &shortAttributeNullable_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &shortAttributeNullable_setterinfo }
    },
    JSPropertySpec {
        name: b"unsignedShortAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &unsignedShortAttributeNullable_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &unsignedShortAttributeNullable_setterinfo }
    },
    JSPropertySpec {
        name: b"longAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &longAttributeNullable_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &longAttributeNullable_setterinfo }
    },
    JSPropertySpec {
        name: b"unsignedLongAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &unsignedLongAttributeNullable_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &unsignedLongAttributeNullable_setterinfo }
    },
    JSPropertySpec {
        name: b"longLongAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &longLongAttributeNullable_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &longLongAttributeNullable_setterinfo }
    },
    JSPropertySpec {
        name: b"unsignedLongLongAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &unsignedLongLongAttributeNullable_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &unsignedLongLongAttributeNullable_setterinfo }
    },
    JSPropertySpec {
        name: b"unrestrictedFloatAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &unrestrictedFloatAttributeNullable_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &unrestrictedFloatAttributeNullable_setterinfo }
    },
    JSPropertySpec {
        name: b"floatAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &floatAttributeNullable_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &floatAttributeNullable_setterinfo }
    },
    JSPropertySpec {
        name: b"unrestrictedDoubleAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &unrestrictedDoubleAttributeNullable_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &unrestrictedDoubleAttributeNullable_setterinfo }
    },
    JSPropertySpec {
        name: b"doubleAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &doubleAttributeNullable_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &doubleAttributeNullable_setterinfo }
    },
    JSPropertySpec {
        name: b"stringAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &stringAttributeNullable_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &stringAttributeNullable_setterinfo }
    },
    JSPropertySpec {
        name: b"usvstringAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &usvstringAttributeNullable_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &usvstringAttributeNullable_setterinfo }
    },
    JSPropertySpec {
        name: b"byteStringAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &byteStringAttributeNullable_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &byteStringAttributeNullable_setterinfo }
    },
    JSPropertySpec {
        name: b"enumAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &enumAttributeNullable_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"interfaceAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &interfaceAttributeNullable_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &interfaceAttributeNullable_setterinfo }
    },
    JSPropertySpec {
        name: b"interfaceAttributeWeak\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &interfaceAttributeWeak_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &interfaceAttributeWeak_setterinfo }
    },
    JSPropertySpec {
        name: b"objectAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &objectAttributeNullable_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &objectAttributeNullable_setterinfo }
    },
    JSPropertySpec {
        name: b"unionAttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &unionAttributeNullable_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &unionAttributeNullable_setterinfo }
    },
    JSPropertySpec {
        name: b"union2AttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &union2AttributeNullable_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &union2AttributeNullable_setterinfo }
    },
    JSPropertySpec {
        name: b"union3AttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &union3AttributeNullable_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &union3AttributeNullable_setterinfo }
    },
    JSPropertySpec {
        name: b"union4AttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &union4AttributeNullable_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &union4AttributeNullable_setterinfo }
    },
    JSPropertySpec {
        name: b"union5AttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &union5AttributeNullable_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &union5AttributeNullable_setterinfo }
    },
    JSPropertySpec {
        name: b"union6AttributeNullable\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &union6AttributeNullable_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &union6AttributeNullable_setterinfo }
    },
    JSPropertySpec {
        name: b"attrToBinaryRename\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &attrToBinaryRename_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &attrToBinaryRename_setterinfo }
    },
    JSPropertySpec {
        name: b"attr-to-binary-rename\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &attr_to_binary_rename_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &attr_to_binary_rename_setterinfo }
    },
    JSPropertySpec {
        name: b"attr-to-automatically-rename\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &attr_to_automatically_rename_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &attr_to_automatically_rename_setterinfo }
    },
    JSPropertySpec {
        name: b"forwardedAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &forwardedAttribute_getterinfo },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &forwardedAttribute_setterinfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]
,
&[
    JSPropertySpec {
        name: b"prefControlledAttributeDisabled\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &prefControlledAttributeDisabled_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]
,
&[
    JSPropertySpec {
        name: b"prefControlledAttributeEnabled\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &prefControlledAttributeEnabled_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]
,
&[
    JSPropertySpec {
        name: b"funcControlledAttributeDisabled\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &funcControlledAttributeDisabled_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]
,
&[
    JSPropertySpec {
        name: b"funcControlledAttributeEnabled\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &funcControlledAttributeEnabled_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]
,
&[
    JSPropertySpec {
        name: b"promiseAttribute\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &promiseAttribute_getterinfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]

];
const sAttributes: &'static [Guard<&'static [JSPropertySpec]>] = &[
    Guard::new(Condition::Satisfied, sAttributes_specs[0]),
    Guard::new(Condition::Pref("dom.testbinding.prefcontrolled.enabled"), sAttributes_specs[1]),
    Guard::new(Condition::Pref("dom.testbinding.prefcontrolled2.enabled"), sAttributes_specs[2]),
    Guard::new(Condition::Func(TestBinding::condition_unsatisfied), sAttributes_specs[3]),
    Guard::new(Condition::Func(TestBinding::condition_satisfied), sAttributes_specs[4]),
    Guard::new(Condition::Satisfied, sAttributes_specs[5])
];
const sConstants_specs: &'static [&'static[ConstantSpec]] = &[
&[
    ConstantSpec { name: b"constantInt64\0", value: ConstantVal::DoubleVal(-1 as f64) },
    ConstantSpec { name: b"constantUint64\0", value: ConstantVal::DoubleVal(1 as f64) },
    ConstantSpec { name: b"constantFloat32\0", value: ConstantVal::DoubleVal(1.0 as f64) },
    ConstantSpec { name: b"constantFloat64\0", value: ConstantVal::DoubleVal(1.0 as f64) },
    ConstantSpec { name: b"constantUnrestrictedFloat32\0", value: ConstantVal::DoubleVal(1.0 as f64) },
    ConstantSpec { name: b"constantUnrestrictedFloat64\0", value: ConstantVal::DoubleVal(1.0 as f64) }]
,
&[
    ConstantSpec { name: b"prefControlledConstDisabled\0", value: ConstantVal::IntVal(0) }]
,
&[
    ConstantSpec { name: b"prefControlledConstEnabled\0", value: ConstantVal::IntVal(0) }]
,
&[
    ConstantSpec { name: b"funcControlledConstDisabled\0", value: ConstantVal::IntVal(0) }]
,
&[
    ConstantSpec { name: b"funcControlledConstEnabled\0", value: ConstantVal::IntVal(0) }]

];
const sConstants: &'static [Guard<&'static [ConstantSpec]>] = &[
    Guard::new(Condition::Satisfied, sConstants_specs[0]),
    Guard::new(Condition::Pref("dom.testbinding.prefcontrolled.enabled"), sConstants_specs[1]),
    Guard::new(Condition::Pref("dom.testbinding.prefcontrolled2.enabled"), sConstants_specs[2]),
    Guard::new(Condition::Func(TestBinding::condition_unsatisfied), sConstants_specs[3]),
    Guard::new(Condition::Func(TestBinding::condition_satisfied), sConstants_specs[4])
];

pub unsafe fn GetProtoObject<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject, mut rval: MutableHandleObject) {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    assert!(((*get_object_class(global.get())).flags & JSCLASS_DOM_GLOBAL) != 0);

    /* Check to see whether the interface objects are already installed */
    let proto_or_iface_array = get_proto_or_iface_array(global.get());
    rval.set((*proto_or_iface_array)[PrototypeList::ID::TestBinding as usize]);
    if !rval.get().is_null() {
        return;
    }

    CreateInterfaceObjects(cx, global, proto_or_iface_array);
    rval.set((*proto_or_iface_array)[PrototypeList::ID::TestBinding as usize]);
    assert!(!rval.get().is_null());

}

static PrototypeClass: JSClass = JSClass {
    name: b"TestBindingPrototype\0" as *const u8 as *const libc::c_char,
    flags:
        // JSCLASS_HAS_RESERVED_SLOTS(0)
        (0 & JSCLASS_RESERVED_SLOTS_MASK) << JSCLASS_RESERVED_SLOTS_SHIFT,
    cOps: 0 as *const _,
    reserved: [0 as *mut os::raw::c_void; 3]
};

unsafe extern fn _constructor<TH: TypeHolderTrait>
(cx: *mut JSContext, argc: u32, vp: *mut JSVal) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let global = GlobalScope::from_object(JS_CALLEE(cx, vp).to_object());
        let args = CallArgs::from_vp(vp, argc);

        let argcount = cmp::min(argc, 1);
        match argcount {
            0 => {
                let result: Result<DomRoot<TestBinding<TH>>, Error> = TestBinding::Constructor(&global);
                let result = match result {
                    Ok(result) => result,
                    Err(e) => {
                        throw_dom_exception(cx, global.upcast::<GlobalScope<TH>>(), e);
                        return false;
                    },
                };

                (result).to_jsval(cx, args.rval());
                return true;
            }
            1 => {
                if args.get(0).get().is_object() && is_array_like(cx, args.get(0)) {
                    let arg0: Vec<f64> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                        Ok(ConversionResult::Success(value)) => value,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     },
                    };
                    let result: Result<DomRoot<TestBinding<TH>>, Error> = TestBinding::Constructor_(&global, arg0);
                    let result = match result {
                        Ok(result) => result,
                        Err(e) => {
                            throw_dom_exception(cx, global.upcast::<GlobalScope<TH>>(), e);
                            return false;
                        },
                    };

                    (result).to_jsval(cx, args.rval());
                    return true;
                }
                let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let result: Result<DomRoot<TestBinding<TH>>, Error> = TestBinding::Constructor__(&global, arg0);
                let result = match result {
                    Ok(result) => result,
                    Err(e) => {
                        throw_dom_exception(cx, global.upcast::<GlobalScope<TH>>(), e);
                        return false;
                    },
                };

                (result).to_jsval(cx, args.rval());
                return true;
            }
            _ => {
                throw_type_error(cx, "Not enough arguments to \"TestBinding.constructor\".");
                return false;
            }
        }
    }), false);
}

static INTERFACE_OBJECT_CLASS: NonCallbackInterfaceObjectClass =
    NonCallbackInterfaceObjectClass::new(
        &InterfaceConstructorBehavior::call(_constructor),
        b"function TestBinding() {\n    [native code]\n}",
        PrototypeList::ID::TestBinding,
        0);

pub unsafe fn GetConstructorObject<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject, mut rval: MutableHandleObject) {
    /* Get the interface object for this class.  This will create the object as
       needed. */
    assert!(((*get_object_class(global.get())).flags & JSCLASS_DOM_GLOBAL) != 0);

    /* Check to see whether the interface objects are already installed */
    let proto_or_iface_array = get_proto_or_iface_array(global.get());
    rval.set((*proto_or_iface_array)[PrototypeList::Constructor::TestBinding as usize]);
    if !rval.get().is_null() {
        return;
    }

    CreateInterfaceObjects(cx, global, proto_or_iface_array);
    rval.set((*proto_or_iface_array)[PrototypeList::Constructor::TestBinding as usize]);
    assert!(!rval.get().is_null());

}

pub unsafe fn DefineDOMInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject) {
    assert!(!global.get().is_null());

    if !ConstructorEnabled(cx, global) {
        return;
    }

    rooted!(in(cx) let mut proto = ptr::null_mut::<JSObject>());
    GetProtoObject(cx, global, proto.handle_mut());
    assert!(!proto.is_null());
}

unsafe fn ConstructorEnabled<TH: TypeHolderTrait>
(aCx: *mut JSContext, aObj: HandleObject) -> bool {
    is_exposed_in(aObj, InterfaceObjectMap::Globals::DEDICATED_WORKER_GLOBAL_SCOPE | InterfaceObjectMap::Globals::SERVICE_WORKER_GLOBAL_SCOPE | InterfaceObjectMap::Globals::WINDOW) &&
    PREFS.get("dom.testbinding.enabled").as_boolean().unwrap_or(false)
}

unsafe fn CreateInterfaceObjects<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject, cache: *mut ProtoOrIfaceArray) {
    rooted!(in(cx) let mut prototype_proto = ptr::null_mut::<JSObject>());
    prototype_proto.set(JS_GetObjectPrototype(cx, global));
    assert!(!prototype_proto.is_null());

    rooted!(in(cx) let mut prototype = ptr::null_mut::<JSObject>());
    create_interface_prototype_object(cx,
                                      prototype_proto.handle().into(),
                                      &PrototypeClass,
                                      sMethods,
                                      sAttributes,
                                      sConstants,
                                      &[],
                                      prototype.handle_mut().into());
    assert!(!prototype.is_null());
    assert!((*cache)[PrototypeList::ID::TestBinding as usize].is_null());
    (*cache)[PrototypeList::ID::TestBinding as usize] = prototype.get();
    <*mut JSObject>::post_barrier((*cache).as_mut_ptr().offset(PrototypeList::ID::TestBinding as isize),
                                  ptr::null_mut(),
                                  prototype.get());


    rooted!(in(cx) let interface_proto = JS_GetFunctionPrototype(cx, global));
    assert!(!interface_proto.is_null());

    rooted!(in(cx) let mut interface = ptr::null_mut::<JSObject>());
    create_noncallback_interface_object(cx,
                                        global.into(),
                                        interface_proto.handle(),
                                        &INTERFACE_OBJECT_CLASS,
                                        sStaticMethods,
                                        sStaticAttributes,
                                        sConstants,
                                        prototype.handle(),
                                        b"TestBinding\0",
                                        0,
                                        interface.handle_mut());
    assert!(!interface.is_null());
    assert!((*cache)[PrototypeList::Constructor::TestBinding as usize].is_null());
    (*cache)[PrototypeList::Constructor::TestBinding as usize] = interface.get();
    <*mut JSObject>::post_barrier((*cache).as_mut_ptr().offset(PrototypeList::Constructor::TestBinding as isize),
                                  ptr::null_mut(),
                                  interface.get());

}
} // mod TestBindingBinding


