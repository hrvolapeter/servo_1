/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */

#![allow(non_camel_case_types,non_upper_case_globals,unused_imports,unused_variables,unused_assignments,unused_mut)]
use dom;
use dom::bindings;
use dom::bindings::callback::CallSetup;
use dom::bindings::callback::CallbackContainer;
use dom::bindings::callback::CallbackFunction;
use dom::bindings::callback::CallbackInterface;
use dom::bindings::callback::CallbackObject;
use dom::bindings::callback::ExceptionHandling;
use dom::bindings::callback::wrap_call_this_object;
use dom::bindings::codegen::InterfaceObjectMap;
use dom::bindings::codegen::PrototypeList;
use dom::bindings::codegen::RegisterBindings;
use dom::bindings::codegen::UnionTypes;
use dom::bindings::constant::ConstantSpec;
use dom::bindings::constant::ConstantVal;
use dom::bindings::conversions::ConversionBehavior;
use dom::bindings::conversions::ConversionResult;
use dom::bindings::conversions::DOM_OBJECT_SLOT;
use dom::bindings::conversions::FromJSValConvertible;
use dom::bindings::conversions::IDLInterface;
use dom::bindings::conversions::StringificationBehavior;
use dom::bindings::conversions::ToJSValConvertible;
use dom::bindings::conversions::is_array_like;
use dom::bindings::conversions::jsid_to_string;
use dom::bindings::conversions::native_from_handlevalue;
use dom::bindings::conversions::native_from_object;
use dom::bindings::conversions::private_from_object;
use dom::bindings::conversions::root_from_handleobject;
use dom::bindings::conversions::root_from_handlevalue;
use dom::bindings::conversions::root_from_object;
use dom::bindings::error::Error;
use dom::bindings::error::Error::JSFailed;
use dom::bindings::error::ErrorResult;
use dom::bindings::error::Fallible;
use dom::bindings::error::throw_dom_exception;
use dom::bindings::guard::Condition;
use dom::bindings::guard::Guard;
use dom::bindings::htmlconstructor::html_constructor;
use dom::bindings::htmlconstructor::pop_current_element_queue;
use dom::bindings::htmlconstructor::push_new_element_queue;
use dom::bindings::inheritance::Castable;
use dom::bindings::interface::ConstructorClassHook;
use dom::bindings::interface::InterfaceConstructorBehavior;
use dom::bindings::interface::NonCallbackInterfaceObjectClass;
use dom::bindings::interface::create_callback_interface_object;
use dom::bindings::interface::create_global_object;
use dom::bindings::interface::create_interface_prototype_object;
use dom::bindings::interface::create_named_constructors;
use dom::bindings::interface::create_noncallback_interface_object;
use dom::bindings::interface::define_guarded_constants;
use dom::bindings::interface::define_guarded_methods;
use dom::bindings::interface::define_guarded_properties;
use dom::bindings::interface::is_exposed_in;
use dom::bindings::iterable::Iterable;
use dom::bindings::iterable::IteratorType;
use dom::bindings::mozmap::MozMap;
use dom::bindings::namespace::NamespaceObjectClass;
use dom::bindings::namespace::create_namespace_object;
use dom::bindings::num::Finite;
use dom::bindings::proxyhandler;
use dom::bindings::proxyhandler::ensure_expando_object;
use dom::bindings::proxyhandler::fill_property_descriptor;
use dom::bindings::proxyhandler::get_expando_object;
use dom::bindings::proxyhandler::get_property_descriptor;
use dom::bindings::reflector::DomObject;
use dom::bindings::reflector::MutDomObject;
use dom::bindings::root::Dom;
use dom::bindings::root::DomRoot;
use dom::bindings::root::OptionalHeapSetter;
use dom::bindings::root::RootedReference;
use dom::bindings::str::ByteString;
use dom::bindings::str::DOMString;
use dom::bindings::str::USVString;
use dom::bindings::trace::JSTraceable;
use dom::bindings::trace::RootedTraceable;
use dom::bindings::trace::RootedTraceableBox;
use dom::bindings::utils::AsVoidPtr;
use dom::bindings::utils::DOMClass;
use dom::bindings::utils::DOMJSClass;
use dom::bindings::utils::DOM_PROTO_UNFORGEABLE_HOLDER_SLOT;
use dom::bindings::utils::JSCLASS_DOM_GLOBAL;
use dom::bindings::utils::ProtoOrIfaceArray;
use dom::bindings::utils::enumerate_global;
use dom::bindings::utils::finalize_global;
use dom::bindings::utils::find_enum_value;
use dom::bindings::utils::generic_getter;
use dom::bindings::utils::generic_lenient_getter;
use dom::bindings::utils::generic_lenient_setter;
use dom::bindings::utils::generic_method;
use dom::bindings::utils::generic_setter;
use dom::bindings::utils::get_array_index_from_id;
use dom::bindings::utils::get_dictionary_property;
use dom::bindings::utils::get_property_on_prototype;
use dom::bindings::utils::get_proto_or_iface_array;
use dom::bindings::utils::has_property_on_prototype;
use dom::bindings::utils::is_platform_object;
use dom::bindings::utils::resolve_global;
use dom::bindings::utils::set_dictionary_property;
use dom::bindings::utils::trace_global;
use dom::bindings::weakref::DOM_WEAK_SLOT;
use dom::bindings::weakref::WeakBox;
use dom::bindings::weakref::WeakReferenceable;
use dom::globalscope::GlobalScope;
use dom::windowproxy::WindowProxy;
use js;
use js::JSCLASS_GLOBAL_SLOT_COUNT;
use js::JSCLASS_IS_DOMJSCLASS;
use js::JSCLASS_IS_GLOBAL;
use js::JSCLASS_RESERVED_SLOTS_MASK;
use js::JS_CALLEE;
use js::error::throw_internal_error;
use js::error::throw_type_error;
use js::glue::AppendToAutoIdVector;
use js::glue::CallJitGetterOp;
use js::glue::CallJitMethodOp;
use js::glue::CallJitSetterOp;
use js::glue::CreateProxyHandler;
use js::glue::GetProxyPrivate;
use js::glue::ProxyTraps;
use js::glue::RUST_JSID_IS_INT;
use js::glue::RUST_JSID_IS_STRING;
use js::glue::RUST_SYMBOL_TO_JSID;
use js::glue::UnwrapObject;
use js::glue::int_to_jsid;
use js::jsapi::AutoIdVector;
use js::jsapi::CallArgs;
use js::jsapi::CurrentGlobalOrNull;
use js::jsapi::FreeOp;
use js::jsapi::GetWellKnownSymbol;
use js::jsapi::Handle as RawHandle;
use js::jsapi::HandleId as RawHandleId;
use js::jsapi::HandleObject as RawHandleObject;
use js::jsapi::HandleValue as RawHandleValue;
use js::jsapi::HandleValueArray;
use js::jsapi::Heap;
use js::jsapi::INTERNED_STRING_TO_JSID;
use js::jsapi::IsCallable;
use js::jsapi::JSAutoCompartment;
use js::jsapi::JSCLASS_RESERVED_SLOTS_SHIFT;
use js::jsapi::JSClass;
use js::jsapi::JSContext;
use js::jsapi::JSFreeOp;
use js::jsapi::JSFunctionSpec;
use js::jsapi::JSITER_HIDDEN;
use js::jsapi::JSITER_OWNONLY;
use js::jsapi::JSITER_SYMBOLS;
use js::jsapi::JSJitGetterCallArgs;
use js::jsapi::JSJitInfo;
use js::jsapi::JSJitInfo_AliasSet;
use js::jsapi::JSJitInfo_ArgType;
use js::jsapi::JSJitInfo_OpType;
use js::jsapi::JSJitMethodCallArgs;
use js::jsapi::JSJitSetterCallArgs;
use js::jsapi::JSNative;
use js::jsapi::JSNativeWrapper;
use js::jsapi::JSObject;
use js::jsapi::JSPROP_ENUMERATE;
use js::jsapi::JSPROP_PERMANENT;
use js::jsapi::JSPROP_READONLY;
use js::jsapi::JSPROP_SHARED;
use js::jsapi::JSPropertySpec;
use js::jsapi::JSString;
use js::jsapi::JSTracer;
use js::jsapi::JSType;
use js::jsapi::JSTypedMethodJitInfo;
use js::jsapi::JSValueType;
use js::jsapi::JS_AtomizeAndPinString;
use js::jsapi::JS_ForwardGetPropertyTo;
use js::jsapi::JS_GetErrorPrototype;
use js::jsapi::JS_GetGlobalForObject;
use js::jsapi::JS_GetIteratorPrototype;
use js::jsapi::JS_GetPropertyById;
use js::jsapi::JS_GetPropertyDescriptorById;
use js::jsapi::JS_GetReservedSlot;
use js::jsapi::JS_HasProperty;
use js::jsapi::JS_HasPropertyById;
use js::jsapi::JS_NewObject;
use js::jsapi::JS_SetReservedSlot;
use js::jsapi::MutableHandle as RawMutableHandle;
use js::jsapi::MutableHandleObject as RawMutableHandleObject;
use js::jsapi::MutableHandleValue as RawMutableHandleValue;
use js::jsapi::ObjectOpResult;
use js::jsapi::PropertyDescriptor;
use js::jsapi::Rooted;
use js::jsapi::RootedId;
use js::jsapi::RootedObject;
use js::jsapi::RootedString;
use js::jsapi::SymbolCode;
use js::jsapi::jsid;
use js::jsval::JSVal;
use js::jsval::NullValue;
use js::jsval::ObjectOrNullValue;
use js::jsval::ObjectValue;
use js::jsval::PrivateValue;
use js::jsval::UndefinedValue;
use js::panic::maybe_resume_unwind;
use js::panic::wrap_panic;
use js::rust::CustomAutoRooterGuard;
use js::rust::GCMethods;
use js::rust::Handle;
use js::rust::HandleId;
use js::rust::HandleObject;
use js::rust::HandleValue;
use js::rust::MutableHandle;
use js::rust::MutableHandleObject;
use js::rust::MutableHandleValue;
use js::rust::define_methods;
use js::rust::define_properties;
use js::rust::get_object_class;
use js::rust::wrappers::Call;
use js::rust::wrappers::GetPropertyKeys;
use js::rust::wrappers::JS_CallFunctionValue;
use js::rust::wrappers::JS_CopyPropertiesFrom;
use js::rust::wrappers::JS_DefineProperty;
use js::rust::wrappers::JS_DefinePropertyById2;
use js::rust::wrappers::JS_GetFunctionPrototype;
use js::rust::wrappers::JS_GetObjectPrototype;
use js::rust::wrappers::JS_GetProperty;
use js::rust::wrappers::JS_InitializePropertiesFromCompatibleNativeObject;
use js::rust::wrappers::JS_NewObjectWithGivenProto;
use js::rust::wrappers::JS_NewObjectWithoutMetadata;
use js::rust::wrappers::JS_ObjectIsDate;
use js::rust::wrappers::JS_SetImmutablePrototype;
use js::rust::wrappers::JS_SetProperty;
use js::rust::wrappers::JS_SetPrototype;
use js::rust::wrappers::JS_SplicePrototype;
use js::rust::wrappers::JS_WrapObject;
use js::rust::wrappers::JS_WrapValue;
use js::rust::wrappers::NewProxyObject;
use js::typedarray;
use libc;
use malloc_size_of::MallocSizeOfOps;
use mem::malloc_size_of_including_raw_self;
use servo_config::prefs::PREFS;
use std::borrow::ToOwned;
use std::cmp;
use std::default::Default;
use std::ffi::CString;
use std::mem;
use std::num;
use std::os;
use std::os::raw::c_void;
use std::panic;
use std::ptr;
use std::ptr::NonNull;
use std::rc;
use std::rc::Rc;
use std::str;
use typeholder::TypeHolderTrait;

#[repr(usize)]
#[derive(Copy, Clone, Debug, JSTraceable, MallocSizeOf, PartialEq)]
pub enum ScrollBehavior {
    Auto,
    Instant,
    Smooth
}
pub mod ScrollBehaviorValues {
    use dom::bindings::conversions::ToJSValConvertible;
    use js::jsapi::JSContext;
    use js::rust::MutableHandleValue;
    use js::jsval::JSVal;

    pub const pairs: &'static [(&'static str, super::ScrollBehavior)] = &[
        ("auto", super::ScrollBehavior::Auto),
        ("instant", super::ScrollBehavior::Instant),
        ("smooth", super::ScrollBehavior::Smooth),
    ];

    impl super::ScrollBehavior {
        pub fn as_str(&self) -> &'static str {
            pairs[*self as usize].0
        }
    }

    impl Default for super::ScrollBehavior {
        fn default() -> super::ScrollBehavior {
            pairs[0].1
        }
    }

    impl ToJSValConvertible for super::ScrollBehavior {
        unsafe fn to_jsval(&self, cx: *mut JSContext, rval: MutableHandleValue) {
            pairs[*self as usize].0.to_jsval(cx, rval);
        }
    }
        } // mod ScrollBehaviorValues

#[derive(JSTraceable)]
pub struct ScrollOptions {
    pub behavior: ScrollBehavior,
}
impl ScrollOptions {
    pub unsafe fn empty(cx: *mut JSContext) -> ScrollOptions {
        match ScrollOptions::new(cx, HandleValue::null()) {
            Ok(ConversionResult::Success(v)) => v,
            _ => unreachable!(),
        }
    }
    pub unsafe fn new(cx: *mut JSContext, val: HandleValue)
                      -> Result<ConversionResult<ScrollOptions>, ()> {
        let object = if val.get().is_null_or_undefined() {
            ptr::null_mut()
        } else if val.get().is_object() {
            val.get().to_object()
        } else {
            return Ok(ConversionResult::Failure("Value is not an object.".into()));
        };
        rooted!(in(cx) let object = object);
            let dictionary = ScrollOptions {
            behavior: {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "behavior", rval.handle_mut())) {
                    true => {
                        match find_enum_value(cx, rval.handle(), ScrollBehaviorValues::pairs) {
                            Err(_) => { return Err(()); },
                            Ok((None, search)) => { throw_type_error(cx, &format!("'{}' is not a valid enum value for enumeration 'ScrollBehavior'.", search)); return Err(()); },
                            Ok((Some(&value), _)) => value,
                        }
                    },
                    false => {
                        ScrollBehavior::Auto
                    },
                }
            },
            };
        Ok(ConversionResult::Success(dictionary))
    }
}

impl FromJSValConvertible for ScrollOptions {
    type Config = ();
    unsafe fn from_jsval(cx: *mut JSContext, value: HandleValue, _option: ())
                         -> Result<ConversionResult<ScrollOptions>, ()> {
        ScrollOptions::new(cx, value)
    }
}

impl ToJSValConvertible for ScrollOptions {
    unsafe fn to_jsval(&self, cx: *mut JSContext, mut rval: MutableHandleValue) {
        rooted!(in(cx) let obj = JS_NewObject(cx, ptr::null()));
        let behavior = &self.behavior;
        rooted!(in(cx) let mut behavior_js = UndefinedValue());
        behavior.to_jsval(cx, behavior_js.handle_mut());
        set_dictionary_property(cx, obj.handle(), "behavior", behavior_js.handle()).unwrap();
        rval.set(ObjectOrNullValue(obj.get()))
    }
}


#[derive(JSTraceable)]
pub struct ScrollToOptions {
    pub parent: dom::bindings::codegen::Bindings::WindowBinding::ScrollOptions,
    pub left: Option<f64>,
    pub top: Option<f64>,
}
impl ScrollToOptions {
    pub unsafe fn empty(cx: *mut JSContext) -> ScrollToOptions {
        match ScrollToOptions::new(cx, HandleValue::null()) {
            Ok(ConversionResult::Success(v)) => v,
            _ => unreachable!(),
        }
    }
    pub unsafe fn new(cx: *mut JSContext, val: HandleValue)
                      -> Result<ConversionResult<ScrollToOptions>, ()> {
        let object = if val.get().is_null_or_undefined() {
            ptr::null_mut()
        } else if val.get().is_object() {
            val.get().to_object()
        } else {
            return Ok(ConversionResult::Failure("Value is not an object.".into()));
        };
        rooted!(in(cx) let object = object);
            let dictionary = ScrollToOptions {
            parent: {
                match try!(dom::bindings::codegen::Bindings::WindowBinding::ScrollOptions::new(cx, val)) {
                    ConversionResult::Success(v) => v,
                    ConversionResult::Failure(error) => {
                        throw_type_error(cx, &error);
                        return Err(());
                    }
                }
            },
            left: {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "left", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            },
            top: {
                rooted!(in(cx) let mut rval = UndefinedValue());
                match try!(get_dictionary_property(cx, object.handle(), "top", rval.handle_mut())) {
                    true => {
                        Some(match FromJSValConvertible::from_jsval(cx, rval.handle(), ()) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return Err(());
                            }
                            _ => { return Err(()); }
                        })
                    },
                    false => {
                        None
                    },
                }
            },
            };
        Ok(ConversionResult::Success(dictionary))
    }
}

impl FromJSValConvertible for ScrollToOptions {
    type Config = ();
    unsafe fn from_jsval(cx: *mut JSContext, value: HandleValue, _option: ())
                         -> Result<ConversionResult<ScrollToOptions>, ()> {
        ScrollToOptions::new(cx, value)
    }
}

impl ToJSValConvertible for ScrollToOptions {
    unsafe fn to_jsval(&self, cx: *mut JSContext, mut rval: MutableHandleValue) {
        rooted!(in(cx) let obj = JS_NewObject(cx, ptr::null()));
        if let Some(ref left) = self.left {
            rooted!(in(cx) let mut left_js = UndefinedValue());
            left.to_jsval(cx, left_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "left", left_js.handle()).unwrap();
        }
        if let Some(ref top) = self.top {
            rooted!(in(cx) let mut top_js = UndefinedValue());
            top.to_jsval(cx, top_js.handle_mut());
            set_dictionary_property(cx, obj.handle(), "top", top_js.handle()).unwrap();
        }
        rval.set(ObjectOrNullValue(obj.get()))
    }
}


#[derive(JSTraceable, PartialEq)]
#[allow_unrooted_interior]
pub struct FrameRequestCallback<TH: TypeHolderTrait + 'static> {
    pub parent: CallbackFunction<TH>,
}

impl<TH: TypeHolderTrait> FrameRequestCallback<TH> {
    pub unsafe fn new(aCx: *mut JSContext, aCallback: *mut JSObject) -> Rc<FrameRequestCallback<TH>> {
        let mut ret = Rc::new(FrameRequestCallback {
            parent: CallbackFunction::new()
        });
        // Note: callback cannot be moved after calling init.
        match Rc::get_mut(&mut ret) {
            Some(ref mut callback) => callback.parent.init(aCx, aCallback),
            None => unreachable!(),
        };
        ret
    }

    pub fn Call_<T: DomObject>(&self, thisObj: &T, time: Finite<f64>, aExceptionHandling: ExceptionHandling) -> Fallible<(), TH> {
        let s = CallSetup::new(self, aExceptionHandling);
        rooted!(in(s.get_context()) let mut thisObjJS = ptr::null_mut::<JSObject>());
        wrap_call_this_object(s.get_context(), thisObj, thisObjJS.handle_mut());
        if thisObjJS.is_null() {
            return Err(JSFailed);
        }
        unsafe { self.Call(s.get_context(), thisObjJS.handle(), time) }
    }

    pub fn Call__(&self, time: Finite<f64>, aExceptionHandling: ExceptionHandling) -> Fallible<(), TH> {
        let s = CallSetup::new(self, aExceptionHandling);
        rooted!(in(s.get_context()) let thisObjJS = ptr::null_mut::<JSObject>());
        unsafe { self.Call(s.get_context(), thisObjJS.handle(), time) }
    }

    unsafe fn Call(&self, cx: *mut JSContext, aThisObj: HandleObject, time: Finite<f64>) -> Fallible<(), TH> {
        rooted!(in(cx) let mut rval = UndefinedValue());
        rooted_vec!(let mut argv);
        argv.extend((0..1).map(|_| Heap::default()));

        let argc = 1;

        rooted!(in(cx) let mut argv_root = UndefinedValue());
        (time).to_jsval(cx, argv_root.handle_mut());
        {
        let arg = &mut argv[0];
        *arg = Heap::default();
        arg.set(argv_root.get());
        }

        rooted!(in(cx) let callable = ObjectValue(self.callback()));
        rooted!(in(cx) let rootedThis = aThisObj.get());
        let ok = JS_CallFunctionValue(
            cx, rootedThis.handle(), callable.handle(),
            &HandleValueArray {
                length_: argc as ::libc::size_t,
                elements_: argv.as_ptr() as *const JSVal
            }, rval.handle_mut());
        maybe_resume_unwind();
        if !ok {
            return Err(JSFailed);
        }

        Ok(())

    }
}
impl<TH: TypeHolderTrait> CallbackContainer<TH> for FrameRequestCallback<TH> {
    unsafe fn new(cx: *mut JSContext, callback: *mut JSObject) -> Rc<FrameRequestCallback<TH>> {
        FrameRequestCallback::new(cx, callback)
    }

    fn callback_holder(&self) -> &CallbackObject<TH> {
        self.parent.callback_holder()
    }
}

impl<TH: TypeHolderTrait> ToJSValConvertible for FrameRequestCallback<TH> {
    unsafe fn to_jsval(&self, cx: *mut JSContext, rval: MutableHandleValue) {
        self.callback().to_jsval(cx, rval);
    }
}

pub use self::WindowBinding::{Wrap, WindowMethods, GetProtoObject, DefineDOMInterface};
pub mod WindowBinding {
#![allow(non_camel_case_types,non_upper_case_globals,unused_imports,unused_variables,unused_assignments,unused_mut)]
use dom;
use dom::bindings;
use dom::bindings::callback::CallSetup;
use dom::bindings::callback::CallbackContainer;
use dom::bindings::callback::CallbackFunction;
use dom::bindings::callback::CallbackInterface;
use dom::bindings::callback::CallbackObject;
use dom::bindings::callback::ExceptionHandling;
use dom::bindings::callback::wrap_call_this_object;
use dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull;
use dom::bindings::codegen::Bindings::EventHandlerBinding::OnBeforeUnloadEventHandlerNonNull;
use dom::bindings::codegen::Bindings::EventHandlerBinding::OnErrorEventHandlerNonNull;
use dom::bindings::codegen::Bindings::EventTargetBinding::EventTargetBinding;
use dom::bindings::codegen::Bindings::FunctionBinding::Function;
use dom::bindings::codegen::Bindings::NodeBinding::NodeBinding;
use dom::bindings::codegen::Bindings::RequestBinding::ReferrerPolicy;
use dom::bindings::codegen::Bindings::RequestBinding::ReferrerPolicyValues;
use dom::bindings::codegen::Bindings::RequestBinding::RequestCache;
use dom::bindings::codegen::Bindings::RequestBinding::RequestCacheValues;
use dom::bindings::codegen::Bindings::RequestBinding::RequestCredentials;
use dom::bindings::codegen::Bindings::RequestBinding::RequestCredentialsValues;
use dom::bindings::codegen::Bindings::RequestBinding::RequestInit;
use dom::bindings::codegen::Bindings::RequestBinding::RequestMode;
use dom::bindings::codegen::Bindings::RequestBinding::RequestModeValues;
use dom::bindings::codegen::Bindings::RequestBinding::RequestRedirect;
use dom::bindings::codegen::Bindings::RequestBinding::RequestRedirectValues;
use dom::bindings::codegen::Bindings::WindowBinding::FrameRequestCallback;
use dom::bindings::codegen::Bindings::WindowBinding::ScrollBehavior;
use dom::bindings::codegen::Bindings::WindowBinding::ScrollBehaviorValues;
use dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions;
use dom::bindings::codegen::InterfaceObjectMap;
use dom::bindings::codegen::PrototypeList;
use dom::bindings::codegen::RegisterBindings;
use dom::bindings::codegen::UnionTypes;
use dom::bindings::constant::ConstantSpec;
use dom::bindings::constant::ConstantVal;
use dom::bindings::conversions::ConversionBehavior;
use dom::bindings::conversions::ConversionResult;
use dom::bindings::conversions::DOM_OBJECT_SLOT;
use dom::bindings::conversions::FromJSValConvertible;
use dom::bindings::conversions::IDLInterface;
use dom::bindings::conversions::StringificationBehavior;
use dom::bindings::conversions::ToJSValConvertible;
use dom::bindings::conversions::is_array_like;
use dom::bindings::conversions::jsid_to_string;
use dom::bindings::conversions::native_from_handlevalue;
use dom::bindings::conversions::native_from_object;
use dom::bindings::conversions::private_from_object;
use dom::bindings::conversions::root_from_handleobject;
use dom::bindings::conversions::root_from_handlevalue;
use dom::bindings::conversions::root_from_object;
use dom::bindings::error::Error;
use dom::bindings::error::Error::JSFailed;
use dom::bindings::error::ErrorResult;
use dom::bindings::error::Fallible;
use dom::bindings::error::throw_dom_exception;
use dom::bindings::guard::Condition;
use dom::bindings::guard::Guard;
use dom::bindings::htmlconstructor::html_constructor;
use dom::bindings::htmlconstructor::pop_current_element_queue;
use dom::bindings::htmlconstructor::push_new_element_queue;
use dom::bindings::inheritance::Castable;
use dom::bindings::interface::ConstructorClassHook;
use dom::bindings::interface::InterfaceConstructorBehavior;
use dom::bindings::interface::NonCallbackInterfaceObjectClass;
use dom::bindings::interface::create_callback_interface_object;
use dom::bindings::interface::create_global_object;
use dom::bindings::interface::create_interface_prototype_object;
use dom::bindings::interface::create_named_constructors;
use dom::bindings::interface::create_noncallback_interface_object;
use dom::bindings::interface::define_guarded_constants;
use dom::bindings::interface::define_guarded_methods;
use dom::bindings::interface::define_guarded_properties;
use dom::bindings::interface::is_exposed_in;
use dom::bindings::iterable::Iterable;
use dom::bindings::iterable::IteratorType;
use dom::bindings::mozmap::MozMap;
use dom::bindings::namespace::NamespaceObjectClass;
use dom::bindings::namespace::create_namespace_object;
use dom::bindings::num::Finite;
use dom::bindings::proxyhandler;
use dom::bindings::proxyhandler::ensure_expando_object;
use dom::bindings::proxyhandler::fill_property_descriptor;
use dom::bindings::proxyhandler::get_expando_object;
use dom::bindings::proxyhandler::get_property_descriptor;
use dom::bindings::reflector::DomObject;
use dom::bindings::reflector::MutDomObject;
use dom::bindings::root::Dom;
use dom::bindings::root::DomRoot;
use dom::bindings::root::OptionalHeapSetter;
use dom::bindings::root::RootedReference;
use dom::bindings::str::ByteString;
use dom::bindings::str::DOMString;
use dom::bindings::str::USVString;
use dom::bindings::trace::JSTraceable;
use dom::bindings::trace::RootedTraceable;
use dom::bindings::trace::RootedTraceableBox;
use dom::bindings::utils::AsVoidPtr;
use dom::bindings::utils::DOMClass;
use dom::bindings::utils::DOMJSClass;
use dom::bindings::utils::DOM_PROTO_UNFORGEABLE_HOLDER_SLOT;
use dom::bindings::utils::JSCLASS_DOM_GLOBAL;
use dom::bindings::utils::ProtoOrIfaceArray;
use dom::bindings::utils::enumerate_global;
use dom::bindings::utils::finalize_global;
use dom::bindings::utils::find_enum_value;
use dom::bindings::utils::generic_getter;
use dom::bindings::utils::generic_lenient_getter;
use dom::bindings::utils::generic_lenient_setter;
use dom::bindings::utils::generic_method;
use dom::bindings::utils::generic_setter;
use dom::bindings::utils::get_array_index_from_id;
use dom::bindings::utils::get_dictionary_property;
use dom::bindings::utils::get_property_on_prototype;
use dom::bindings::utils::get_proto_or_iface_array;
use dom::bindings::utils::has_property_on_prototype;
use dom::bindings::utils::is_platform_object;
use dom::bindings::utils::resolve_global;
use dom::bindings::utils::set_dictionary_property;
use dom::bindings::utils::trace_global;
use dom::bindings::weakref::DOM_WEAK_SLOT;
use dom::bindings::weakref::WeakBox;
use dom::bindings::weakref::WeakReferenceable;
use dom::globalscope::GlobalScope;
use dom::promise::Promise;
use dom::types::CSSStyleDeclaration;
use dom::types::Crypto;
use dom::types::CustomElementRegistry;
use dom::types::Document;
use dom::types::Element;
use dom::types::EventTarget;
use dom::types::History;
use dom::types::Location;
use dom::types::MediaQueryList;
use dom::types::Navigator;
use dom::types::Node;
use dom::types::Performance;
use dom::types::Request;
use dom::types::Screen;
use dom::types::Storage;
use dom::types::TestRunner;
use dom::types::Window;
use dom::windowproxy::WindowProxy;
use js;
use js::JSCLASS_GLOBAL_SLOT_COUNT;
use js::JSCLASS_IS_DOMJSCLASS;
use js::JSCLASS_IS_GLOBAL;
use js::JSCLASS_RESERVED_SLOTS_MASK;
use js::JS_CALLEE;
use js::error::throw_internal_error;
use js::error::throw_type_error;
use js::glue::AppendToAutoIdVector;
use js::glue::CallJitGetterOp;
use js::glue::CallJitMethodOp;
use js::glue::CallJitSetterOp;
use js::glue::CreateProxyHandler;
use js::glue::GetProxyPrivate;
use js::glue::ProxyTraps;
use js::glue::RUST_JSID_IS_INT;
use js::glue::RUST_JSID_IS_STRING;
use js::glue::RUST_SYMBOL_TO_JSID;
use js::glue::UnwrapObject;
use js::glue::int_to_jsid;
use js::jsapi::AutoIdVector;
use js::jsapi::CallArgs;
use js::jsapi::CurrentGlobalOrNull;
use js::jsapi::FreeOp;
use js::jsapi::GetWellKnownSymbol;
use js::jsapi::Handle as RawHandle;
use js::jsapi::HandleId as RawHandleId;
use js::jsapi::HandleObject as RawHandleObject;
use js::jsapi::HandleValue as RawHandleValue;
use js::jsapi::HandleValueArray;
use js::jsapi::Heap;
use js::jsapi::INTERNED_STRING_TO_JSID;
use js::jsapi::IsCallable;
use js::jsapi::JSAutoCompartment;
use js::jsapi::JSCLASS_RESERVED_SLOTS_SHIFT;
use js::jsapi::JSClass;
use js::jsapi::JSContext;
use js::jsapi::JSFreeOp;
use js::jsapi::JSFunctionSpec;
use js::jsapi::JSITER_HIDDEN;
use js::jsapi::JSITER_OWNONLY;
use js::jsapi::JSITER_SYMBOLS;
use js::jsapi::JSJitGetterCallArgs;
use js::jsapi::JSJitInfo;
use js::jsapi::JSJitInfo_AliasSet;
use js::jsapi::JSJitInfo_ArgType;
use js::jsapi::JSJitInfo_OpType;
use js::jsapi::JSJitMethodCallArgs;
use js::jsapi::JSJitSetterCallArgs;
use js::jsapi::JSNative;
use js::jsapi::JSNativeWrapper;
use js::jsapi::JSObject;
use js::jsapi::JSPROP_ENUMERATE;
use js::jsapi::JSPROP_PERMANENT;
use js::jsapi::JSPROP_READONLY;
use js::jsapi::JSPROP_SHARED;
use js::jsapi::JSPropertySpec;
use js::jsapi::JSString;
use js::jsapi::JSTracer;
use js::jsapi::JSType;
use js::jsapi::JSTypedMethodJitInfo;
use js::jsapi::JSValueType;
use js::jsapi::JS_AtomizeAndPinString;
use js::jsapi::JS_ForwardGetPropertyTo;
use js::jsapi::JS_GetErrorPrototype;
use js::jsapi::JS_GetGlobalForObject;
use js::jsapi::JS_GetIteratorPrototype;
use js::jsapi::JS_GetPropertyById;
use js::jsapi::JS_GetPropertyDescriptorById;
use js::jsapi::JS_GetReservedSlot;
use js::jsapi::JS_HasProperty;
use js::jsapi::JS_HasPropertyById;
use js::jsapi::JS_NewObject;
use js::jsapi::JS_SetReservedSlot;
use js::jsapi::MutableHandle as RawMutableHandle;
use js::jsapi::MutableHandleObject as RawMutableHandleObject;
use js::jsapi::MutableHandleValue as RawMutableHandleValue;
use js::jsapi::ObjectOpResult;
use js::jsapi::PropertyDescriptor;
use js::jsapi::Rooted;
use js::jsapi::RootedId;
use js::jsapi::RootedObject;
use js::jsapi::RootedString;
use js::jsapi::SymbolCode;
use js::jsapi::jsid;
use js::jsval::JSVal;
use js::jsval::NullValue;
use js::jsval::ObjectOrNullValue;
use js::jsval::ObjectValue;
use js::jsval::PrivateValue;
use js::jsval::UndefinedValue;
use js::panic::maybe_resume_unwind;
use js::panic::wrap_panic;
use js::rust::CustomAutoRooterGuard;
use js::rust::GCMethods;
use js::rust::Handle;
use js::rust::HandleId;
use js::rust::HandleObject;
use js::rust::HandleValue;
use js::rust::MutableHandle;
use js::rust::MutableHandleObject;
use js::rust::MutableHandleValue;
use js::rust::define_methods;
use js::rust::define_properties;
use js::rust::get_object_class;
use js::rust::wrappers::Call;
use js::rust::wrappers::GetPropertyKeys;
use js::rust::wrappers::JS_CallFunctionValue;
use js::rust::wrappers::JS_CopyPropertiesFrom;
use js::rust::wrappers::JS_DefineProperty;
use js::rust::wrappers::JS_DefinePropertyById2;
use js::rust::wrappers::JS_GetFunctionPrototype;
use js::rust::wrappers::JS_GetObjectPrototype;
use js::rust::wrappers::JS_GetProperty;
use js::rust::wrappers::JS_InitializePropertiesFromCompatibleNativeObject;
use js::rust::wrappers::JS_NewObjectWithGivenProto;
use js::rust::wrappers::JS_NewObjectWithoutMetadata;
use js::rust::wrappers::JS_ObjectIsDate;
use js::rust::wrappers::JS_SetImmutablePrototype;
use js::rust::wrappers::JS_SetProperty;
use js::rust::wrappers::JS_SetPrototype;
use js::rust::wrappers::JS_SplicePrototype;
use js::rust::wrappers::JS_WrapObject;
use js::rust::wrappers::JS_WrapValue;
use js::rust::wrappers::NewProxyObject;
use js::typedarray;
use libc;
use malloc_size_of::MallocSizeOfOps;
use mem::malloc_size_of_including_raw_self;
use servo_config::prefs::PREFS;
use std::borrow::ToOwned;
use std::cmp;
use std::default::Default;
use std::ffi::CString;
use std::mem;
use std::num;
use std::os;
use std::os::raw::c_void;
use std::panic;
use std::ptr;
use std::ptr::NonNull;
use std::rc;
use std::rc::Rc;
use std::str;
use typeholder::TypeHolderTrait;

unsafe extern fn get_window<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<WindowProxy<TH>> = this.Window();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn window_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_window::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_self<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<WindowProxy<TH>> = this.Self_();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_self<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        JS_DefineProperty(cx, obj, b"self\0" as *const u8 as *const libc::c_char,
                          args.get(0), JSPROP_ENUMERATE, None, None)
    }), false);
}


fn self_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_self::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn self_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_self::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_document<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<Document<TH>> = this.Document();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn document_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_document::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_name<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DOMString = this.Name();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_name<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetName(arg0);

        return true;
    }), false);
}


fn name_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_name::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn name_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_name::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_location<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<Location<TH>> = this.Location();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn location_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_location::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_history<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<History<TH>> = this.History();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn history_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_history::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_customElements<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<CustomElementRegistry<TH>> = this.CustomElements();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn customElements_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_customElements::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_status<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DOMString = this.Status();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_status<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.SetStatus(arg0);

        return true;
    }), false);
}


fn status_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_status::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn status_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_status::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn close<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.Close();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn close_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: close::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_closed<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: bool = this.Closed();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn closed_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_closed::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_BOOLEAN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_frames<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<WindowProxy<TH>> = this.Frames();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_frames<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        JS_DefineProperty(cx, obj, b"frames\0" as *const u8 as *const libc::c_char,
                          args.get(0), JSPROP_ENUMERATE, None, None)
    }), false);
}


fn frames_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_frames::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn frames_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_frames::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_top<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DomRoot<WindowProxy<TH>>> = this.GetTop();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn top_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_top::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_parent<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DomRoot<WindowProxy<TH>>> = this.GetParent();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn parent_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_parent::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_frameElement<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<DomRoot<Element<TH>>> = this.GetFrameElement();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn frameElement_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_frameElement::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_navigator<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<Navigator<TH>> = this.Navigator();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn navigator_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_navigator::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn alert<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        let argcount = cmp::min(argc, 1);
        match argcount {
            0 => {
                let result: () = this.Alert_();

                (result).to_jsval(cx, args.rval());
                return true;
            }
            1 => {
                let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
                    Ok(ConversionResult::Success(strval)) => strval,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                let result: () = this.Alert(arg0);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            _ => {
                throw_type_error(cx, "Not enough arguments to \"Window.alert\".");
                return false;
            }
        }
    }), false);
}


fn alert_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: alert::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn requestAnimationFrame<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Window.requestAnimationFrame\".");
            return false;
        }
        let arg0: Rc<FrameRequestCallback<TH>> = if args.get(0).get().is_object() {
            if IsCallable(args.get(0).get().to_object()) {
                FrameRequestCallback::new(cx, args.get(0).get().to_object())
            } else {
                throw_type_error(cx, "Value is not callable.");
                return false;

            }
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: u32 = this.RequestAnimationFrame(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn requestAnimationFrame_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: requestAnimationFrame::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn cancelAnimationFrame<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Window.cancelAnimationFrame\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.CancelAnimationFrame(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn cancelAnimationFrame_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: cancelAnimationFrame::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn postMessage<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"Window.postMessage\".");
            return false;
        }
        let arg0: HandleValue = args.get(0);
        let arg1: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(1), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: Result<(), Error<TH>> = this.PostMessage(cx, arg0, arg1);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn postMessage_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: postMessage::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn captureEvents<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.CaptureEvents();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn captureEvents_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: captureEvents::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn releaseEvents<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.ReleaseEvents();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn releaseEvents_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: releaseEvents::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getComputedStyle<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Window.getComputedStyle\".");
            return false;
        }
        let arg0: DomRoot<Element<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface Element.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: Option<DOMString> = if args.get(1).is_undefined() {
            None
        } else {
            Some(match FromJSValConvertible::from_jsval(cx, args.get(1), StringificationBehavior::Default) {
                Ok(ConversionResult::Success(strval)) => strval,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            })
        };
        let result: DomRoot<CSSStyleDeclaration<TH>> = this.GetComputedStyle(&arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn getComputedStyle_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: getComputedStyle::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn matchMedia<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Window.matchMedia\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: DomRoot<MediaQueryList<TH>> = this.MatchMedia(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn matchMedia_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: matchMedia::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_screen<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<Screen<TH>> = this.Screen();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn screen_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_screen::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasNone as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        true,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn moveTo<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"Window.moveTo\".");
            return false;
        }
        let arg0: i32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: i32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.MoveTo(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn moveTo_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: moveTo::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn moveBy<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"Window.moveBy\".");
            return false;
        }
        let arg0: i32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: i32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.MoveBy(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn moveBy_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: moveBy::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn resizeTo<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"Window.resizeTo\".");
            return false;
        }
        let arg0: i32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: i32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.ResizeTo(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn resizeTo_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: resizeTo::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn resizeBy<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"Window.resizeBy\".");
            return false;
        }
        let arg0: i32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: i32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.ResizeBy(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn resizeBy_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: resizeBy::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_innerWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: i32 = this.InnerWidth();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn innerWidth_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_innerWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_innerHeight<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: i32 = this.InnerHeight();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn innerHeight_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_innerHeight::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_scrollX<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: i32 = this.ScrollX();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn scrollX_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_scrollX::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_pageXOffset<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: i32 = this.PageXOffset();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn pageXOffset_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_pageXOffset::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_scrollY<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: i32 = this.ScrollY();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn scrollY_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_scrollY::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_pageYOffset<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: i32 = this.PageYOffset();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn pageYOffset_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_pageYOffset::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn scroll<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        let argcount = cmp::min(argc, 2);
        match argcount {
            0 => {
                let arg0: dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions = if args.get(0).is_undefined() {
                    dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions::empty(cx)
                } else {
                    match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                        Ok(ConversionResult::Success(dictionary)) => dictionary,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     },
                    }
                };
                let result: () = this.Scroll(&arg0);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            1 => {
                let arg0: dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions = if args.get(0).is_undefined() {
                    dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions::empty(cx)
                } else {
                    match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                        Ok(ConversionResult::Success(dictionary)) => dictionary,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     },
                    }
                };
                let result: () = this.Scroll(&arg0);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            2 => {
                let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg1: f64 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let result: () = this.Scroll_(arg0, arg1);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            _ => {
                throw_type_error(cx, "Not enough arguments to \"Window.scroll\".");
                return false;
            }
        }
    }), false);
}


fn scroll_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: scroll::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn scrollTo<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        let argcount = cmp::min(argc, 2);
        match argcount {
            0 => {
                let arg0: dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions = if args.get(0).is_undefined() {
                    dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions::empty(cx)
                } else {
                    match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                        Ok(ConversionResult::Success(dictionary)) => dictionary,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     },
                    }
                };
                let result: () = this.ScrollTo(&arg0);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            1 => {
                let arg0: dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions = if args.get(0).is_undefined() {
                    dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions::empty(cx)
                } else {
                    match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                        Ok(ConversionResult::Success(dictionary)) => dictionary,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     },
                    }
                };
                let result: () = this.ScrollTo(&arg0);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            2 => {
                let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg1: f64 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let result: () = this.ScrollTo_(arg0, arg1);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            _ => {
                throw_type_error(cx, "Not enough arguments to \"Window.scrollTo\".");
                return false;
            }
        }
    }), false);
}


fn scrollTo_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: scrollTo::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn scrollBy<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        let argcount = cmp::min(argc, 2);
        match argcount {
            0 => {
                let arg0: dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions = if args.get(0).is_undefined() {
                    dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions::empty(cx)
                } else {
                    match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                        Ok(ConversionResult::Success(dictionary)) => dictionary,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     },
                    }
                };
                let result: () = this.ScrollBy(&arg0);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            1 => {
                let arg0: dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions = if args.get(0).is_undefined() {
                    dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions::empty(cx)
                } else {
                    match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                        Ok(ConversionResult::Success(dictionary)) => dictionary,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     },
                    }
                };
                let result: () = this.ScrollBy(&arg0);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            2 => {
                let arg0: f64 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg1: f64 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let result: () = this.ScrollBy_(arg0, arg1);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            _ => {
                throw_type_error(cx, "Not enough arguments to \"Window.scrollBy\".");
                return false;
            }
        }
    }), false);
}


fn scrollBy_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: scrollBy::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_screenX<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: i32 = this.ScreenX();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn screenX_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_screenX::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_screenY<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: i32 = this.ScreenY();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn screenY_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_screenY::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_outerWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: i32 = this.OuterWidth();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn outerWidth_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_outerWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_outerHeight<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: i32 = this.OuterHeight();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn outerHeight_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_outerHeight::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_devicePixelRatio<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Finite<f64> = this.DevicePixelRatio();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn devicePixelRatio_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_devicePixelRatio::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn debug<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Window.debug\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.Debug(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn debug_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: debug::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn gc<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.Gc();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn gc_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: gc::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn trap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.Trap();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn trap_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: trap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn webdriverCallback<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: HandleValue = if args.get(0).is_undefined() {
            HandleValue::undefined()
        } else {
            args.get(0)
        };
        let result: () = this.WebdriverCallback(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn webdriverCallback_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: webdriverCallback::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn webdriverTimeout<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.WebdriverTimeout();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn webdriverTimeout_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: webdriverTimeout::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_testRunner<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<TestRunner<TH>> = this.TestRunner();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn testRunner_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_testRunner::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_crypto<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<Crypto<TH>> = this.Crypto();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn crypto_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_crypto::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onabort<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnabort();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onabort<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnabort(arg0);

        return true;
    }), false);
}


fn onabort_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onabort::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onabort_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onabort::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onblur<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnblur();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onblur<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnblur(arg0);

        return true;
    }), false);
}


fn onblur_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onblur::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onblur_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onblur::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_oncancel<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOncancel();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_oncancel<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOncancel(arg0);

        return true;
    }), false);
}


fn oncancel_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_oncancel::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn oncancel_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_oncancel::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_oncanplay<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOncanplay();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_oncanplay<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOncanplay(arg0);

        return true;
    }), false);
}


fn oncanplay_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_oncanplay::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn oncanplay_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_oncanplay::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_oncanplaythrough<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOncanplaythrough();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_oncanplaythrough<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOncanplaythrough(arg0);

        return true;
    }), false);
}


fn oncanplaythrough_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_oncanplaythrough::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn oncanplaythrough_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_oncanplaythrough::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onchange<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnchange();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onchange<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnchange(arg0);

        return true;
    }), false);
}


fn onchange_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onchange::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onchange_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onchange::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onclick<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnclick();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onclick<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnclick(arg0);

        return true;
    }), false);
}


fn onclick_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onclick::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onclick_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onclick::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onclose<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnclose();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onclose<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnclose(arg0);

        return true;
    }), false);
}


fn onclose_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onclose::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onclose_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onclose::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_oncontextmenu<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOncontextmenu();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_oncontextmenu<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOncontextmenu(arg0);

        return true;
    }), false);
}


fn oncontextmenu_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_oncontextmenu::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn oncontextmenu_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_oncontextmenu::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_oncuechange<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOncuechange();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_oncuechange<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOncuechange(arg0);

        return true;
    }), false);
}


fn oncuechange_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_oncuechange::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn oncuechange_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_oncuechange::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_ondblclick<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOndblclick();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_ondblclick<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOndblclick(arg0);

        return true;
    }), false);
}


fn ondblclick_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_ondblclick::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn ondblclick_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_ondblclick::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_ondrag<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOndrag();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_ondrag<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOndrag(arg0);

        return true;
    }), false);
}


fn ondrag_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_ondrag::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn ondrag_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_ondrag::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_ondragend<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOndragend();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_ondragend<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOndragend(arg0);

        return true;
    }), false);
}


fn ondragend_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_ondragend::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn ondragend_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_ondragend::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_ondragenter<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOndragenter();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_ondragenter<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOndragenter(arg0);

        return true;
    }), false);
}


fn ondragenter_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_ondragenter::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn ondragenter_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_ondragenter::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_ondragexit<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOndragexit();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_ondragexit<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOndragexit(arg0);

        return true;
    }), false);
}


fn ondragexit_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_ondragexit::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn ondragexit_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_ondragexit::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_ondragleave<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOndragleave();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_ondragleave<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOndragleave(arg0);

        return true;
    }), false);
}


fn ondragleave_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_ondragleave::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn ondragleave_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_ondragleave::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_ondragover<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOndragover();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_ondragover<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOndragover(arg0);

        return true;
    }), false);
}


fn ondragover_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_ondragover::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn ondragover_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_ondragover::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_ondragstart<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOndragstart();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_ondragstart<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOndragstart(arg0);

        return true;
    }), false);
}


fn ondragstart_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_ondragstart::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn ondragstart_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_ondragstart::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_ondrop<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOndrop();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_ondrop<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOndrop(arg0);

        return true;
    }), false);
}


fn ondrop_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_ondrop::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn ondrop_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_ondrop::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_ondurationchange<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOndurationchange();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_ondurationchange<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOndurationchange(arg0);

        return true;
    }), false);
}


fn ondurationchange_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_ondurationchange::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn ondurationchange_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_ondurationchange::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onemptied<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnemptied();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onemptied<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnemptied(arg0);

        return true;
    }), false);
}


fn onemptied_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onemptied::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onemptied_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onemptied::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onended<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnended();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onended<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnended(arg0);

        return true;
    }), false);
}


fn onended_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onended::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onended_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onended::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onerror<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::OnErrorEventHandlerNonNull<TH>>> = this.GetOnerror();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onerror<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<OnErrorEventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(OnErrorEventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnerror(arg0);

        return true;
    }), false);
}


fn onerror_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onerror::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onerror_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onerror::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onfocus<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnfocus();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onfocus<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnfocus(arg0);

        return true;
    }), false);
}


fn onfocus_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onfocus::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onfocus_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onfocus::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_oninput<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOninput();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_oninput<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOninput(arg0);

        return true;
    }), false);
}


fn oninput_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_oninput::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn oninput_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_oninput::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_oninvalid<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOninvalid();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_oninvalid<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOninvalid(arg0);

        return true;
    }), false);
}


fn oninvalid_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_oninvalid::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn oninvalid_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_oninvalid::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onkeydown<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnkeydown();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onkeydown<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnkeydown(arg0);

        return true;
    }), false);
}


fn onkeydown_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onkeydown::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onkeydown_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onkeydown::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onkeypress<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnkeypress();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onkeypress<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnkeypress(arg0);

        return true;
    }), false);
}


fn onkeypress_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onkeypress::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onkeypress_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onkeypress::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onkeyup<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnkeyup();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onkeyup<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnkeyup(arg0);

        return true;
    }), false);
}


fn onkeyup_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onkeyup::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onkeyup_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onkeyup::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onload<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnload();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onload<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnload(arg0);

        return true;
    }), false);
}


fn onload_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onload::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onload_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onload::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onloadeddata<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnloadeddata();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onloadeddata<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnloadeddata(arg0);

        return true;
    }), false);
}


fn onloadeddata_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onloadeddata::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onloadeddata_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onloadeddata::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onloadedmetadata<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnloadedmetadata();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onloadedmetadata<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnloadedmetadata(arg0);

        return true;
    }), false);
}


fn onloadedmetadata_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onloadedmetadata::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onloadedmetadata_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onloadedmetadata::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onloadstart<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnloadstart();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onloadstart<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnloadstart(arg0);

        return true;
    }), false);
}


fn onloadstart_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onloadstart::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onloadstart_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onloadstart::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onmousedown<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnmousedown();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onmousedown<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnmousedown(arg0);

        return true;
    }), false);
}


fn onmousedown_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onmousedown::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onmousedown_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onmousedown::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onmouseenter<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnmouseenter();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onmouseenter<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnmouseenter(arg0);

        return true;
    }), false);
}


fn onmouseenter_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onmouseenter::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onmouseenter_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onmouseenter::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onmouseleave<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnmouseleave();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onmouseleave<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnmouseleave(arg0);

        return true;
    }), false);
}


fn onmouseleave_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onmouseleave::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onmouseleave_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onmouseleave::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onmousemove<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnmousemove();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onmousemove<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnmousemove(arg0);

        return true;
    }), false);
}


fn onmousemove_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onmousemove::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onmousemove_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onmousemove::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onmouseout<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnmouseout();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onmouseout<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnmouseout(arg0);

        return true;
    }), false);
}


fn onmouseout_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onmouseout::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onmouseout_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onmouseout::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onmouseover<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnmouseover();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onmouseover<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnmouseover(arg0);

        return true;
    }), false);
}


fn onmouseover_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onmouseover::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onmouseover_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onmouseover::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onmouseup<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnmouseup();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onmouseup<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnmouseup(arg0);

        return true;
    }), false);
}


fn onmouseup_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onmouseup::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onmouseup_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onmouseup::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onwheel<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnwheel();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onwheel<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnwheel(arg0);

        return true;
    }), false);
}


fn onwheel_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onwheel::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onwheel_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onwheel::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onpause<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnpause();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onpause<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnpause(arg0);

        return true;
    }), false);
}


fn onpause_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onpause::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onpause_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onpause::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onplay<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnplay();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onplay<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnplay(arg0);

        return true;
    }), false);
}


fn onplay_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onplay::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onplay_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onplay::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onplaying<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnplaying();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onplaying<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnplaying(arg0);

        return true;
    }), false);
}


fn onplaying_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onplaying::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onplaying_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onplaying::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onprogress<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnprogress();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onprogress<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnprogress(arg0);

        return true;
    }), false);
}


fn onprogress_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onprogress::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onprogress_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onprogress::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onratechange<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnratechange();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onratechange<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnratechange(arg0);

        return true;
    }), false);
}


fn onratechange_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onratechange::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onratechange_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onratechange::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onreset<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnreset();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onreset<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnreset(arg0);

        return true;
    }), false);
}


fn onreset_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onreset::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onreset_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onreset::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onresize<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnresize();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onresize<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnresize(arg0);

        return true;
    }), false);
}


fn onresize_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onresize::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onresize_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onresize::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onscroll<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnscroll();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onscroll<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnscroll(arg0);

        return true;
    }), false);
}


fn onscroll_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onscroll::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onscroll_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onscroll::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onseeked<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnseeked();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onseeked<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnseeked(arg0);

        return true;
    }), false);
}


fn onseeked_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onseeked::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onseeked_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onseeked::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onseeking<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnseeking();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onseeking<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnseeking(arg0);

        return true;
    }), false);
}


fn onseeking_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onseeking::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onseeking_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onseeking::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onselect<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnselect();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onselect<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnselect(arg0);

        return true;
    }), false);
}


fn onselect_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onselect::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onselect_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onselect::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onshow<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnshow();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onshow<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnshow(arg0);

        return true;
    }), false);
}


fn onshow_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onshow::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onshow_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onshow::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onstalled<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnstalled();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onstalled<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnstalled(arg0);

        return true;
    }), false);
}


fn onstalled_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onstalled::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onstalled_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onstalled::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onsubmit<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnsubmit();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onsubmit<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnsubmit(arg0);

        return true;
    }), false);
}


fn onsubmit_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onsubmit::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onsubmit_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onsubmit::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onsuspend<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnsuspend();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onsuspend<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnsuspend(arg0);

        return true;
    }), false);
}


fn onsuspend_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onsuspend::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onsuspend_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onsuspend::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_ontimeupdate<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOntimeupdate();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_ontimeupdate<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOntimeupdate(arg0);

        return true;
    }), false);
}


fn ontimeupdate_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_ontimeupdate::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn ontimeupdate_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_ontimeupdate::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_ontoggle<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOntoggle();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_ontoggle<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOntoggle(arg0);

        return true;
    }), false);
}


fn ontoggle_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_ontoggle::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn ontoggle_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_ontoggle::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onvolumechange<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnvolumechange();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onvolumechange<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnvolumechange(arg0);

        return true;
    }), false);
}


fn onvolumechange_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onvolumechange::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onvolumechange_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onvolumechange::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onwaiting<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnwaiting();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onwaiting<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnwaiting(arg0);

        return true;
    }), false);
}


fn onwaiting_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onwaiting::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onwaiting_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onwaiting::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_ontransitionend<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOntransitionend();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_ontransitionend<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOntransitionend(arg0);

        return true;
    }), false);
}


fn ontransitionend_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_ontransitionend::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn ontransitionend_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_ontransitionend::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onafterprint<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnafterprint();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onafterprint<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnafterprint(arg0);

        return true;
    }), false);
}


fn onafterprint_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onafterprint::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onafterprint_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onafterprint::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onbeforeprint<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnbeforeprint();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onbeforeprint<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnbeforeprint(arg0);

        return true;
    }), false);
}


fn onbeforeprint_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onbeforeprint::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onbeforeprint_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onbeforeprint::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onbeforeunload<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::OnBeforeUnloadEventHandlerNonNull<TH>>> = this.GetOnbeforeunload();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onbeforeunload<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<OnBeforeUnloadEventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(OnBeforeUnloadEventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnbeforeunload(arg0);

        return true;
    }), false);
}


fn onbeforeunload_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onbeforeunload::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onbeforeunload_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onbeforeunload::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onhashchange<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnhashchange();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onhashchange<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnhashchange(arg0);

        return true;
    }), false);
}


fn onhashchange_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onhashchange::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onhashchange_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onhashchange::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onlanguagechange<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnlanguagechange();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onlanguagechange<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnlanguagechange(arg0);

        return true;
    }), false);
}


fn onlanguagechange_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onlanguagechange::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onlanguagechange_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onlanguagechange::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onmessage<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnmessage();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onmessage<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnmessage(arg0);

        return true;
    }), false);
}


fn onmessage_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onmessage::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onmessage_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onmessage::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onoffline<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnoffline();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onoffline<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnoffline(arg0);

        return true;
    }), false);
}


fn onoffline_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onoffline::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onoffline_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onoffline::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_ononline<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnonline();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_ononline<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnonline(arg0);

        return true;
    }), false);
}


fn ononline_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_ononline::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn ononline_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_ononline::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onpagehide<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnpagehide();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onpagehide<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnpagehide(arg0);

        return true;
    }), false);
}


fn onpagehide_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onpagehide::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onpagehide_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onpagehide::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onpageshow<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnpageshow();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onpageshow<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnpageshow(arg0);

        return true;
    }), false);
}


fn onpageshow_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onpageshow::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onpageshow_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onpageshow::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onpopstate<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnpopstate();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onpopstate<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnpopstate(arg0);

        return true;
    }), false);
}


fn onpopstate_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onpopstate::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onpopstate_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onpopstate::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onrejectionhandled<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnrejectionhandled();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onrejectionhandled<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnrejectionhandled(arg0);

        return true;
    }), false);
}


fn onrejectionhandled_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onrejectionhandled::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onrejectionhandled_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onrejectionhandled::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onstorage<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnstorage();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onstorage<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnstorage(arg0);

        return true;
    }), false);
}


fn onstorage_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onstorage::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onstorage_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onstorage::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onunhandledrejection<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnunhandledrejection();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onunhandledrejection<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnunhandledrejection(arg0);

        return true;
    }), false);
}


fn onunhandledrejection_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onunhandledrejection::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onunhandledrejection_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onunhandledrejection::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onunload<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnunload();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onunload<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnunload(arg0);

        return true;
    }), false);
}


fn onunload_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onunload::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onunload_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onunload::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onvrdisplayconnect<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnvrdisplayconnect();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onvrdisplayconnect<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnvrdisplayconnect(arg0);

        return true;
    }), false);
}


fn onvrdisplayconnect_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onvrdisplayconnect::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onvrdisplayconnect_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onvrdisplayconnect::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onvrdisplaydisconnect<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnvrdisplaydisconnect();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onvrdisplaydisconnect<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnvrdisplaydisconnect(arg0);

        return true;
    }), false);
}


fn onvrdisplaydisconnect_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onvrdisplaydisconnect::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onvrdisplaydisconnect_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onvrdisplaydisconnect::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onvrdisplayactivate<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnvrdisplayactivate();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onvrdisplayactivate<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnvrdisplayactivate(arg0);

        return true;
    }), false);
}


fn onvrdisplayactivate_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onvrdisplayactivate::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onvrdisplayactivate_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onvrdisplayactivate::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onvrdisplaydeactivate<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnvrdisplaydeactivate();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onvrdisplaydeactivate<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnvrdisplaydeactivate(arg0);

        return true;
    }), false);
}


fn onvrdisplaydeactivate_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onvrdisplaydeactivate::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onvrdisplaydeactivate_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onvrdisplaydeactivate::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onvrdisplayblur<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnvrdisplayblur();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onvrdisplayblur<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnvrdisplayblur(arg0);

        return true;
    }), false);
}


fn onvrdisplayblur_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onvrdisplayblur::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onvrdisplayblur_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onvrdisplayblur::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onvrdisplayfocus<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnvrdisplayfocus();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onvrdisplayfocus<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnvrdisplayfocus(arg0);

        return true;
    }), false);
}


fn onvrdisplayfocus_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onvrdisplayfocus::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onvrdisplayfocus_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onvrdisplayfocus::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onvrdisplaypresentchange<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>> = this.GetOnvrdisplaypresentchange();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onvrdisplaypresentchange<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<EventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(EventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnvrdisplaypresentchange(arg0);

        return true;
    }), false);
}


fn onvrdisplaypresentchange_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_onvrdisplaypresentchange::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onvrdisplaypresentchange_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_onvrdisplaypresentchange::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_localStorage<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<Storage<TH>> = this.LocalStorage();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn localStorage_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_localStorage::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_origin<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: USVString = this.Origin();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_origin<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        JS_DefineProperty(cx, obj, b"origin\0" as *const u8 as *const libc::c_char,
                          args.get(0), JSPROP_ENUMERATE, None, None)
    }), false);
}


fn origin_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_origin::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn origin_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_origin::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn btoa<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Window.btoa\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: Result<DOMString, Error<TH>> = this.Btoa(arg0);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn btoa_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: btoa::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn atob<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Window.atob\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: Result<DOMString, Error<TH>> = this.Atob(arg0);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn atob_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: atob::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn setTimeout<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        let argcount = cmp::min(argc, 3);
        match argcount {
            1 => {
                if args.get(0).get().is_object() && !is_platform_object(args.get(0).get().to_object()) {
                    let arg0: Rc<Function<TH>> = if args.get(0).get().is_object() {
                        if IsCallable(args.get(0).get().to_object()) {
                            Function::new(cx, args.get(0).get().to_object())
                        } else {
                            throw_type_error(cx, "Value is not callable.");
                            return false;

                        }
                    } else {
                        throw_type_error(cx, "Value is not an object.");
                        return false;

                    };
                    let arg1: i32 = if args.get(1).is_undefined() {
                        0
                    } else {
                        match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return false;

                            }
                            _ => { return false;
                         }
                        }
                    };
                    let mut arg2 = vec![];
                    if argc > 2 {
                        arg2.reserve(argc as usize - 2);
                        for variadicArg in 2..argc {
                            let slot: HandleValue = args.get(variadicArg);
                            arg2.push(slot);
                        }
                    }
                    let result: i32 = this.SetTimeout(cx, arg0, arg1, arg2);

                    (result).to_jsval(cx, args.rval());
                    return true;
                }
                let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
                    Ok(ConversionResult::Success(strval)) => strval,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                let arg1: i32 = if args.get(1).is_undefined() {
                    0
                } else {
                    match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                        Ok(ConversionResult::Success(v)) => v,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     }
                    }
                };
                let mut arg2 = vec![];
                if argc > 2 {
                    arg2.reserve(argc as usize - 2);
                    for variadicArg in 2..argc {
                        let slot: HandleValue = args.get(variadicArg);
                        arg2.push(slot);
                    }
                }
                let result: i32 = this.SetTimeout_(cx, arg0, arg1, arg2);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            2 => {
                if args.get(0).get().is_object() && !is_platform_object(args.get(0).get().to_object()) {
                    let arg0: Rc<Function<TH>> = if args.get(0).get().is_object() {
                        if IsCallable(args.get(0).get().to_object()) {
                            Function::new(cx, args.get(0).get().to_object())
                        } else {
                            throw_type_error(cx, "Value is not callable.");
                            return false;

                        }
                    } else {
                        throw_type_error(cx, "Value is not an object.");
                        return false;

                    };
                    let arg1: i32 = if args.get(1).is_undefined() {
                        0
                    } else {
                        match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return false;

                            }
                            _ => { return false;
                         }
                        }
                    };
                    let mut arg2 = vec![];
                    if argc > 2 {
                        arg2.reserve(argc as usize - 2);
                        for variadicArg in 2..argc {
                            let slot: HandleValue = args.get(variadicArg);
                            arg2.push(slot);
                        }
                    }
                    let result: i32 = this.SetTimeout(cx, arg0, arg1, arg2);

                    (result).to_jsval(cx, args.rval());
                    return true;
                }
                let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
                    Ok(ConversionResult::Success(strval)) => strval,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                let arg1: i32 = if args.get(1).is_undefined() {
                    0
                } else {
                    match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                        Ok(ConversionResult::Success(v)) => v,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     }
                    }
                };
                let mut arg2 = vec![];
                if argc > 2 {
                    arg2.reserve(argc as usize - 2);
                    for variadicArg in 2..argc {
                        let slot: HandleValue = args.get(variadicArg);
                        arg2.push(slot);
                    }
                }
                let result: i32 = this.SetTimeout_(cx, arg0, arg1, arg2);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            3 => {
                if args.get(0).get().is_object() && !is_platform_object(args.get(0).get().to_object()) {
                    let arg0: Rc<Function<TH>> = if args.get(0).get().is_object() {
                        if IsCallable(args.get(0).get().to_object()) {
                            Function::new(cx, args.get(0).get().to_object())
                        } else {
                            throw_type_error(cx, "Value is not callable.");
                            return false;

                        }
                    } else {
                        throw_type_error(cx, "Value is not an object.");
                        return false;

                    };
                    let arg1: i32 = if args.get(1).is_undefined() {
                        0
                    } else {
                        match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return false;

                            }
                            _ => { return false;
                         }
                        }
                    };
                    let mut arg2 = vec![];
                    if argc > 2 {
                        arg2.reserve(argc as usize - 2);
                        for variadicArg in 2..argc {
                            let slot: HandleValue = args.get(variadicArg);
                            arg2.push(slot);
                        }
                    }
                    let result: i32 = this.SetTimeout(cx, arg0, arg1, arg2);

                    (result).to_jsval(cx, args.rval());
                    return true;
                }
                let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
                    Ok(ConversionResult::Success(strval)) => strval,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                let arg1: i32 = if args.get(1).is_undefined() {
                    0
                } else {
                    match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                        Ok(ConversionResult::Success(v)) => v,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     }
                    }
                };
                let mut arg2 = vec![];
                if argc > 2 {
                    arg2.reserve(argc as usize - 2);
                    for variadicArg in 2..argc {
                        let slot: HandleValue = args.get(variadicArg);
                        arg2.push(slot);
                    }
                }
                let result: i32 = this.SetTimeout_(cx, arg0, arg1, arg2);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            _ => {
                throw_type_error(cx, "Not enough arguments to \"Window.setTimeout\".");
                return false;
            }
        }
    }), false);
}


fn setTimeout_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: setTimeout::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn clearTimeout<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: i32 = if args.get(0).is_undefined() {
            0
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.ClearTimeout(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn clearTimeout_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: clearTimeout::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn setInterval<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        let argcount = cmp::min(argc, 3);
        match argcount {
            1 => {
                if args.get(0).get().is_object() && !is_platform_object(args.get(0).get().to_object()) {
                    let arg0: Rc<Function<TH>> = if args.get(0).get().is_object() {
                        if IsCallable(args.get(0).get().to_object()) {
                            Function::new(cx, args.get(0).get().to_object())
                        } else {
                            throw_type_error(cx, "Value is not callable.");
                            return false;

                        }
                    } else {
                        throw_type_error(cx, "Value is not an object.");
                        return false;

                    };
                    let arg1: i32 = if args.get(1).is_undefined() {
                        0
                    } else {
                        match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return false;

                            }
                            _ => { return false;
                         }
                        }
                    };
                    let mut arg2 = vec![];
                    if argc > 2 {
                        arg2.reserve(argc as usize - 2);
                        for variadicArg in 2..argc {
                            let slot: HandleValue = args.get(variadicArg);
                            arg2.push(slot);
                        }
                    }
                    let result: i32 = this.SetInterval(cx, arg0, arg1, arg2);

                    (result).to_jsval(cx, args.rval());
                    return true;
                }
                let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
                    Ok(ConversionResult::Success(strval)) => strval,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                let arg1: i32 = if args.get(1).is_undefined() {
                    0
                } else {
                    match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                        Ok(ConversionResult::Success(v)) => v,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     }
                    }
                };
                let mut arg2 = vec![];
                if argc > 2 {
                    arg2.reserve(argc as usize - 2);
                    for variadicArg in 2..argc {
                        let slot: HandleValue = args.get(variadicArg);
                        arg2.push(slot);
                    }
                }
                let result: i32 = this.SetInterval_(cx, arg0, arg1, arg2);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            2 => {
                if args.get(0).get().is_object() && !is_platform_object(args.get(0).get().to_object()) {
                    let arg0: Rc<Function<TH>> = if args.get(0).get().is_object() {
                        if IsCallable(args.get(0).get().to_object()) {
                            Function::new(cx, args.get(0).get().to_object())
                        } else {
                            throw_type_error(cx, "Value is not callable.");
                            return false;

                        }
                    } else {
                        throw_type_error(cx, "Value is not an object.");
                        return false;

                    };
                    let arg1: i32 = if args.get(1).is_undefined() {
                        0
                    } else {
                        match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return false;

                            }
                            _ => { return false;
                         }
                        }
                    };
                    let mut arg2 = vec![];
                    if argc > 2 {
                        arg2.reserve(argc as usize - 2);
                        for variadicArg in 2..argc {
                            let slot: HandleValue = args.get(variadicArg);
                            arg2.push(slot);
                        }
                    }
                    let result: i32 = this.SetInterval(cx, arg0, arg1, arg2);

                    (result).to_jsval(cx, args.rval());
                    return true;
                }
                let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
                    Ok(ConversionResult::Success(strval)) => strval,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                let arg1: i32 = if args.get(1).is_undefined() {
                    0
                } else {
                    match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                        Ok(ConversionResult::Success(v)) => v,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     }
                    }
                };
                let mut arg2 = vec![];
                if argc > 2 {
                    arg2.reserve(argc as usize - 2);
                    for variadicArg in 2..argc {
                        let slot: HandleValue = args.get(variadicArg);
                        arg2.push(slot);
                    }
                }
                let result: i32 = this.SetInterval_(cx, arg0, arg1, arg2);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            3 => {
                if args.get(0).get().is_object() && !is_platform_object(args.get(0).get().to_object()) {
                    let arg0: Rc<Function<TH>> = if args.get(0).get().is_object() {
                        if IsCallable(args.get(0).get().to_object()) {
                            Function::new(cx, args.get(0).get().to_object())
                        } else {
                            throw_type_error(cx, "Value is not callable.");
                            return false;

                        }
                    } else {
                        throw_type_error(cx, "Value is not an object.");
                        return false;

                    };
                    let arg1: i32 = if args.get(1).is_undefined() {
                        0
                    } else {
                        match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return false;

                            }
                            _ => { return false;
                         }
                        }
                    };
                    let mut arg2 = vec![];
                    if argc > 2 {
                        arg2.reserve(argc as usize - 2);
                        for variadicArg in 2..argc {
                            let slot: HandleValue = args.get(variadicArg);
                            arg2.push(slot);
                        }
                    }
                    let result: i32 = this.SetInterval(cx, arg0, arg1, arg2);

                    (result).to_jsval(cx, args.rval());
                    return true;
                }
                let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
                    Ok(ConversionResult::Success(strval)) => strval,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                let arg1: i32 = if args.get(1).is_undefined() {
                    0
                } else {
                    match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                        Ok(ConversionResult::Success(v)) => v,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     }
                    }
                };
                let mut arg2 = vec![];
                if argc > 2 {
                    arg2.reserve(argc as usize - 2);
                    for variadicArg in 2..argc {
                        let slot: HandleValue = args.get(variadicArg);
                        arg2.push(slot);
                    }
                }
                let result: i32 = this.SetInterval_(cx, arg0, arg1, arg2);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            _ => {
                throw_type_error(cx, "Not enough arguments to \"Window.setInterval\".");
                return false;
            }
        }
    }), false);
}


fn setInterval_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: setInterval::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn clearInterval<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: i32 = if args.get(0).is_undefined() {
            0
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.ClearInterval(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn clearInterval_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: clearInterval::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn fetch<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"Window.fetch\".");
            return false;
        }
        let arg0: UnionTypes::RequestOrUSVString<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let arg1: RootedTraceableBox<dom::bindings::codegen::Bindings::RequestBinding::RequestInit<TH>> = if args.get(1).is_undefined() {
            dom::bindings::codegen::Bindings::RequestBinding::RequestInit::empty(cx)
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
                Ok(ConversionResult::Success(dictionary)) => dictionary,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        let result: Rc<Promise<TH>> = this.Fetch(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn fetch_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: fetch::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_performance<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<Performance<TH>> = this.Performance();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_performance<TH: TypeHolderTrait>
(cx: *mut JSContext, obj: HandleObject, this: *const Window<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        JS_DefineProperty(cx, obj, b"performance\0" as *const u8 as *const libc::c_char,
                          args.get(0), JSPROP_ENUMERATE, None, None)
    }), false);
}


fn performance_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_performance::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn performance_setterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: set_performance::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_sessionStorage<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const Window<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<Storage<TH>> = this.SessionStorage();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn sessionStorage_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_sessionStorage::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::Window as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn _finalize<TH: TypeHolderTrait>
(_fop: *mut JSFreeOp, obj: *mut JSObject) {
    return wrap_panic(panic::AssertUnwindSafe(|| {

        let this = native_from_object::<Window<TH>, TH>(obj).unwrap();
        finalize_global(obj);
            if !this.is_null() {
                // The pointer can be null if the object is the unforgeable holder of that interface.
                let _ = Box::from_raw(this as *mut Window<TH>);
            }
            debug!("Window<TH> finalize: {:p}", this);
    }), ());
}

unsafe extern fn _trace<TH: TypeHolderTrait>
(trc: *mut JSTracer, obj: *mut JSObject) {
    return wrap_panic(panic::AssertUnwindSafe(|| {

        let this = native_from_object::<Window<TH>, TH>(obj).unwrap();
        if this.is_null() { return; } // GC during obj creation
        (*this).trace(trc);
        trace_global(trc, obj);
    }), ());
}

fn CLASS_OPS<TH: TypeHolderTrait>() -> js::jsapi::JSClassOps { js::jsapi::JSClassOps {
    addProperty: None,
    delProperty: None,
    getProperty: None,
    setProperty: None,
    enumerate: Some(enumerate_global),
    resolve: Some(resolve_global),
    mayResolve: None,
    finalize: Some(_finalize::<TH>),
    call: None,
    hasInstance: None,
    construct: None,
    trace: Some(js::jsapi::JS_GlobalObjectTraceHook),
}}

fn Class<TH: TypeHolderTrait>() -> DOMJSClass { DOMJSClass {
    base: js::jsapi::JSClass {
        name: b"Window\0" as *const u8 as *const libc::c_char,
        flags: JSCLASS_IS_DOMJSCLASS | JSCLASS_IS_GLOBAL | JSCLASS_DOM_GLOBAL |
               (((JSCLASS_GLOBAL_SLOT_COUNT + 1) & JSCLASS_RESERVED_SLOTS_MASK) << JSCLASS_RESERVED_SLOTS_SHIFT)
               /* JSCLASS_HAS_RESERVED_SLOTS(JSCLASS_GLOBAL_SLOT_COUNT + 1) */,
        cOps: &CLASS_OPS::<TH>(),
        reserved: [0 as *mut _; 3],
    },
    dom_class: DOMClass {
    interface_chain: [ PrototypeList::ID::EventTarget, PrototypeList::ID::GlobalScope, PrototypeList::ID::Window, PrototypeList::ID::Last, PrototypeList::ID::Last, PrototypeList::ID::Last ],
    type_id: ::dom::bindings::codegen::InheritTypes::TopTypeId { eventtarget: (::dom::bindings::codegen::InheritTypes::EventTargetTypeId::GlobalScope(::dom::bindings::codegen::InheritTypes::GlobalScopeTypeId::Window)) },
    global: InterfaceObjectMap::Globals::WINDOW,
    malloc_size_of: malloc_size_of_including_raw_self::<Window<TH>> as unsafe fn(&mut _, _) -> _,
}
}}

#[inline]
fn malloc_size<TH: TypeHolderTrait>(ops: &mut MallocSizeOfOps, obj: *const c_void) -> usize {
    malloc_size_of_including_raw_self::<Window<TH>>(ops, obj)
}

pub unsafe fn Wrap<TH: TypeHolderTrait>
(cx: *mut JSContext, object: Box<Window<TH>>) -> DomRoot<Window<TH>> {
    let raw = Box::into_raw(object);
    let _rt = RootedTraceable::new(&*raw);

    rooted!(in(cx) let mut obj = ptr::null_mut::<JSObject>());
    create_global_object(
        cx,
        &Class::<TH>().base,
        raw as *const libc::c_void,
        _trace,
        obj.handle_mut());
    assert!(!obj.is_null());

    (*raw).init_reflector(obj.get());

    let _ac = JSAutoCompartment::new(cx, obj.get());
    rooted!(in(cx) let mut proto = ptr::null_mut::<JSObject>());
    GetProtoObject(cx, obj.handle(), proto.handle_mut());
    assert!(JS_SplicePrototype(cx, obj.handle(), proto.handle()));
    let mut immutable = false;
    assert!(JS_SetImmutablePrototype(cx, obj.handle(), &mut immutable));
    assert!(immutable);

    define_guarded_properties(cx, obj.handle(), sAttributes::<TH>());
    define_guarded_methods(cx, obj.handle(), sMethods::<TH>());

    rooted!(in(cx) let mut unforgeable_holder = ptr::null_mut::<JSObject>());
    unforgeable_holder.handle_mut().set(
        JS_GetReservedSlot(proto.get(), DOM_PROTO_UNFORGEABLE_HOLDER_SLOT).to_object());
    assert!(JS_CopyPropertiesFrom(cx, obj.handle(), unforgeable_holder.handle()));


    DomRoot::from_ref(&*raw)
}

impl<TH: TypeHolderTrait> IDLInterface for Window<TH> {
    #[inline]
    fn derives(class: &'static DOMClass) -> bool {
        class as *const _ == &Class::<TH>().dom_class as *const _
    }
}

impl<TH: TypeHolderTrait> PartialEq for Window<TH> {
    fn eq(&self, other: &Window<TH>) -> bool {
        self as *const Window<TH> == &*other
    }
}

pub trait WindowMethods<TH: TypeHolderTrait> {
    fn Window(&self) -> DomRoot<WindowProxy<TH>>;
    fn Self_(&self) -> DomRoot<WindowProxy<TH>>;
    fn Document(&self) -> DomRoot<Document<TH>>;
    fn Name(&self) -> DOMString;
    fn SetName(&self, value: DOMString) -> ();
    fn Location(&self) -> DomRoot<Location<TH>>;
    fn History(&self) -> DomRoot<History<TH>>;
    fn CustomElements(&self) -> DomRoot<CustomElementRegistry<TH>>;
    fn Status(&self) -> DOMString;
    fn SetStatus(&self, value: DOMString) -> ();
    fn Close(&self) -> ();
    fn Closed(&self) -> bool;
    fn Frames(&self) -> DomRoot<WindowProxy<TH>>;
    fn GetTop(&self) -> Option<DomRoot<WindowProxy<TH>>>;
    fn GetParent(&self) -> Option<DomRoot<WindowProxy<TH>>>;
    fn GetFrameElement(&self) -> Option<DomRoot<Element<TH>>>;
    fn Navigator(&self) -> DomRoot<Navigator<TH>>;
    fn Alert(&self, message: DOMString) -> ();
    fn Alert_(&self) -> ();
    fn RequestAnimationFrame(&self, callback: Rc<FrameRequestCallback<TH>>) -> u32;
    fn CancelAnimationFrame(&self, handle: u32) -> ();
    unsafe fn PostMessage(&self, cx: *mut JSContext, message: HandleValue, targetOrigin: DOMString) -> Fallible<(), TH>;
    fn CaptureEvents(&self) -> ();
    fn ReleaseEvents(&self) -> ();
    fn GetComputedStyle(&self, elt: &Element<TH>, pseudoElt: Option<DOMString>) -> DomRoot<CSSStyleDeclaration<TH>>;
    fn MatchMedia(&self, query: DOMString) -> DomRoot<MediaQueryList<TH>>;
    fn Screen(&self) -> DomRoot<Screen<TH>>;
    fn MoveTo(&self, x: i32, y: i32) -> ();
    fn MoveBy(&self, x: i32, y: i32) -> ();
    fn ResizeTo(&self, x: i32, y: i32) -> ();
    fn ResizeBy(&self, x: i32, y: i32) -> ();
    fn InnerWidth(&self) -> i32;
    fn InnerHeight(&self) -> i32;
    fn ScrollX(&self) -> i32;
    fn PageXOffset(&self) -> i32;
    fn ScrollY(&self) -> i32;
    fn PageYOffset(&self) -> i32;
    fn Scroll(&self, options: &dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions) -> ();
    fn Scroll_(&self, x: f64, y: f64) -> ();
    fn ScrollTo(&self, options: &dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions) -> ();
    fn ScrollTo_(&self, x: f64, y: f64) -> ();
    fn ScrollBy(&self, options: &dom::bindings::codegen::Bindings::WindowBinding::ScrollToOptions) -> ();
    fn ScrollBy_(&self, x: f64, y: f64) -> ();
    fn ScreenX(&self) -> i32;
    fn ScreenY(&self) -> i32;
    fn OuterWidth(&self) -> i32;
    fn OuterHeight(&self) -> i32;
    fn DevicePixelRatio(&self) -> Finite<f64>;
    fn Debug(&self, arg: DOMString) -> ();
    fn Gc(&self) -> ();
    fn Trap(&self) -> ();
    unsafe fn WebdriverCallback(&self, cx: *mut JSContext, result: HandleValue) -> ();
    fn WebdriverTimeout(&self) -> ();
    fn TestRunner(&self) -> DomRoot<TestRunner<TH>>;
    fn Crypto(&self) -> DomRoot<Crypto<TH>>;
    fn GetOnabort(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnabort(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnblur(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnblur(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOncancel(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOncancel(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOncanplay(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOncanplay(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOncanplaythrough(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOncanplaythrough(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnchange(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnchange(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnclick(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnclick(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnclose(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnclose(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOncontextmenu(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOncontextmenu(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOncuechange(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOncuechange(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOndblclick(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOndblclick(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOndrag(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOndrag(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOndragend(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOndragend(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOndragenter(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOndragenter(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOndragexit(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOndragexit(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOndragleave(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOndragleave(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOndragover(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOndragover(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOndragstart(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOndragstart(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOndrop(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOndrop(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOndurationchange(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOndurationchange(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnemptied(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnemptied(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnended(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnended(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnerror(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::OnErrorEventHandlerNonNull<TH>>>;
    fn SetOnerror(&self, value: Option<Rc<OnErrorEventHandlerNonNull<TH>>>) -> ();
    fn GetOnfocus(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnfocus(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOninput(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOninput(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOninvalid(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOninvalid(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnkeydown(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnkeydown(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnkeypress(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnkeypress(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnkeyup(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnkeyup(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnload(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnload(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnloadeddata(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnloadeddata(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnloadedmetadata(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnloadedmetadata(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnloadstart(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnloadstart(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnmousedown(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnmousedown(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnmouseenter(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnmouseenter(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnmouseleave(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnmouseleave(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnmousemove(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnmousemove(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnmouseout(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnmouseout(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnmouseover(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnmouseover(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnmouseup(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnmouseup(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnwheel(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnwheel(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnpause(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnpause(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnplay(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnplay(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnplaying(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnplaying(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnprogress(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnprogress(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnratechange(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnratechange(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnreset(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnreset(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnresize(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnresize(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnscroll(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnscroll(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnseeked(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnseeked(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnseeking(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnseeking(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnselect(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnselect(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnshow(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnshow(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnstalled(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnstalled(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnsubmit(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnsubmit(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnsuspend(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnsuspend(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOntimeupdate(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOntimeupdate(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOntoggle(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOntoggle(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnvolumechange(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnvolumechange(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnwaiting(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnwaiting(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOntransitionend(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOntransitionend(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnafterprint(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnafterprint(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnbeforeprint(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnbeforeprint(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnbeforeunload(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::OnBeforeUnloadEventHandlerNonNull<TH>>>;
    fn SetOnbeforeunload(&self, value: Option<Rc<OnBeforeUnloadEventHandlerNonNull<TH>>>) -> ();
    fn GetOnhashchange(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnhashchange(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnlanguagechange(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnlanguagechange(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnmessage(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnmessage(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnoffline(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnoffline(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnonline(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnonline(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnpagehide(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnpagehide(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnpageshow(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnpageshow(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnpopstate(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnpopstate(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnrejectionhandled(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnrejectionhandled(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnstorage(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnstorage(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnunhandledrejection(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnunhandledrejection(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnunload(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnunload(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnvrdisplayconnect(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnvrdisplayconnect(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnvrdisplaydisconnect(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnvrdisplaydisconnect(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnvrdisplayactivate(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnvrdisplayactivate(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnvrdisplaydeactivate(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnvrdisplaydeactivate(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnvrdisplayblur(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnvrdisplayblur(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnvrdisplayfocus(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnvrdisplayfocus(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn GetOnvrdisplaypresentchange(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::EventHandlerNonNull<TH>>>;
    fn SetOnvrdisplaypresentchange(&self, value: Option<Rc<EventHandlerNonNull<TH>>>) -> ();
    fn LocalStorage(&self) -> DomRoot<Storage<TH>>;
    fn Origin(&self) -> USVString;
    fn Btoa(&self, data: DOMString) -> Fallible<DOMString, TH>;
    fn Atob(&self, data: DOMString) -> Fallible<DOMString, TH>;
    unsafe fn SetTimeout(&self, cx: *mut JSContext, handler: Rc<Function<TH>>, timeout: i32, arguments: Vec<HandleValue>) -> i32;
    unsafe fn SetTimeout_(&self, cx: *mut JSContext, handler: DOMString, timeout: i32, arguments: Vec<HandleValue>) -> i32;
    fn ClearTimeout(&self, handle: i32) -> ();
    unsafe fn SetInterval(&self, cx: *mut JSContext, handler: Rc<Function<TH>>, timeout: i32, arguments: Vec<HandleValue>) -> i32;
    unsafe fn SetInterval_(&self, cx: *mut JSContext, handler: DOMString, timeout: i32, arguments: Vec<HandleValue>) -> i32;
    fn ClearInterval(&self, handle: i32) -> ();
    fn Fetch(&self, input: UnionTypes::RequestOrUSVString<TH>, init: RootedTraceableBox<dom::bindings::codegen::Bindings::RequestBinding::RequestInit<TH>>) -> Rc<Promise<TH>>;
    fn Performance(&self) -> DomRoot<Performance<TH>>;
    fn SessionStorage(&self) -> DomRoot<Storage<TH>>;
}
fn sMethods_specs<TH: TypeHolderTrait>() -> &'static [&'static[JSFunctionSpec]] { &[
&[
    JSFunctionSpec {
        name: b"close\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &close_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"alert\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &alert_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"requestAnimationFrame\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &requestAnimationFrame_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"cancelAnimationFrame\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &cancelAnimationFrame_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"postMessage\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &postMessage_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"captureEvents\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &captureEvents_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"releaseEvents\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &releaseEvents_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getComputedStyle\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getComputedStyle_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"matchMedia\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &matchMedia_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"moveTo\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &moveTo_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"moveBy\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &moveBy_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"resizeTo\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &resizeTo_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"resizeBy\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &resizeBy_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"scroll\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &scroll_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"scrollTo\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &scrollTo_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"scrollBy\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &scrollBy_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"debug\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &debug_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"gc\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &gc_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"trap\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &trap_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"webdriverCallback\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &webdriverCallback_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"webdriverTimeout\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &webdriverTimeout_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"btoa\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &btoa_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"atob\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &atob_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"setTimeout\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &setTimeout_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"clearTimeout\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &clearTimeout_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"setInterval\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &setInterval_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"clearInterval\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &clearInterval_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"fetch\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &fetch_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]

]}
fn sMethods<TH: TypeHolderTrait>() -> &'static [Guard<&'static [JSFunctionSpec]>] { &[
    Guard::new(Condition::Satisfied, sMethods_specs::<TH>()[0])
]}
fn sAttributes_specs<TH: TypeHolderTrait>() -> &'static [&'static[JSPropertySpec]] { &[
&[
    JSPropertySpec {
        name: b"self\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &self_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &self_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"name\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &name_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &name_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"history\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &history_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]
,
&[
    JSPropertySpec {
        name: b"customElements\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &customElements_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]
,
&[
    JSPropertySpec {
        name: b"status\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &status_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &status_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"closed\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &closed_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"frames\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &frames_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &frames_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"parent\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &parent_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"frameElement\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &frameElement_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"navigator\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &navigator_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"screen\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &screen_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"innerWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &innerWidth_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"innerHeight\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &innerHeight_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"scrollX\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &scrollX_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"pageXOffset\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &pageXOffset_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"scrollY\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &scrollY_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"pageYOffset\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &pageYOffset_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"screenX\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &screenX_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"screenY\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &screenY_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"outerWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &outerWidth_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"outerHeight\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &outerHeight_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"devicePixelRatio\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &devicePixelRatio_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]
,
&[
    JSPropertySpec {
        name: b"testRunner\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &testRunner_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]
,
&[
    JSPropertySpec {
        name: b"crypto\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &crypto_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"onabort\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onabort_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onabort_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onblur\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onblur_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onblur_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"oncancel\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &oncancel_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &oncancel_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"oncanplay\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &oncanplay_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &oncanplay_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"oncanplaythrough\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &oncanplaythrough_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &oncanplaythrough_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onchange\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onchange_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onchange_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onclick\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onclick_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onclick_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onclose\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onclose_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onclose_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"oncontextmenu\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &oncontextmenu_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &oncontextmenu_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"oncuechange\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &oncuechange_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &oncuechange_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"ondblclick\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &ondblclick_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &ondblclick_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"ondrag\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &ondrag_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &ondrag_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"ondragend\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &ondragend_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &ondragend_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"ondragenter\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &ondragenter_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &ondragenter_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"ondragexit\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &ondragexit_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &ondragexit_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"ondragleave\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &ondragleave_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &ondragleave_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"ondragover\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &ondragover_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &ondragover_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"ondragstart\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &ondragstart_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &ondragstart_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"ondrop\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &ondrop_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &ondrop_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"ondurationchange\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &ondurationchange_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &ondurationchange_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onemptied\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onemptied_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onemptied_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onended\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onended_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onended_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onerror\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onerror_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onerror_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onfocus\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onfocus_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onfocus_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"oninput\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &oninput_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &oninput_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"oninvalid\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &oninvalid_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &oninvalid_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onkeydown\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onkeydown_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onkeydown_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onkeypress\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onkeypress_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onkeypress_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onkeyup\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onkeyup_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onkeyup_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onload\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onload_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onload_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onloadeddata\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onloadeddata_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onloadeddata_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onloadedmetadata\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onloadedmetadata_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onloadedmetadata_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onloadstart\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onloadstart_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onloadstart_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onmousedown\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onmousedown_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onmousedown_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onmouseenter\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_lenient_getter), info: &onmouseenter_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_lenient_setter), info: &onmouseenter_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onmouseleave\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_lenient_getter), info: &onmouseleave_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_lenient_setter), info: &onmouseleave_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onmousemove\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onmousemove_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onmousemove_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onmouseout\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onmouseout_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onmouseout_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onmouseover\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onmouseover_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onmouseover_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onmouseup\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onmouseup_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onmouseup_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onwheel\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onwheel_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onwheel_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onpause\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onpause_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onpause_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onplay\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onplay_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onplay_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onplaying\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onplaying_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onplaying_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onprogress\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onprogress_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onprogress_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onratechange\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onratechange_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onratechange_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onreset\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onreset_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onreset_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onresize\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onresize_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onresize_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onscroll\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onscroll_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onscroll_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onseeked\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onseeked_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onseeked_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onseeking\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onseeking_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onseeking_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onselect\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onselect_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onselect_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onshow\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onshow_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onshow_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onstalled\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onstalled_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onstalled_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onsubmit\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onsubmit_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onsubmit_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onsuspend\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onsuspend_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onsuspend_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"ontimeupdate\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &ontimeupdate_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &ontimeupdate_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"ontoggle\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &ontoggle_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &ontoggle_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onvolumechange\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onvolumechange_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onvolumechange_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onwaiting\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onwaiting_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onwaiting_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"ontransitionend\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &ontransitionend_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &ontransitionend_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onafterprint\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onafterprint_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onafterprint_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onbeforeprint\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onbeforeprint_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onbeforeprint_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onbeforeunload\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onbeforeunload_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onbeforeunload_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onhashchange\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onhashchange_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onhashchange_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onlanguagechange\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onlanguagechange_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onlanguagechange_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onmessage\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onmessage_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onmessage_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onoffline\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onoffline_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onoffline_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"ononline\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &ononline_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &ononline_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onpagehide\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onpagehide_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onpagehide_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onpageshow\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onpageshow_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onpageshow_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onpopstate\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onpopstate_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onpopstate_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onrejectionhandled\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onrejectionhandled_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onrejectionhandled_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onstorage\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onstorage_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onstorage_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onunhandledrejection\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onunhandledrejection_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onunhandledrejection_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onunload\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onunload_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onunload_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onvrdisplayconnect\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onvrdisplayconnect_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onvrdisplayconnect_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onvrdisplaydisconnect\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onvrdisplaydisconnect_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onvrdisplaydisconnect_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onvrdisplayactivate\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onvrdisplayactivate_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onvrdisplayactivate_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onvrdisplaydeactivate\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onvrdisplaydeactivate_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onvrdisplaydeactivate_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onvrdisplayblur\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onvrdisplayblur_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onvrdisplayblur_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onvrdisplayfocus\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onvrdisplayfocus_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onvrdisplayfocus_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"onvrdisplaypresentchange\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onvrdisplaypresentchange_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onvrdisplaypresentchange_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"localStorage\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &localStorage_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"origin\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &origin_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &origin_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"performance\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &performance_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &performance_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"sessionStorage\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &sessionStorage_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]

]}
fn sAttributes<TH: TypeHolderTrait>() -> &'static [Guard<&'static [JSPropertySpec]>] { &[
    Guard::new(Condition::Satisfied, sAttributes_specs::<TH>()[0]),
    Guard::new(Condition::Pref("dom.customelements.enabled"), sAttributes_specs::<TH>()[1]),
    Guard::new(Condition::Satisfied, sAttributes_specs::<TH>()[2]),
    Guard::new(Condition::Pref("dom.bluetooth.testing.enabled"), sAttributes_specs::<TH>()[3]),
    Guard::new(Condition::Satisfied, sAttributes_specs::<TH>()[4])
]}
fn sUnforgeableAttributes_specs<TH: TypeHolderTrait>() -> &'static [&'static[JSPropertySpec]] { &[
&[
    JSPropertySpec {
        name: b"window\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED | JSPROP_PERMANENT) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &window_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"document\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED | JSPROP_PERMANENT) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &document_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"location\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED | JSPROP_PERMANENT) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &location_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"top\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED | JSPROP_PERMANENT) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &top_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]

]}
fn sUnforgeableAttributes<TH: TypeHolderTrait>() -> &'static [Guard<&'static [JSPropertySpec]>] { &[
    Guard::new(Condition::Satisfied, sUnforgeableAttributes_specs::<TH>()[0])
]}

pub unsafe fn GetProtoObject<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject, mut rval: MutableHandleObject) {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    assert!(((*get_object_class(global.get())).flags & JSCLASS_DOM_GLOBAL) != 0);

    /* Check to see whether the interface objects are already installed */
    let proto_or_iface_array = get_proto_or_iface_array(global.get());
    rval.set((*proto_or_iface_array)[PrototypeList::ID::Window as usize]);
    if !rval.get().is_null() {
        return;
    }

    CreateInterfaceObjects(cx, global, proto_or_iface_array);
    rval.set((*proto_or_iface_array)[PrototypeList::ID::Window as usize]);
    assert!(!rval.get().is_null());

}

static PrototypeClass: JSClass = JSClass {
    name: b"WindowPrototype\0" as *const u8 as *const libc::c_char,
    flags:
        // JSCLASS_HAS_RESERVED_SLOTS(1)
        (1 & JSCLASS_RESERVED_SLOTS_MASK) << JSCLASS_RESERVED_SLOTS_SHIFT,
    cOps: 0 as *const _,
    reserved: [0 as *mut os::raw::c_void; 3]
};

static INTERFACE_OBJECT_CLASS: NonCallbackInterfaceObjectClass =
    NonCallbackInterfaceObjectClass::new(
        &InterfaceConstructorBehavior::throw(),
        b"function Window() {\n    [native code]\n}",
        PrototypeList::ID::Window,
        2);

pub unsafe fn DefineDOMInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject) {
    assert!(!global.get().is_null());

    if !ConstructorEnabled(cx, global) {
        return;
    }

    rooted!(in(cx) let mut proto = ptr::null_mut::<JSObject>());
    GetProtoObject(cx, global, proto.handle_mut());
    assert!(!proto.is_null());
}

unsafe fn ConstructorEnabled<TH: TypeHolderTrait>
(aCx: *mut JSContext, aObj: HandleObject) -> bool {
    is_exposed_in(aObj, InterfaceObjectMap::Globals::WINDOW)
}

unsafe fn CreateInterfaceObjects<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject, cache: *mut ProtoOrIfaceArray) {
    rooted!(in(cx) let mut prototype_proto = ptr::null_mut::<JSObject>());
    EventTargetBinding::GetProtoObject(cx, global, prototype_proto.handle_mut());
    assert!(!prototype_proto.is_null());

    rooted!(in(cx) let mut prototype = ptr::null_mut::<JSObject>());
    create_interface_prototype_object(cx,
                                      prototype_proto.handle().into(),
                                      &PrototypeClass,
                                      &[],
                                      &[],
                                      &[],
                                      &[],
                                      prototype.handle_mut().into());
    assert!(!prototype.is_null());
    assert!((*cache)[PrototypeList::ID::Window as usize].is_null());
    (*cache)[PrototypeList::ID::Window as usize] = prototype.get();
    <*mut JSObject>::post_barrier((*cache).as_mut_ptr().offset(PrototypeList::ID::Window as isize),
                                  ptr::null_mut(),
                                  prototype.get());


    rooted!(in(cx) let mut interface_proto = ptr::null_mut::<JSObject>());
    EventTargetBinding::GetConstructorObject(cx, global, interface_proto.handle_mut());
    assert!(!interface_proto.is_null());

    rooted!(in(cx) let mut interface = ptr::null_mut::<JSObject>());
    create_noncallback_interface_object(cx,
                                        global.into(),
                                        interface_proto.handle(),
                                        &INTERFACE_OBJECT_CLASS,
                                        &[],
                                        &[],
                                        &[],
                                        prototype.handle(),
                                        b"Window\0",
                                        0,
                                        interface.handle_mut());
    assert!(!interface.is_null());

    rooted!(in(cx) let mut unforgeable_holder = ptr::null_mut::<JSObject>());
    unforgeable_holder.handle_mut().set(
        JS_NewObjectWithoutMetadata(cx, ptr::null(), HandleObject::null()));
    assert!(!unforgeable_holder.is_null());

    define_guarded_properties(cx, unforgeable_holder.handle(), sUnforgeableAttributes::<TH>());
    JS_SetReservedSlot(prototype.get(), DOM_PROTO_UNFORGEABLE_HOLDER_SLOT,
                       ObjectValue(unforgeable_holder.get()))
}
} // mod WindowBinding


