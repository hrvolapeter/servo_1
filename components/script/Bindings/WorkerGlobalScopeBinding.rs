/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */

#![allow(non_camel_case_types,non_upper_case_globals,unused_imports,unused_variables,unused_assignments,unused_mut)]
use dom;
use dom::bindings;
use dom::bindings::callback::CallSetup;
use dom::bindings::callback::CallbackContainer;
use dom::bindings::callback::CallbackFunction;
use dom::bindings::callback::CallbackInterface;
use dom::bindings::callback::CallbackObject;
use dom::bindings::callback::ExceptionHandling;
use dom::bindings::callback::wrap_call_this_object;
use dom::bindings::codegen::InterfaceObjectMap;
use dom::bindings::codegen::PrototypeList;
use dom::bindings::codegen::RegisterBindings;
use dom::bindings::codegen::UnionTypes;
use dom::bindings::constant::ConstantSpec;
use dom::bindings::constant::ConstantVal;
use dom::bindings::conversions::ConversionBehavior;
use dom::bindings::conversions::ConversionResult;
use dom::bindings::conversions::DOM_OBJECT_SLOT;
use dom::bindings::conversions::FromJSValConvertible;
use dom::bindings::conversions::IDLInterface;
use dom::bindings::conversions::StringificationBehavior;
use dom::bindings::conversions::ToJSValConvertible;
use dom::bindings::conversions::is_array_like;
use dom::bindings::conversions::jsid_to_string;
use dom::bindings::conversions::native_from_handlevalue;
use dom::bindings::conversions::native_from_object;
use dom::bindings::conversions::private_from_object;
use dom::bindings::conversions::root_from_handleobject;
use dom::bindings::conversions::root_from_handlevalue;
use dom::bindings::conversions::root_from_object;
use dom::bindings::error::Error;
use dom::bindings::error::Error::JSFailed;
use dom::bindings::error::ErrorResult;
use dom::bindings::error::Fallible;
use dom::bindings::error::throw_dom_exception;
use dom::bindings::guard::Condition;
use dom::bindings::guard::Guard;
use dom::bindings::htmlconstructor::html_constructor;
use dom::bindings::htmlconstructor::pop_current_element_queue;
use dom::bindings::htmlconstructor::push_new_element_queue;
use dom::bindings::inheritance::Castable;
use dom::bindings::interface::ConstructorClassHook;
use dom::bindings::interface::InterfaceConstructorBehavior;
use dom::bindings::interface::NonCallbackInterfaceObjectClass;
use dom::bindings::interface::create_callback_interface_object;
use dom::bindings::interface::create_global_object;
use dom::bindings::interface::create_interface_prototype_object;
use dom::bindings::interface::create_named_constructors;
use dom::bindings::interface::create_noncallback_interface_object;
use dom::bindings::interface::define_guarded_constants;
use dom::bindings::interface::define_guarded_methods;
use dom::bindings::interface::define_guarded_properties;
use dom::bindings::interface::is_exposed_in;
use dom::bindings::iterable::Iterable;
use dom::bindings::iterable::IteratorType;
use dom::bindings::mozmap::MozMap;
use dom::bindings::namespace::NamespaceObjectClass;
use dom::bindings::namespace::create_namespace_object;
use dom::bindings::num::Finite;
use dom::bindings::proxyhandler;
use dom::bindings::proxyhandler::ensure_expando_object;
use dom::bindings::proxyhandler::fill_property_descriptor;
use dom::bindings::proxyhandler::get_expando_object;
use dom::bindings::proxyhandler::get_property_descriptor;
use dom::bindings::reflector::DomObject;
use dom::bindings::reflector::MutDomObject;
use dom::bindings::root::Dom;
use dom::bindings::root::DomRoot;
use dom::bindings::root::OptionalHeapSetter;
use dom::bindings::root::RootedReference;
use dom::bindings::str::ByteString;
use dom::bindings::str::DOMString;
use dom::bindings::str::USVString;
use dom::bindings::trace::JSTraceable;
use dom::bindings::trace::RootedTraceable;
use dom::bindings::trace::RootedTraceableBox;
use dom::bindings::utils::AsVoidPtr;
use dom::bindings::utils::DOMClass;
use dom::bindings::utils::DOMJSClass;
use dom::bindings::utils::DOM_PROTO_UNFORGEABLE_HOLDER_SLOT;
use dom::bindings::utils::JSCLASS_DOM_GLOBAL;
use dom::bindings::utils::ProtoOrIfaceArray;
use dom::bindings::utils::enumerate_global;
use dom::bindings::utils::finalize_global;
use dom::bindings::utils::find_enum_value;
use dom::bindings::utils::generic_getter;
use dom::bindings::utils::generic_lenient_getter;
use dom::bindings::utils::generic_lenient_setter;
use dom::bindings::utils::generic_method;
use dom::bindings::utils::generic_setter;
use dom::bindings::utils::get_array_index_from_id;
use dom::bindings::utils::get_dictionary_property;
use dom::bindings::utils::get_property_on_prototype;
use dom::bindings::utils::get_proto_or_iface_array;
use dom::bindings::utils::has_property_on_prototype;
use dom::bindings::utils::is_platform_object;
use dom::bindings::utils::resolve_global;
use dom::bindings::utils::set_dictionary_property;
use dom::bindings::utils::trace_global;
use dom::bindings::weakref::DOM_WEAK_SLOT;
use dom::bindings::weakref::WeakBox;
use dom::bindings::weakref::WeakReferenceable;
use dom::globalscope::GlobalScope;
use dom::windowproxy::WindowProxy;
use js;
use js::JSCLASS_GLOBAL_SLOT_COUNT;
use js::JSCLASS_IS_DOMJSCLASS;
use js::JSCLASS_IS_GLOBAL;
use js::JSCLASS_RESERVED_SLOTS_MASK;
use js::JS_CALLEE;
use js::error::throw_internal_error;
use js::error::throw_type_error;
use js::glue::AppendToAutoIdVector;
use js::glue::CallJitGetterOp;
use js::glue::CallJitMethodOp;
use js::glue::CallJitSetterOp;
use js::glue::CreateProxyHandler;
use js::glue::GetProxyPrivate;
use js::glue::ProxyTraps;
use js::glue::RUST_JSID_IS_INT;
use js::glue::RUST_JSID_IS_STRING;
use js::glue::RUST_SYMBOL_TO_JSID;
use js::glue::UnwrapObject;
use js::glue::int_to_jsid;
use js::jsapi::AutoIdVector;
use js::jsapi::CallArgs;
use js::jsapi::CurrentGlobalOrNull;
use js::jsapi::FreeOp;
use js::jsapi::GetWellKnownSymbol;
use js::jsapi::Handle as RawHandle;
use js::jsapi::HandleId as RawHandleId;
use js::jsapi::HandleObject as RawHandleObject;
use js::jsapi::HandleValue as RawHandleValue;
use js::jsapi::HandleValueArray;
use js::jsapi::Heap;
use js::jsapi::INTERNED_STRING_TO_JSID;
use js::jsapi::IsCallable;
use js::jsapi::JSAutoCompartment;
use js::jsapi::JSCLASS_RESERVED_SLOTS_SHIFT;
use js::jsapi::JSClass;
use js::jsapi::JSContext;
use js::jsapi::JSFreeOp;
use js::jsapi::JSFunctionSpec;
use js::jsapi::JSITER_HIDDEN;
use js::jsapi::JSITER_OWNONLY;
use js::jsapi::JSITER_SYMBOLS;
use js::jsapi::JSJitGetterCallArgs;
use js::jsapi::JSJitInfo;
use js::jsapi::JSJitInfo_AliasSet;
use js::jsapi::JSJitInfo_ArgType;
use js::jsapi::JSJitInfo_OpType;
use js::jsapi::JSJitMethodCallArgs;
use js::jsapi::JSJitSetterCallArgs;
use js::jsapi::JSNative;
use js::jsapi::JSNativeWrapper;
use js::jsapi::JSObject;
use js::jsapi::JSPROP_ENUMERATE;
use js::jsapi::JSPROP_PERMANENT;
use js::jsapi::JSPROP_READONLY;
use js::jsapi::JSPROP_SHARED;
use js::jsapi::JSPropertySpec;
use js::jsapi::JSString;
use js::jsapi::JSTracer;
use js::jsapi::JSType;
use js::jsapi::JSTypedMethodJitInfo;
use js::jsapi::JSValueType;
use js::jsapi::JS_AtomizeAndPinString;
use js::jsapi::JS_ForwardGetPropertyTo;
use js::jsapi::JS_GetErrorPrototype;
use js::jsapi::JS_GetGlobalForObject;
use js::jsapi::JS_GetIteratorPrototype;
use js::jsapi::JS_GetPropertyById;
use js::jsapi::JS_GetPropertyDescriptorById;
use js::jsapi::JS_GetReservedSlot;
use js::jsapi::JS_HasProperty;
use js::jsapi::JS_HasPropertyById;
use js::jsapi::JS_NewObject;
use js::jsapi::JS_SetReservedSlot;
use js::jsapi::MutableHandle as RawMutableHandle;
use js::jsapi::MutableHandleObject as RawMutableHandleObject;
use js::jsapi::MutableHandleValue as RawMutableHandleValue;
use js::jsapi::ObjectOpResult;
use js::jsapi::PropertyDescriptor;
use js::jsapi::Rooted;
use js::jsapi::RootedId;
use js::jsapi::RootedObject;
use js::jsapi::RootedString;
use js::jsapi::SymbolCode;
use js::jsapi::jsid;
use js::jsval::JSVal;
use js::jsval::NullValue;
use js::jsval::ObjectOrNullValue;
use js::jsval::ObjectValue;
use js::jsval::PrivateValue;
use js::jsval::UndefinedValue;
use js::panic::maybe_resume_unwind;
use js::panic::wrap_panic;
use js::rust::CustomAutoRooterGuard;
use js::rust::GCMethods;
use js::rust::Handle;
use js::rust::HandleId;
use js::rust::HandleObject;
use js::rust::HandleValue;
use js::rust::MutableHandle;
use js::rust::MutableHandleObject;
use js::rust::MutableHandleValue;
use js::rust::define_methods;
use js::rust::define_properties;
use js::rust::get_object_class;
use js::rust::wrappers::Call;
use js::rust::wrappers::GetPropertyKeys;
use js::rust::wrappers::JS_CallFunctionValue;
use js::rust::wrappers::JS_CopyPropertiesFrom;
use js::rust::wrappers::JS_DefineProperty;
use js::rust::wrappers::JS_DefinePropertyById2;
use js::rust::wrappers::JS_GetFunctionPrototype;
use js::rust::wrappers::JS_GetObjectPrototype;
use js::rust::wrappers::JS_GetProperty;
use js::rust::wrappers::JS_InitializePropertiesFromCompatibleNativeObject;
use js::rust::wrappers::JS_NewObjectWithGivenProto;
use js::rust::wrappers::JS_NewObjectWithoutMetadata;
use js::rust::wrappers::JS_ObjectIsDate;
use js::rust::wrappers::JS_SetImmutablePrototype;
use js::rust::wrappers::JS_SetProperty;
use js::rust::wrappers::JS_SetPrototype;
use js::rust::wrappers::JS_SplicePrototype;
use js::rust::wrappers::JS_WrapObject;
use js::rust::wrappers::JS_WrapValue;
use js::rust::wrappers::NewProxyObject;
use js::typedarray;
use libc;
use malloc_size_of::MallocSizeOfOps;
use mem::malloc_size_of_including_raw_self;
use servo_config::prefs::PREFS;
use std::borrow::ToOwned;
use std::cmp;
use std::default::Default;
use std::ffi::CString;
use std::mem;
use std::num;
use std::os;
use std::os::raw::c_void;
use std::panic;
use std::ptr;
use std::ptr::NonNull;
use std::rc;
use std::rc::Rc;
use std::str;
use typeholder::TypeHolderTrait;

pub use self::WorkerGlobalScopeBinding::{WorkerGlobalScopeMethods, GetProtoObject, GetConstructorObject, DefineDOMInterface};
pub mod WorkerGlobalScopeBinding {
#![allow(non_camel_case_types,non_upper_case_globals,unused_imports,unused_variables,unused_assignments,unused_mut)]
use dom;
use dom::bindings;
use dom::bindings::callback::CallSetup;
use dom::bindings::callback::CallbackContainer;
use dom::bindings::callback::CallbackFunction;
use dom::bindings::callback::CallbackInterface;
use dom::bindings::callback::CallbackObject;
use dom::bindings::callback::ExceptionHandling;
use dom::bindings::callback::wrap_call_this_object;
use dom::bindings::codegen::Bindings::EventHandlerBinding::OnErrorEventHandlerNonNull;
use dom::bindings::codegen::Bindings::EventTargetBinding::EventTargetBinding;
use dom::bindings::codegen::Bindings::FunctionBinding::Function;
use dom::bindings::codegen::Bindings::RequestBinding::ReferrerPolicy;
use dom::bindings::codegen::Bindings::RequestBinding::ReferrerPolicyValues;
use dom::bindings::codegen::Bindings::RequestBinding::RequestCache;
use dom::bindings::codegen::Bindings::RequestBinding::RequestCacheValues;
use dom::bindings::codegen::Bindings::RequestBinding::RequestCredentials;
use dom::bindings::codegen::Bindings::RequestBinding::RequestCredentialsValues;
use dom::bindings::codegen::Bindings::RequestBinding::RequestInit;
use dom::bindings::codegen::Bindings::RequestBinding::RequestMode;
use dom::bindings::codegen::Bindings::RequestBinding::RequestModeValues;
use dom::bindings::codegen::Bindings::RequestBinding::RequestRedirect;
use dom::bindings::codegen::Bindings::RequestBinding::RequestRedirectValues;
use dom::bindings::codegen::InterfaceObjectMap;
use dom::bindings::codegen::PrototypeList;
use dom::bindings::codegen::RegisterBindings;
use dom::bindings::codegen::UnionTypes;
use dom::bindings::constant::ConstantSpec;
use dom::bindings::constant::ConstantVal;
use dom::bindings::conversions::ConversionBehavior;
use dom::bindings::conversions::ConversionResult;
use dom::bindings::conversions::DOM_OBJECT_SLOT;
use dom::bindings::conversions::FromJSValConvertible;
use dom::bindings::conversions::IDLInterface;
use dom::bindings::conversions::StringificationBehavior;
use dom::bindings::conversions::ToJSValConvertible;
use dom::bindings::conversions::is_array_like;
use dom::bindings::conversions::jsid_to_string;
use dom::bindings::conversions::native_from_handlevalue;
use dom::bindings::conversions::native_from_object;
use dom::bindings::conversions::private_from_object;
use dom::bindings::conversions::root_from_handleobject;
use dom::bindings::conversions::root_from_handlevalue;
use dom::bindings::conversions::root_from_object;
use dom::bindings::error::Error;
use dom::bindings::error::Error::JSFailed;
use dom::bindings::error::ErrorResult;
use dom::bindings::error::Fallible;
use dom::bindings::error::throw_dom_exception;
use dom::bindings::guard::Condition;
use dom::bindings::guard::Guard;
use dom::bindings::htmlconstructor::html_constructor;
use dom::bindings::htmlconstructor::pop_current_element_queue;
use dom::bindings::htmlconstructor::push_new_element_queue;
use dom::bindings::inheritance::Castable;
use dom::bindings::interface::ConstructorClassHook;
use dom::bindings::interface::InterfaceConstructorBehavior;
use dom::bindings::interface::NonCallbackInterfaceObjectClass;
use dom::bindings::interface::create_callback_interface_object;
use dom::bindings::interface::create_global_object;
use dom::bindings::interface::create_interface_prototype_object;
use dom::bindings::interface::create_named_constructors;
use dom::bindings::interface::create_noncallback_interface_object;
use dom::bindings::interface::define_guarded_constants;
use dom::bindings::interface::define_guarded_methods;
use dom::bindings::interface::define_guarded_properties;
use dom::bindings::interface::is_exposed_in;
use dom::bindings::iterable::Iterable;
use dom::bindings::iterable::IteratorType;
use dom::bindings::mozmap::MozMap;
use dom::bindings::namespace::NamespaceObjectClass;
use dom::bindings::namespace::create_namespace_object;
use dom::bindings::num::Finite;
use dom::bindings::proxyhandler;
use dom::bindings::proxyhandler::ensure_expando_object;
use dom::bindings::proxyhandler::fill_property_descriptor;
use dom::bindings::proxyhandler::get_expando_object;
use dom::bindings::proxyhandler::get_property_descriptor;
use dom::bindings::reflector::DomObject;
use dom::bindings::reflector::MutDomObject;
use dom::bindings::root::Dom;
use dom::bindings::root::DomRoot;
use dom::bindings::root::OptionalHeapSetter;
use dom::bindings::root::RootedReference;
use dom::bindings::str::ByteString;
use dom::bindings::str::DOMString;
use dom::bindings::str::USVString;
use dom::bindings::trace::JSTraceable;
use dom::bindings::trace::RootedTraceable;
use dom::bindings::trace::RootedTraceableBox;
use dom::bindings::utils::AsVoidPtr;
use dom::bindings::utils::DOMClass;
use dom::bindings::utils::DOMJSClass;
use dom::bindings::utils::DOM_PROTO_UNFORGEABLE_HOLDER_SLOT;
use dom::bindings::utils::JSCLASS_DOM_GLOBAL;
use dom::bindings::utils::ProtoOrIfaceArray;
use dom::bindings::utils::enumerate_global;
use dom::bindings::utils::finalize_global;
use dom::bindings::utils::find_enum_value;
use dom::bindings::utils::generic_getter;
use dom::bindings::utils::generic_lenient_getter;
use dom::bindings::utils::generic_lenient_setter;
use dom::bindings::utils::generic_method;
use dom::bindings::utils::generic_setter;
use dom::bindings::utils::get_array_index_from_id;
use dom::bindings::utils::get_dictionary_property;
use dom::bindings::utils::get_property_on_prototype;
use dom::bindings::utils::get_proto_or_iface_array;
use dom::bindings::utils::has_property_on_prototype;
use dom::bindings::utils::is_platform_object;
use dom::bindings::utils::resolve_global;
use dom::bindings::utils::set_dictionary_property;
use dom::bindings::utils::trace_global;
use dom::bindings::weakref::DOM_WEAK_SLOT;
use dom::bindings::weakref::WeakBox;
use dom::bindings::weakref::WeakReferenceable;
use dom::globalscope::GlobalScope;
use dom::promise::Promise;
use dom::types::Crypto;
use dom::types::EventTarget;
use dom::types::Performance;
use dom::types::Request;
use dom::types::WorkerGlobalScope;
use dom::types::WorkerLocation;
use dom::types::WorkerNavigator;
use dom::windowproxy::WindowProxy;
use js;
use js::JSCLASS_GLOBAL_SLOT_COUNT;
use js::JSCLASS_IS_DOMJSCLASS;
use js::JSCLASS_IS_GLOBAL;
use js::JSCLASS_RESERVED_SLOTS_MASK;
use js::JS_CALLEE;
use js::error::throw_internal_error;
use js::error::throw_type_error;
use js::glue::AppendToAutoIdVector;
use js::glue::CallJitGetterOp;
use js::glue::CallJitMethodOp;
use js::glue::CallJitSetterOp;
use js::glue::CreateProxyHandler;
use js::glue::GetProxyPrivate;
use js::glue::ProxyTraps;
use js::glue::RUST_JSID_IS_INT;
use js::glue::RUST_JSID_IS_STRING;
use js::glue::RUST_SYMBOL_TO_JSID;
use js::glue::UnwrapObject;
use js::glue::int_to_jsid;
use js::jsapi::AutoIdVector;
use js::jsapi::CallArgs;
use js::jsapi::CurrentGlobalOrNull;
use js::jsapi::FreeOp;
use js::jsapi::GetWellKnownSymbol;
use js::jsapi::Handle as RawHandle;
use js::jsapi::HandleId as RawHandleId;
use js::jsapi::HandleObject as RawHandleObject;
use js::jsapi::HandleValue as RawHandleValue;
use js::jsapi::HandleValueArray;
use js::jsapi::Heap;
use js::jsapi::INTERNED_STRING_TO_JSID;
use js::jsapi::IsCallable;
use js::jsapi::JSAutoCompartment;
use js::jsapi::JSCLASS_RESERVED_SLOTS_SHIFT;
use js::jsapi::JSClass;
use js::jsapi::JSContext;
use js::jsapi::JSFreeOp;
use js::jsapi::JSFunctionSpec;
use js::jsapi::JSITER_HIDDEN;
use js::jsapi::JSITER_OWNONLY;
use js::jsapi::JSITER_SYMBOLS;
use js::jsapi::JSJitGetterCallArgs;
use js::jsapi::JSJitInfo;
use js::jsapi::JSJitInfo_AliasSet;
use js::jsapi::JSJitInfo_ArgType;
use js::jsapi::JSJitInfo_OpType;
use js::jsapi::JSJitMethodCallArgs;
use js::jsapi::JSJitSetterCallArgs;
use js::jsapi::JSNative;
use js::jsapi::JSNativeWrapper;
use js::jsapi::JSObject;
use js::jsapi::JSPROP_ENUMERATE;
use js::jsapi::JSPROP_PERMANENT;
use js::jsapi::JSPROP_READONLY;
use js::jsapi::JSPROP_SHARED;
use js::jsapi::JSPropertySpec;
use js::jsapi::JSString;
use js::jsapi::JSTracer;
use js::jsapi::JSType;
use js::jsapi::JSTypedMethodJitInfo;
use js::jsapi::JSValueType;
use js::jsapi::JS_AtomizeAndPinString;
use js::jsapi::JS_ForwardGetPropertyTo;
use js::jsapi::JS_GetErrorPrototype;
use js::jsapi::JS_GetGlobalForObject;
use js::jsapi::JS_GetIteratorPrototype;
use js::jsapi::JS_GetPropertyById;
use js::jsapi::JS_GetPropertyDescriptorById;
use js::jsapi::JS_GetReservedSlot;
use js::jsapi::JS_HasProperty;
use js::jsapi::JS_HasPropertyById;
use js::jsapi::JS_NewObject;
use js::jsapi::JS_SetReservedSlot;
use js::jsapi::MutableHandle as RawMutableHandle;
use js::jsapi::MutableHandleObject as RawMutableHandleObject;
use js::jsapi::MutableHandleValue as RawMutableHandleValue;
use js::jsapi::ObjectOpResult;
use js::jsapi::PropertyDescriptor;
use js::jsapi::Rooted;
use js::jsapi::RootedId;
use js::jsapi::RootedObject;
use js::jsapi::RootedString;
use js::jsapi::SymbolCode;
use js::jsapi::jsid;
use js::jsval::JSVal;
use js::jsval::NullValue;
use js::jsval::ObjectOrNullValue;
use js::jsval::ObjectValue;
use js::jsval::PrivateValue;
use js::jsval::UndefinedValue;
use js::panic::maybe_resume_unwind;
use js::panic::wrap_panic;
use js::rust::CustomAutoRooterGuard;
use js::rust::GCMethods;
use js::rust::Handle;
use js::rust::HandleId;
use js::rust::HandleObject;
use js::rust::HandleValue;
use js::rust::MutableHandle;
use js::rust::MutableHandleObject;
use js::rust::MutableHandleValue;
use js::rust::define_methods;
use js::rust::define_properties;
use js::rust::get_object_class;
use js::rust::wrappers::Call;
use js::rust::wrappers::GetPropertyKeys;
use js::rust::wrappers::JS_CallFunctionValue;
use js::rust::wrappers::JS_CopyPropertiesFrom;
use js::rust::wrappers::JS_DefineProperty;
use js::rust::wrappers::JS_DefinePropertyById2;
use js::rust::wrappers::JS_GetFunctionPrototype;
use js::rust::wrappers::JS_GetObjectPrototype;
use js::rust::wrappers::JS_GetProperty;
use js::rust::wrappers::JS_InitializePropertiesFromCompatibleNativeObject;
use js::rust::wrappers::JS_NewObjectWithGivenProto;
use js::rust::wrappers::JS_NewObjectWithoutMetadata;
use js::rust::wrappers::JS_ObjectIsDate;
use js::rust::wrappers::JS_SetImmutablePrototype;
use js::rust::wrappers::JS_SetProperty;
use js::rust::wrappers::JS_SetPrototype;
use js::rust::wrappers::JS_SplicePrototype;
use js::rust::wrappers::JS_WrapObject;
use js::rust::wrappers::JS_WrapValue;
use js::rust::wrappers::NewProxyObject;
use js::typedarray;
use libc;
use malloc_size_of::MallocSizeOfOps;
use mem::malloc_size_of_including_raw_self;
use servo_config::prefs::PREFS;
use std::borrow::ToOwned;
use std::cmp;
use std::default::Default;
use std::ffi::CString;
use std::mem;
use std::num;
use std::os;
use std::os::raw::c_void;
use std::panic;
use std::ptr;
use std::ptr::NonNull;
use std::rc;
use std::rc::Rc;
use std::str;
use typeholder::TypeHolderTrait;

unsafe extern fn get_self<TH: TypeHolderTrait<TH>>
(cx: *mut JSContext, _obj: HandleObject, this: *const WorkerGlobalScope<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<WorkerGlobalScope<TH>> = this.Self_();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn self_getterinfo<TH: TypeHolderTrait<TH>>() -> JSJitInfo { JSJitInfo {
    call: get_self::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WorkerGlobalScope as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_location<TH: TypeHolderTrait<TH>>
(cx: *mut JSContext, _obj: HandleObject, this: *const WorkerGlobalScope<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<WorkerLocation<TH>> = this.Location();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn location_getterinfo<TH: TypeHolderTrait<TH>>() -> JSJitInfo { JSJitInfo {
    call: get_location::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WorkerGlobalScope as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_onerror<TH: TypeHolderTrait<TH>>
(cx: *mut JSContext, _obj: HandleObject, this: *const WorkerGlobalScope<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::OnErrorEventHandlerNonNull<TH>>> = this.GetOnerror();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_onerror<TH: TypeHolderTrait<TH>>
(cx: *mut JSContext, obj: HandleObject, this: *const WorkerGlobalScope<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let arg0: Option<Rc<OnErrorEventHandlerNonNull<TH>>> = if args.get(0).get().is_object() {
            Some(OnErrorEventHandlerNonNull::new(cx, args.get(0).get().to_object()))
        } else {
            None
        };
        let result: () = this.SetOnerror(arg0);

        return true;
    }), false);
}


fn onerror_getterinfo<TH: TypeHolderTrait<TH>>() -> JSJitInfo { JSJitInfo {
    call: get_onerror::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WorkerGlobalScope as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn onerror_setterinfo<TH: TypeHolderTrait<TH>>() -> JSJitInfo { JSJitInfo {
    call: set_onerror::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WorkerGlobalScope as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn importScripts<TH: TypeHolderTrait<TH>>
(cx: *mut JSContext, _obj: HandleObject, this: *const WorkerGlobalScope<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let mut arg0 = vec![];
        if argc > 0 {
            arg0.reserve(argc as usize - 0);
            for variadicArg in 0..argc {
                let slot: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(variadicArg), StringificationBehavior::Default) {
                    Ok(ConversionResult::Success(strval)) => strval,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                arg0.push(slot);
            }
        }
        let result: Result<(), Error<TH>> = this.ImportScripts(arg0);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn importScripts_methodinfo<TH: TypeHolderTrait<TH>>() -> JSJitInfo { JSJitInfo {
    call: importScripts::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WorkerGlobalScope as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_navigator<TH: TypeHolderTrait<TH>>
(cx: *mut JSContext, _obj: HandleObject, this: *const WorkerGlobalScope<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<WorkerNavigator<TH>> = this.Navigator();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn navigator_getterinfo<TH: TypeHolderTrait<TH>>() -> JSJitInfo { JSJitInfo {
    call: get_navigator::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WorkerGlobalScope as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_crypto<TH: TypeHolderTrait<TH>>
(cx: *mut JSContext, _obj: HandleObject, this: *const WorkerGlobalScope<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<Crypto<TH>> = this.Crypto();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn crypto_getterinfo<TH: TypeHolderTrait<TH>>() -> JSJitInfo { JSJitInfo {
    call: get_crypto::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WorkerGlobalScope as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_origin<TH: TypeHolderTrait<TH>>
(cx: *mut JSContext, _obj: HandleObject, this: *const WorkerGlobalScope<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: USVString = this.Origin();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_origin<TH: TypeHolderTrait<TH>>
(cx: *mut JSContext, obj: HandleObject, this: *const WorkerGlobalScope<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        JS_DefineProperty(cx, obj, b"origin\0" as *const u8 as *const libc::c_char,
                          args.get(0), JSPROP_ENUMERATE, None, None)
    }), false);
}


fn origin_getterinfo<TH: TypeHolderTrait<TH>>() -> JSJitInfo { JSJitInfo {
    call: get_origin::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WorkerGlobalScope as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn origin_setterinfo<TH: TypeHolderTrait<TH>>() -> JSJitInfo { JSJitInfo {
    call: set_origin::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WorkerGlobalScope as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn btoa<TH: TypeHolderTrait<TH>>
(cx: *mut JSContext, _obj: HandleObject, this: *const WorkerGlobalScope<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WorkerGlobalScope.btoa\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: Result<DOMString, Error<TH>> = this.Btoa(arg0);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn btoa_methodinfo<TH: TypeHolderTrait<TH>>() -> JSJitInfo { JSJitInfo {
    call: btoa::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WorkerGlobalScope as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn atob<TH: TypeHolderTrait<TH>>
(cx: *mut JSContext, _obj: HandleObject, this: *const WorkerGlobalScope<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WorkerGlobalScope.atob\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: Result<DOMString, Error<TH>> = this.Atob(arg0);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn atob_methodinfo<TH: TypeHolderTrait<TH>>() -> JSJitInfo { JSJitInfo {
    call: atob::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WorkerGlobalScope as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_STRING as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn setTimeout<TH: TypeHolderTrait<TH>>
(cx: *mut JSContext, _obj: HandleObject, this: *const WorkerGlobalScope<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        let argcount = cmp::min(argc, 3);
        match argcount {
            1 => {
                if args.get(0).get().is_object() && !is_platform_object(args.get(0).get().to_object()) {
                    let arg0: Rc<Function<TH>> = if args.get(0).get().is_object() {
                        if IsCallable(args.get(0).get().to_object()) {
                            Function::new(cx, args.get(0).get().to_object())
                        } else {
                            throw_type_error(cx, "Value is not callable.");
                            return false;

                        }
                    } else {
                        throw_type_error(cx, "Value is not an object.");
                        return false;

                    };
                    let arg1: i32 = if args.get(1).is_undefined() {
                        0
                    } else {
                        match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return false;

                            }
                            _ => { return false;
                         }
                        }
                    };
                    let mut arg2 = vec![];
                    if argc > 2 {
                        arg2.reserve(argc as usize - 2);
                        for variadicArg in 2..argc {
                            let slot: HandleValue = args.get(variadicArg);
                            arg2.push(slot);
                        }
                    }
                    let result: i32 = this.SetTimeout(cx, arg0, arg1, arg2);

                    (result).to_jsval(cx, args.rval());
                    return true;
                }
                let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
                    Ok(ConversionResult::Success(strval)) => strval,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                let arg1: i32 = if args.get(1).is_undefined() {
                    0
                } else {
                    match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                        Ok(ConversionResult::Success(v)) => v,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     }
                    }
                };
                let mut arg2 = vec![];
                if argc > 2 {
                    arg2.reserve(argc as usize - 2);
                    for variadicArg in 2..argc {
                        let slot: HandleValue = args.get(variadicArg);
                        arg2.push(slot);
                    }
                }
                let result: i32 = this.SetTimeout_(cx, arg0, arg1, arg2);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            2 => {
                if args.get(0).get().is_object() && !is_platform_object(args.get(0).get().to_object()) {
                    let arg0: Rc<Function<TH>> = if args.get(0).get().is_object() {
                        if IsCallable(args.get(0).get().to_object()) {
                            Function::new(cx, args.get(0).get().to_object())
                        } else {
                            throw_type_error(cx, "Value is not callable.");
                            return false;

                        }
                    } else {
                        throw_type_error(cx, "Value is not an object.");
                        return false;

                    };
                    let arg1: i32 = if args.get(1).is_undefined() {
                        0
                    } else {
                        match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return false;

                            }
                            _ => { return false;
                         }
                        }
                    };
                    let mut arg2 = vec![];
                    if argc > 2 {
                        arg2.reserve(argc as usize - 2);
                        for variadicArg in 2..argc {
                            let slot: HandleValue = args.get(variadicArg);
                            arg2.push(slot);
                        }
                    }
                    let result: i32 = this.SetTimeout(cx, arg0, arg1, arg2);

                    (result).to_jsval(cx, args.rval());
                    return true;
                }
                let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
                    Ok(ConversionResult::Success(strval)) => strval,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                let arg1: i32 = if args.get(1).is_undefined() {
                    0
                } else {
                    match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                        Ok(ConversionResult::Success(v)) => v,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     }
                    }
                };
                let mut arg2 = vec![];
                if argc > 2 {
                    arg2.reserve(argc as usize - 2);
                    for variadicArg in 2..argc {
                        let slot: HandleValue = args.get(variadicArg);
                        arg2.push(slot);
                    }
                }
                let result: i32 = this.SetTimeout_(cx, arg0, arg1, arg2);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            3 => {
                if args.get(0).get().is_object() && !is_platform_object(args.get(0).get().to_object()) {
                    let arg0: Rc<Function<TH>> = if args.get(0).get().is_object() {
                        if IsCallable(args.get(0).get().to_object()) {
                            Function::new(cx, args.get(0).get().to_object())
                        } else {
                            throw_type_error(cx, "Value is not callable.");
                            return false;

                        }
                    } else {
                        throw_type_error(cx, "Value is not an object.");
                        return false;

                    };
                    let arg1: i32 = if args.get(1).is_undefined() {
                        0
                    } else {
                        match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return false;

                            }
                            _ => { return false;
                         }
                        }
                    };
                    let mut arg2 = vec![];
                    if argc > 2 {
                        arg2.reserve(argc as usize - 2);
                        for variadicArg in 2..argc {
                            let slot: HandleValue = args.get(variadicArg);
                            arg2.push(slot);
                        }
                    }
                    let result: i32 = this.SetTimeout(cx, arg0, arg1, arg2);

                    (result).to_jsval(cx, args.rval());
                    return true;
                }
                let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
                    Ok(ConversionResult::Success(strval)) => strval,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                let arg1: i32 = if args.get(1).is_undefined() {
                    0
                } else {
                    match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                        Ok(ConversionResult::Success(v)) => v,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     }
                    }
                };
                let mut arg2 = vec![];
                if argc > 2 {
                    arg2.reserve(argc as usize - 2);
                    for variadicArg in 2..argc {
                        let slot: HandleValue = args.get(variadicArg);
                        arg2.push(slot);
                    }
                }
                let result: i32 = this.SetTimeout_(cx, arg0, arg1, arg2);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            _ => {
                throw_type_error(cx, "Not enough arguments to \"WorkerGlobalScope.setTimeout\".");
                return false;
            }
        }
    }), false);
}


fn setTimeout_methodinfo<TH: TypeHolderTrait<TH>>() -> JSJitInfo { JSJitInfo {
    call: setTimeout::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WorkerGlobalScope as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn clearTimeout<TH: TypeHolderTrait<TH>>
(cx: *mut JSContext, _obj: HandleObject, this: *const WorkerGlobalScope<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: i32 = if args.get(0).is_undefined() {
            0
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.ClearTimeout(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn clearTimeout_methodinfo<TH: TypeHolderTrait<TH>>() -> JSJitInfo { JSJitInfo {
    call: clearTimeout::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WorkerGlobalScope as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn setInterval<TH: TypeHolderTrait<TH>>
(cx: *mut JSContext, _obj: HandleObject, this: *const WorkerGlobalScope<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        let argcount = cmp::min(argc, 3);
        match argcount {
            1 => {
                if args.get(0).get().is_object() && !is_platform_object(args.get(0).get().to_object()) {
                    let arg0: Rc<Function<TH>> = if args.get(0).get().is_object() {
                        if IsCallable(args.get(0).get().to_object()) {
                            Function::new(cx, args.get(0).get().to_object())
                        } else {
                            throw_type_error(cx, "Value is not callable.");
                            return false;

                        }
                    } else {
                        throw_type_error(cx, "Value is not an object.");
                        return false;

                    };
                    let arg1: i32 = if args.get(1).is_undefined() {
                        0
                    } else {
                        match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return false;

                            }
                            _ => { return false;
                         }
                        }
                    };
                    let mut arg2 = vec![];
                    if argc > 2 {
                        arg2.reserve(argc as usize - 2);
                        for variadicArg in 2..argc {
                            let slot: HandleValue = args.get(variadicArg);
                            arg2.push(slot);
                        }
                    }
                    let result: i32 = this.SetInterval(cx, arg0, arg1, arg2);

                    (result).to_jsval(cx, args.rval());
                    return true;
                }
                let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
                    Ok(ConversionResult::Success(strval)) => strval,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                let arg1: i32 = if args.get(1).is_undefined() {
                    0
                } else {
                    match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                        Ok(ConversionResult::Success(v)) => v,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     }
                    }
                };
                let mut arg2 = vec![];
                if argc > 2 {
                    arg2.reserve(argc as usize - 2);
                    for variadicArg in 2..argc {
                        let slot: HandleValue = args.get(variadicArg);
                        arg2.push(slot);
                    }
                }
                let result: i32 = this.SetInterval_(cx, arg0, arg1, arg2);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            2 => {
                if args.get(0).get().is_object() && !is_platform_object(args.get(0).get().to_object()) {
                    let arg0: Rc<Function<TH>> = if args.get(0).get().is_object() {
                        if IsCallable(args.get(0).get().to_object()) {
                            Function::new(cx, args.get(0).get().to_object())
                        } else {
                            throw_type_error(cx, "Value is not callable.");
                            return false;

                        }
                    } else {
                        throw_type_error(cx, "Value is not an object.");
                        return false;

                    };
                    let arg1: i32 = if args.get(1).is_undefined() {
                        0
                    } else {
                        match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return false;

                            }
                            _ => { return false;
                         }
                        }
                    };
                    let mut arg2 = vec![];
                    if argc > 2 {
                        arg2.reserve(argc as usize - 2);
                        for variadicArg in 2..argc {
                            let slot: HandleValue = args.get(variadicArg);
                            arg2.push(slot);
                        }
                    }
                    let result: i32 = this.SetInterval(cx, arg0, arg1, arg2);

                    (result).to_jsval(cx, args.rval());
                    return true;
                }
                let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
                    Ok(ConversionResult::Success(strval)) => strval,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                let arg1: i32 = if args.get(1).is_undefined() {
                    0
                } else {
                    match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                        Ok(ConversionResult::Success(v)) => v,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     }
                    }
                };
                let mut arg2 = vec![];
                if argc > 2 {
                    arg2.reserve(argc as usize - 2);
                    for variadicArg in 2..argc {
                        let slot: HandleValue = args.get(variadicArg);
                        arg2.push(slot);
                    }
                }
                let result: i32 = this.SetInterval_(cx, arg0, arg1, arg2);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            3 => {
                if args.get(0).get().is_object() && !is_platform_object(args.get(0).get().to_object()) {
                    let arg0: Rc<Function<TH>> = if args.get(0).get().is_object() {
                        if IsCallable(args.get(0).get().to_object()) {
                            Function::new(cx, args.get(0).get().to_object())
                        } else {
                            throw_type_error(cx, "Value is not callable.");
                            return false;

                        }
                    } else {
                        throw_type_error(cx, "Value is not an object.");
                        return false;

                    };
                    let arg1: i32 = if args.get(1).is_undefined() {
                        0
                    } else {
                        match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                            Ok(ConversionResult::Success(v)) => v,
                            Ok(ConversionResult::Failure(error)) => {
                                throw_type_error(cx, &error);
                                return false;

                            }
                            _ => { return false;
                         }
                        }
                    };
                    let mut arg2 = vec![];
                    if argc > 2 {
                        arg2.reserve(argc as usize - 2);
                        for variadicArg in 2..argc {
                            let slot: HandleValue = args.get(variadicArg);
                            arg2.push(slot);
                        }
                    }
                    let result: i32 = this.SetInterval(cx, arg0, arg1, arg2);

                    (result).to_jsval(cx, args.rval());
                    return true;
                }
                let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
                    Ok(ConversionResult::Success(strval)) => strval,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                let arg1: i32 = if args.get(1).is_undefined() {
                    0
                } else {
                    match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                        Ok(ConversionResult::Success(v)) => v,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     }
                    }
                };
                let mut arg2 = vec![];
                if argc > 2 {
                    arg2.reserve(argc as usize - 2);
                    for variadicArg in 2..argc {
                        let slot: HandleValue = args.get(variadicArg);
                        arg2.push(slot);
                    }
                }
                let result: i32 = this.SetInterval_(cx, arg0, arg1, arg2);

                (result).to_jsval(cx, args.rval());
                return true;
            }
            _ => {
                throw_type_error(cx, "Not enough arguments to \"WorkerGlobalScope.setInterval\".");
                return false;
            }
        }
    }), false);
}


fn setInterval_methodinfo<TH: TypeHolderTrait<TH>>() -> JSJitInfo { JSJitInfo {
    call: setInterval::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WorkerGlobalScope as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn clearInterval<TH: TypeHolderTrait<TH>>
(cx: *mut JSContext, _obj: HandleObject, this: *const WorkerGlobalScope<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let arg0: i32 = if args.get(0).is_undefined() {
            0
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                Ok(ConversionResult::Success(v)) => v,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             }
            }
        };
        let result: () = this.ClearInterval(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn clearInterval_methodinfo<TH: TypeHolderTrait<TH>>() -> JSJitInfo { JSJitInfo {
    call: clearInterval::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WorkerGlobalScope as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn fetch<TH: TypeHolderTrait<TH>>
(cx: *mut JSContext, _obj: HandleObject, this: *const WorkerGlobalScope<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WorkerGlobalScope.fetch\".");
            return false;
        }
        let arg0: UnionTypes::RequestOrUSVString<TH> = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let arg1: RootedTraceableBox<dom::bindings::codegen::Bindings::RequestBinding::RequestInit<TH>> = if args.get(1).is_undefined() {
            dom::bindings::codegen::Bindings::RequestBinding::RequestInit::empty(cx)
        } else {
            match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
                Ok(ConversionResult::Success(dictionary)) => dictionary,
                Ok(ConversionResult::Failure(error)) => {
                    throw_type_error(cx, &error);
                    return false;

                }
                _ => { return false;
             },
            }
        };
        let result: Rc<Promise<TH>> = this.Fetch(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn fetch_methodinfo<TH: TypeHolderTrait<TH>>() -> JSJitInfo { JSJitInfo {
    call: fetch::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WorkerGlobalScope as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_performance<TH: TypeHolderTrait<TH>>
(cx: *mut JSContext, _obj: HandleObject, this: *const WorkerGlobalScope<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<Performance<TH>> = this.Performance();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}

unsafe extern fn set_performance<TH: TypeHolderTrait<TH>>
(cx: *mut JSContext, obj: HandleObject, this: *const WorkerGlobalScope<TH>, args: JSJitSetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        JS_DefineProperty(cx, obj, b"performance\0" as *const u8 as *const libc::c_char,
                          args.get(0), JSPROP_ENUMERATE, None, None)
    }), false);
}


fn performance_getterinfo<TH: TypeHolderTrait<TH>>() -> JSJitInfo { JSJitInfo {
    call: get_performance::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WorkerGlobalScope as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

fn performance_setterinfo<TH: TypeHolderTrait<TH>>() -> JSJitInfo { JSJitInfo {
    call: set_performance::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WorkerGlobalScope as u16,
    depth: 2,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Setter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

impl<TH: TypeHolderTrait<TH>> IDLInterface for WorkerGlobalScope<TH> {
    #[inline]
    fn derives(class: &'static DOMClass) -> bool {
        class.interface_chain[2] == PrototypeList::ID::WorkerGlobalScope
    }
}

impl<TH: TypeHolderTrait<TH>> PartialEq for WorkerGlobalScope<TH> {
    fn eq(&self, other: &WorkerGlobalScope<TH>) -> bool {
        self as *const WorkerGlobalScope<TH> == &*other
    }
}

pub trait WorkerGlobalScopeMethods<TH: TypeHolderTrait<TH>> {
    fn Self_(&self) -> DomRoot<WorkerGlobalScope<TH>>;
    fn Location(&self) -> DomRoot<WorkerLocation<TH>>;
    fn GetOnerror(&self) -> Option<Rc<dom::bindings::codegen::Bindings::EventHandlerBinding::OnErrorEventHandlerNonNull<TH>>>;
    fn SetOnerror(&self, value: Option<Rc<OnErrorEventHandlerNonNull<TH>>>) -> ();
    fn ImportScripts(&self, urls: Vec<DOMString>) -> Fallible<(), TH>;
    fn Navigator(&self) -> DomRoot<WorkerNavigator<TH>>;
    fn Crypto(&self) -> DomRoot<Crypto<TH>>;
    fn Origin(&self) -> USVString;
    fn Btoa(&self, data: DOMString) -> Fallible<DOMString, TH>;
    fn Atob(&self, data: DOMString) -> Fallible<DOMString, TH>;
    unsafe fn SetTimeout(&self, cx: *mut JSContext, handler: Rc<Function<TH>>, timeout: i32, arguments: Vec<HandleValue>) -> i32;
    unsafe fn SetTimeout_(&self, cx: *mut JSContext, handler: DOMString, timeout: i32, arguments: Vec<HandleValue>) -> i32;
    fn ClearTimeout(&self, handle: i32) -> ();
    unsafe fn SetInterval(&self, cx: *mut JSContext, handler: Rc<Function<TH>>, timeout: i32, arguments: Vec<HandleValue>) -> i32;
    unsafe fn SetInterval_(&self, cx: *mut JSContext, handler: DOMString, timeout: i32, arguments: Vec<HandleValue>) -> i32;
    fn ClearInterval(&self, handle: i32) -> ();
    fn Fetch(&self, input: UnionTypes::RequestOrUSVString<TH>, init: RootedTraceableBox<dom::bindings::codegen::Bindings::RequestBinding::RequestInit<TH>>) -> Rc<Promise<TH>>;
    fn Performance(&self) -> DomRoot<Performance<TH>>;
}
fn sMethods_specs<TH: TypeHolderTrait<TH>>() -> &'static [&'static[JSFunctionSpec]] { &[
&[
    JSFunctionSpec {
        name: b"importScripts\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &importScripts_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"btoa\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &btoa_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"atob\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &atob_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"setTimeout\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &setTimeout_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"clearTimeout\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &clearTimeout_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"setInterval\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &setInterval_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"clearInterval\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &clearInterval_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"fetch\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &fetch_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]

]}
fn sMethods<TH: TypeHolderTrait<TH>>() -> &'static [Guard<&'static [JSFunctionSpec]>] { &[
    Guard::new(Condition::Satisfied, sMethods_specs::<TH>()[0])
]}
fn sAttributes_specs<TH: TypeHolderTrait<TH>>() -> &'static [&'static[JSPropertySpec]] { &[
&[
    JSPropertySpec {
        name: b"self\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &self_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"location\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &location_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"onerror\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &onerror_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &onerror_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"navigator\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &navigator_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"crypto\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &crypto_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"origin\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &origin_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &origin_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: b"performance\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &performance_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: Some(generic_setter), info: &performance_setterinfo::<TH>() }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]

]}
fn sAttributes<TH: TypeHolderTrait<TH>>() -> &'static [Guard<&'static [JSPropertySpec]>] { &[
    Guard::new(Condition::Satisfied, sAttributes_specs::<TH>()[0])
]}

pub unsafe fn GetProtoObject<TH: TypeHolderTrait<TH>>
(cx: *mut JSContext, global: HandleObject, mut rval: MutableHandleObject) {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    assert!(((*get_object_class(global.get())).flags & JSCLASS_DOM_GLOBAL) != 0);

    /* Check to see whether the interface objects are already installed */
    let proto_or_iface_array = get_proto_or_iface_array(global.get());
    rval.set((*proto_or_iface_array)[PrototypeList::ID::WorkerGlobalScope as usize]);
    if !rval.get().is_null() {
        return;
    }

    CreateInterfaceObjects(cx, global, proto_or_iface_array);
    rval.set((*proto_or_iface_array)[PrototypeList::ID::WorkerGlobalScope as usize]);
    assert!(!rval.get().is_null());

}

static PrototypeClass: JSClass = JSClass {
    name: b"WorkerGlobalScopePrototype\0" as *const u8 as *const libc::c_char,
    flags:
        // JSCLASS_HAS_RESERVED_SLOTS(0)
        (0 & JSCLASS_RESERVED_SLOTS_MASK) << JSCLASS_RESERVED_SLOTS_SHIFT,
    cOps: 0 as *const _,
    reserved: [0 as *mut os::raw::c_void; 3]
};

static INTERFACE_OBJECT_CLASS: NonCallbackInterfaceObjectClass =
    NonCallbackInterfaceObjectClass::new(
        &InterfaceConstructorBehavior::throw(),
        b"function WorkerGlobalScope() {\n    [native code]\n}",
        PrototypeList::ID::WorkerGlobalScope,
        2);

pub unsafe fn GetConstructorObject<TH: TypeHolderTrait<TH>>
(cx: *mut JSContext, global: HandleObject, mut rval: MutableHandleObject) {
    /* Get the interface object for this class.  This will create the object as
       needed. */
    assert!(((*get_object_class(global.get())).flags & JSCLASS_DOM_GLOBAL) != 0);

    /* Check to see whether the interface objects are already installed */
    let proto_or_iface_array = get_proto_or_iface_array(global.get());
    rval.set((*proto_or_iface_array)[PrototypeList::Constructor::WorkerGlobalScope as usize]);
    if !rval.get().is_null() {
        return;
    }

    CreateInterfaceObjects(cx, global, proto_or_iface_array);
    rval.set((*proto_or_iface_array)[PrototypeList::Constructor::WorkerGlobalScope as usize]);
    assert!(!rval.get().is_null());

}

pub unsafe fn DefineDOMInterface<TH: TypeHolderTrait<TH>>
(cx: *mut JSContext, global: HandleObject) {
    assert!(!global.get().is_null());

    if !ConstructorEnabled(cx, global) {
        return;
    }

    rooted!(in(cx) let mut proto = ptr::null_mut::<JSObject>());
    GetProtoObject(cx, global, proto.handle_mut());
    assert!(!proto.is_null());
}

unsafe fn ConstructorEnabled<TH: TypeHolderTrait<TH>>
(aCx: *mut JSContext, aObj: HandleObject) -> bool {
    is_exposed_in(aObj, InterfaceObjectMap::Globals::DEDICATED_WORKER_GLOBAL_SCOPE | InterfaceObjectMap::Globals::SERVICE_WORKER_GLOBAL_SCOPE)
}

unsafe fn CreateInterfaceObjects<TH: TypeHolderTrait<TH>>
(cx: *mut JSContext, global: HandleObject, cache: *mut ProtoOrIfaceArray) {
    rooted!(in(cx) let mut prototype_proto = ptr::null_mut::<JSObject>());
    EventTargetBinding::GetProtoObject(cx, global, prototype_proto.handle_mut());
    assert!(!prototype_proto.is_null());

    rooted!(in(cx) let mut prototype = ptr::null_mut::<JSObject>());
    create_interface_prototype_object(cx,
                                      prototype_proto.handle().into(),
                                      &PrototypeClass,
                                      sMethods::<TH>(),
                                      sAttributes::<TH>(),
                                      &[],
                                      &[],
                                      prototype.handle_mut().into());
    assert!(!prototype.is_null());
    assert!((*cache)[PrototypeList::ID::WorkerGlobalScope as usize].is_null());
    (*cache)[PrototypeList::ID::WorkerGlobalScope as usize] = prototype.get();
    <*mut JSObject>::post_barrier((*cache).as_mut_ptr().offset(PrototypeList::ID::WorkerGlobalScope as isize),
                                  ptr::null_mut(),
                                  prototype.get());


    rooted!(in(cx) let mut interface_proto = ptr::null_mut::<JSObject>());
    EventTargetBinding::GetConstructorObject(cx, global, interface_proto.handle_mut());
    assert!(!interface_proto.is_null());

    rooted!(in(cx) let mut interface = ptr::null_mut::<JSObject>());
    create_noncallback_interface_object(cx,
                                        global.into(),
                                        interface_proto.handle(),
                                        &INTERFACE_OBJECT_CLASS,
                                        &[],
                                        &[],
                                        &[],
                                        prototype.handle(),
                                        b"WorkerGlobalScope\0",
                                        0,
                                        interface.handle_mut());
    assert!(!interface.is_null());
    assert!((*cache)[PrototypeList::Constructor::WorkerGlobalScope as usize].is_null());
    (*cache)[PrototypeList::Constructor::WorkerGlobalScope as usize] = interface.get();
    <*mut JSObject>::post_barrier((*cache).as_mut_ptr().offset(PrototypeList::Constructor::WorkerGlobalScope as isize),
                                  ptr::null_mut(),
                                  interface.get());

}
} // mod WorkerGlobalScopeBinding


